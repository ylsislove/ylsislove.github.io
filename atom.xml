<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.aayu.today</id>
    <title>学无止境</title>
    <subtitle>世界上大部分事，都没太大意义。真理与热爱除外</subtitle>
    <icon>https://blog.aayu.today/images/favicon.ico</icon>
    <link href="https://blog.aayu.today" />
    <author>
      <name>宇凌喵</name>
    </author>
    <updated>2024-07-27T08:23:47.000Z</updated>
    <category term="HoloLens" />
    <category term=" NAS" />
    <entry>
        <id>https://blog.aayu.today/nas/zspace/20240727/</id>
        <title>手拉手教你部署思源笔记+发布服务+外网访问</title>
        <link rel="alternate" href="https://blog.aayu.today/nas/zspace/20240727/"/>
        <content type="html">&lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;h3 id=&#34;官方思源笔记-docker-版权限问题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#官方思源笔记-docker-版权限问题&#34;&gt;#&lt;/a&gt; 官方思源笔记 Docker 版权限问题&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;官方思源笔记 Docker 地址：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL2IzbG9nL3NpeXVhbg==&#34;&gt;https://hub.docker.com/r/b3log/siyuan&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在极空间部署官方的 Docker 镜像会遇到权限问题，具体表现为映射文件夹后启动会报错，如下：&lt;/p&gt;
&lt;p class=&#34;gallery&#34; data-height=&#34;240&#34;&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/11/202408110006812.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/11/202408110006707.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/11/202408110009015.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;报错原因是因为：官方的思源笔记 Docker 镜像是使用的默认创建的普通用户  &lt;code&gt;siyuan&lt;/code&gt; （uid 1000/gid 1000）来启动内核进程的，但极空间文件夹是 root 用户权限，当创建 docker 镜像时做了文件夹映射后，普通用户  &lt;code&gt;siyuan&lt;/code&gt;  是没有权限在设置的目录下创建新的文件夹&lt;/p&gt;
&lt;p&gt;所以报错原因就如上图所示：在设置的目录下创建 temp 文件夹失败，镜像就会启动不成功，一直反复重启。&lt;/p&gt;
&lt;h2 id=&#34;修改了权限后的思源笔记-docker-镜像&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#修改了权限后的思源笔记-docker-镜像&#34;&gt;#&lt;/a&gt; 修改了权限后的思源笔记 Docker 镜像&lt;/h2&gt;
&lt;p&gt;借助极空间论坛 zsource 大佬镜像自助编译的思路，将思源笔记官方的 Dockerfile 文件里的启动用户改为 root 用户，完美解决创建 Docker 容器文件夹路径映射后权限不足的问题。&lt;/p&gt;
&lt;p&gt;修改了 Dockerfile 文件的代码仓我也上传到了 GitHub 上，地址：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3lsc2lzbG92ZS9zaXl1YW4tejQ=&#34;&gt;https://github.com/ylsislove/siyuan-z4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同时借助 GitHub Action，可以自助编译成不同架构的 Docker 镜像，这样极空间 z4 和 z2Pro 等不同设备都可以用我修改了权限后的思源笔记镜像了。这也是我想写这篇文章的一个原因，让更多的小白用户都能用上思源笔记，支持开源开发者！&lt;/p&gt;
&lt;p&gt;后面如果我不出意外，应该会和官方镜像保持同步更新的节奏～&lt;/p&gt;
&lt;h2 id=&#34;部署思源笔记&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#部署思源笔记&#34;&gt;#&lt;/a&gt; 部署思源笔记&lt;/h2&gt;
&lt;h3 id=&#34;下载镜像&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#下载镜像&#34;&gt;#&lt;/a&gt; 下载镜像&lt;/h3&gt;
&lt;p&gt;部署就很简单了，首先在极空间 Docker 镜像界面搜索 siyuan，然后找到 ylsislove/siyuan 版本的，点击下载。&lt;/p&gt;
&lt;p&gt;这里可能会有用户碰到点击下载后显示不出版本信息，或镜像无法拉取的问题。这是因为国内有些地区的网络无法访问 Docker Hub，所以拉取不到镜像。有这个问题的用户可以在博客给我留言，我抽空就把最新镜像导出成文件，上传到极空间后，就可以在本地镜像下用上传文件的方式导入镜像了。&lt;/p&gt;
&lt;p&gt;选择当前最新版本，点击下载，下载完成后就可以在本地镜像中看到，双击开始配置容器。&lt;/p&gt;
&lt;p class=&#34;gallery&#34; data-height=&#34;240&#34;&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/11/202408110037907.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/12/202408122328480.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/12/202408122328472.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置容器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#配置容器&#34;&gt;#&lt;/a&gt; 配置容器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基础设置：可以根据自己需求设置，名称随便取&lt;/li&gt;
&lt;li&gt;文件夹路径：需要选择一个极空间文件夹，来持久化保存我们的文件&lt;/li&gt;
&lt;li&gt;网络：保持默认就行&lt;/li&gt;
&lt;li&gt;端口：这里需要设置两个端口映射， &lt;code&gt;6806&lt;/code&gt;  是思源笔记访问端口， &lt;code&gt;6807&lt;/code&gt;  可以在思源笔记里配置成服务发布端口。所以这两个端口都需要映射出去，我选择映射成 &lt;code&gt;26806&lt;/code&gt;  和 &lt;code&gt;26807&lt;/code&gt;  这两个空闲端口，小伙伴也可以自己映射成其他端口，都是 no problem&lt;/li&gt;
&lt;li&gt;别名：保持默认即可&lt;/li&gt;
&lt;li&gt;环境：也保持默认即可， &lt;code&gt;ACCESSAUTHCODE&lt;/code&gt;  字段我们在命令那一栏配置&lt;/li&gt;
&lt;li&gt;命令：这里比较重要，我们要在自定义命令中配置工作空间路径，授权码，和默认语言这三项，如图片所示，把我下面这行配置粘过去即可，记得自己改一下授权密码&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight txt&#34;&gt;&lt;figcaption data-lang=&#34;txt&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;--workspace=/siyuan/workspace --accessAuthCode=123456789 --lang=zh_CN&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;能力：保持默认即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&#34;gallery&#34; data-height=&#34;150&#34;&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/12/202408122331837.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/12/202408122331757.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/12/202408122332875.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/12/202408122333410.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p class=&#34;gallery&#34; data-height=&#34;150&#34;&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/12/202408122338320.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/12/202408122339184.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/12/202408122344516.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/12/202408122344964.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;最后点击应用，不出意外的话容器就会创建成功啦，创建成功后，记得点击容器的日志按钮，出现如下日志，说明容器配置的没问题。&lt;/p&gt;
&lt;p&gt;再打开我们在极空间映射的文件夹，也正常映射出了文件。&lt;/p&gt;
&lt;p&gt;最后，在浏览器访问 &lt;code&gt;极空间IP:26806&lt;/code&gt;  地址，能正常访问思源笔记，思源笔记部署篇完美结束～&lt;/p&gt;
&lt;p class=&#34;gallery&#34; data-height=&#34;150&#34;&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/12/202408122347518.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/12/202408122346628.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/12/202408122349553.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/12/202408122351891.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;发布服务&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#发布服务&#34;&gt;#&lt;/a&gt; 发布服务&lt;/h2&gt;
&lt;p&gt;在思源笔记左上角点击「 设置 」，找到「 发布 」选项，然后打开发布功能&lt;/p&gt;
&lt;p&gt;注意端口要和容器中设置的端口对应。&lt;/p&gt;
&lt;p&gt;设置完毕后，就可以在浏览器访问 &lt;code&gt;极空间IP:26807&lt;/code&gt;  地址，就能看到笔记被发布出去了～&lt;/p&gt;
&lt;p&gt;发布模式（端口 6807）和普通模式（端口 6806）的区别就是：发布模式访问笔记本是只读的，其他人是无法更改你的笔记内容的，只能浏览，这对于喜欢分享笔记的朋友来说就非常友好啦～&lt;/p&gt;
&lt;p class=&#34;gallery&#34; data-height=&#34;240&#34;&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/18/202408182346847.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/18/202408182352007.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;外网访问&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#外网访问&#34;&gt;#&lt;/a&gt; 外网访问&lt;/h2&gt;
&lt;p&gt;外网访问的方式有很多，比如如果有小伙伴能向运营商申请到公网 IP 的话，直接在浏览器输入公网 IP:26806 就能访问到思源笔记了。&lt;/p&gt;
&lt;p&gt;但有些地区的运营商可能不会向普通民众开放公网 IP，所以这里我们就需要借助一台能公网访问的云服务器来实现内网穿透，使用云服务的公网 IP 来访问极空间内网的思源笔记。&lt;/p&gt;
&lt;p&gt;云服务器的选购也有很多种，比如阿里云、腾讯云、华为云等等。之前我一直用的是腾讯云的云服务器，最近发现在腾讯云购买一台新的服务器价格贵的有点离谱&lt;/p&gt;
&lt;p&gt;所以我这里以炭云的云服务器为例，小伙伴也可以自行选购其他家更便宜的云服务器～&lt;/p&gt;
&lt;p&gt;炭云云服务器页面：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY29hbGNsb3VkLm5ldC9hZmYucGhwP2FmZj03MTQ=&#34;&gt;https://www.coalcloud.net/aff.php?aff=714&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以在右上角先注册一个账号，注册完成后，选择云服务器栏目下的「 香港 HK BGP PRO（EQHK2）」服务器，选择香港地区有挺多好处的，比如网络访问不受限，可以直接拉取 Docker 镜像或 GitHub 仓库，域名不用备案等等～&lt;/p&gt;
&lt;p&gt;不过推荐大家有时间还是去搞一下域名备案，这样以后万一炭云跑路了，也可以直接把域名直接挂到国内的云服务器上，不用担心域名访问受限 hh~&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/19/202408192250537.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到有一款比较便宜的云服务器，1 核 500M 内存，虽然配置比较拉，但带宽比腾讯云之类的云服务器慷慨多了，月租 19 块钱还要什么自行车哈哈哈&lt;/p&gt;
&lt;p&gt;配置也简简单单，镜像选择 &lt;code&gt;Ubuntu 20.04&lt;/code&gt; ，这里我就选择按月支付，用支付宝支付，轻轻松松购买完成～&lt;/p&gt;
&lt;p class=&#34;gallery&#34; data-height=&#34;150&#34;&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/19/202408192252724.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/19/202408192259785.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/19/202408192305369.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;购买完成后，可以在左侧的云服务器栏目中，看到我们购买后的云服务器，点进去后就能看到更详细的信息～&lt;/p&gt;
&lt;p&gt;耐心等待服务器创建完成，在这个过程中，我们需要安装一款 SSH 客户端，用来连接我们的云服务器，这里我使用的是 Termius，小伙伴也可以选择其他自己更喜欢的软件，都没问题～&lt;/p&gt;
&lt;p&gt;Termius 下载地址：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly90ZXJtaXVzLmNvbS9kb3dubG9hZC93aW5kb3dz&#34;&gt;https://termius.com/download/windows&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果因为网络原因下载太慢的话，我把安装包也放到了我的云盘里，也可以直接从我的云盘里下载～&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9wYW4uYWF5dS50b2RheS8/ZGlyPS8lRTUlQjglQjglRTclOTQlQTglRTglQkQlQUYlRTQlQkIlQjYlRTUlOTIlOEMlRTUlQjclQTUlRTUlODUlQjc=&#34;&gt;阿宇云盘&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;安装完成后，看到我们浏览器也配置完毕了，接下来就可以连接我们的云服务器了，跟着我的操作来，肯定没问题～&lt;/p&gt;
&lt;p&gt;首先在服务器详情界面确认我们的 IP 地址和 Root 密码，然后在 Termius 里点击 Add，选择 New Host，然后输入我们的 IP 地址，用户名输入 root，密码输入我们的 Root 密码，配置完成后，点击右上角退出编辑界面～&lt;/p&gt;
&lt;p class=&#34;gallery&#34; data-height=&#34;150&#34;&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/19/202408192321917.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/19/202408192323919.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/19/202408192327018.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在主页面双击我们刚刚配置的服务器，然后选择 &lt;code&gt;Add and continue&lt;/code&gt; ，就能成功连接到我们的云服务器啦～&lt;/p&gt;
&lt;p class=&#34;gallery&#34; data-height=&#34;240&#34;&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/19/202408192329231.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/08/19/202408192334307.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;待更～&lt;/p&gt;
&lt;h2 id=&#34;绑定域名&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#绑定域名&#34;&gt;#&lt;/a&gt; 绑定域名&lt;/h2&gt;
&lt;p&gt;待更～&lt;/p&gt;
&lt;h2 id=&#34;webdav备份&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#webdav备份&#34;&gt;#&lt;/a&gt; WebDAV 备份&lt;/h2&gt;
&lt;p&gt;待更～&lt;/p&gt;
&lt;p&gt;~&lt;/p&gt;
&lt;p&gt;~&lt;/p&gt;
&lt;p&gt;~&lt;/p&gt;
&lt;p&gt;这段时间要经常加班，所以只能尽量抽时间把这篇教程写完，喜欢的话欢迎在评论区给我留言，（づ￣3￣）づ╭❤～&lt;/p&gt;
&lt;p&gt;~&lt;/p&gt;
&lt;p&gt;~&lt;/p&gt;
&lt;p&gt;~&lt;/p&gt;
</content>
        <category term="我的NAS捣鼓笔记" scheme="https://blog.aayu.today/categories/nas/" />
        <category term="极空间" scheme="https://blog.aayu.today/categories/nas/%E6%9E%81%E7%A9%BA%E9%97%B4/" />
        <category term="NAS" scheme="https://blog.aayu.today/tags/NAS/" />
        <category term="极空间" scheme="https://blog.aayu.today/tags/%E6%9E%81%E7%A9%BA%E9%97%B4/" />
        <category term="思源笔记" scheme="https://blog.aayu.today/tags/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0/" />
        <updated>2024-07-27T08:23:47.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/leisure/forever/20240616/</id>
        <title>硕士生涯致谢</title>
        <link rel="alternate" href="https://blog.aayu.today/leisure/forever/20240616/"/>
        <content type="html">&lt;p&gt;三年时光转瞬即逝。回顾了下我的本科毕设致谢，在致谢的最后我写到：“感谢自己，能找到自己真正热爱的事物，并为之不断努力奋斗。未来如果能推动 VR/AR/MR 事业的发展，就再好不过了”。很开心，到目前为止我依然在努力朝着我的梦想前进，不忘初心。&lt;/p&gt;
&lt;p&gt;感谢我的导师关庆锋老师，有太多感激的话想对关老师说了。在我刚入研一的那会，老师要确定我们几个新生的研究方向，记得老师当时给我暂定的方向是并行计算，这也是实验室的大课题之一。但当时，我对于硬件开发会更感兴趣，因为我的本科专业是软件工程，入研究生特意选了电子信息，也是希望可以培养下自己在硬件方面的能力，这样我脑海里很多有意思的想法，我才有能力动手把它们变为现实。关老师听了我的想法之后，很支持我有自己感兴趣的方向，也恰好手里有物联网开发的项目，于是乎，我如愿以偿的朝着我的梦想前进了一步。也正是我迈出的这一步，让我在三个月后到绵阳出差部署物联网设备时，遇到了我的人生伴侣付志玲，哈哈这是后话了。&lt;/p&gt;
&lt;p&gt;另一件感动也让我十分难忘的事是，在研二下学期，我们要确定自己的毕业设计课题了。记得那天，我走到关老师办公室，给老师详细阐述了我想做 AR 相关毕设的想法，关老师听的很认真。在确认了我想法的可行性后，老师支持和鼓励我大胆去做，大胆去尝试，并用经费购买了一套 AR 眼镜作为设备支撑。正是关老师的这份支持和信任，让我的研究生三年过的十分有意义。一日为师，终身为父，不管今后我的成就如何，王宇都会永远感恩关老师对我的指导和教诲。&lt;/p&gt;
&lt;p&gt;研究生三年也是快乐的三年，从刚入实验室的懵懵懂懂，到和大家一起出去唱歌、吃饭，玩剧本杀，真的充满了很多难忘快乐的回忆。记得第一次和师兄师姐们在校园里玩剧本杀，各自有各自的角色扮演，从扑朔迷离的剧情中找寻真相，到最后知道真相后的哈哈大笑。还有在光谷世界城玩的那一次，有人扮演话事狗，有人扮演黑帮狗老大，还有各种情报交易、物品交易等，这些充满回忆的场景还历历在目。岁月悠悠，时光易逝，感谢实验室杨雪师姐、嘉琪师姐和雷司琪师姐，以及梁宇云师兄、哲玮师兄、钟英强师兄和顾峻峰师兄对我学业和生活的指导。感谢我的小伙伴阿董、阿瑛小熊、老刘、老朱、老罗、郭郭、武浩和阚宏扬，和你们的干饭闲聊时光也是我最快乐的日子。还有派派，解决了我很多细节处理上的问题。感谢周欣萌师妹，帮我处理了很多报销材料。除此之外，也感谢何明洋师弟、戴良洋师弟以及上述师兄师姐和同门，帮助我采集了很多宝贵的研究数据。&lt;/p&gt;
&lt;p&gt;在生活中，感谢我的伴侣付志玲。记得第一次见到你是在出差的机场处，你蹦蹦跳跳的向我走来，哈哈哈给我留下了第一眼深刻的印象。后面，我们一起部署了设备，也一起探讨了很多物联网和羊肚菌种植相关的问题。在研一期间的第一个春节，我鼓起勇气向你表白，很开心，我们在一起啦。后面的日子，纵使我们身处不同的地方，你也会每天给我分享你的生活，你的开心，你的快乐，就像一朵花儿每天都为我绽放。在研三找工作的时期，你将我从懒惰的状态拉起，鼓励我坚持，帮助我投递简历、规划面试时间，如果没有你，我想我的生活肯定会暗淡很多。感谢有你，我想未来的路我们一起走，未来的山我们一起踏，未来的海我们一起过。余生有你，此生无憾。&lt;/p&gt;
&lt;p&gt;学习和生活中还有很多我想感谢的人，感谢姚尧老师，在我找工作迷茫时给我提供了宝贵的建议；感谢羊肚菌种植基地的王定军王总，给物联网项目开发提供了很多有针对性的见解；感谢立创开源平台的启凡科创老师，开源了如此优秀的智能手表硬件，也很热心的在群里解答群友提出的各种各样的问题；感谢北京 XREAL 公司萌萌姐送我的新款 Air2 AR 眼镜，支持我朝着梦想努力，雪中送炭般的善意会让我永远记得；感谢杭州 Rokid 的 Hope 推荐我参加 AR 应用开发大赛，让我体验到 Rokid 系列产品的厉害之处。还有感谢有十年之交的高中同学原殿斌、崔晓霞和周宁，人生又能有多少个十年呢，我们能一起相伴十年真的是太难忘了，难忘和你们一起出去踏青、吃饭、K 歌和打桌球的日子，虽然未来我们要各奔南北了，但若有饭，召必回哈哈。&lt;/p&gt;
&lt;p&gt;也感谢我的爸爸、妈妈、哥哥和姐姐。家人的爱是最无私的爱，家也是我永远的避风港，是我在外面复杂的世界能茁壮成长的底气。虽然爸爸总会唠叨我的英语，但每次和父母通话时，听着父母的声音，内心就会变得无比平静和安心。还有家里我的小侄女王湑菡，每次打电话时你的声声 “二爸” 总是能让我的心充满幸福，希望，希望家里每一个人都能平平安安，健康快乐。&lt;/p&gt;
&lt;p&gt;最后还是想感谢自己，感谢自己能一直朝着自己热爱的方向努力，感谢自己在实验面临瓶颈时能咬牙坚持不放弃，感谢自己热爱运动、热爱跑步，把自己的身体照顾的好好的，感谢自己能始终以一个开朗乐观的心态面对世界。最后的最后，祝愿我身边的所有人都能面朝大海，春暖花开。&lt;/p&gt;
&lt;p&gt;王宇&lt;br /&gt;
 2024 年 5 月于未来城校区镜湖湖畔&lt;/p&gt;
</content>
        <category term="清风明月" scheme="https://blog.aayu.today/categories/leisure/" />
        <category term="永恒" scheme="https://blog.aayu.today/categories/leisure/forever/" />
        <category term="AR" scheme="https://blog.aayu.today/tags/AR/" />
        <updated>2024-06-15T20:49:40.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/leisure/forever/20240615/</id>
        <title>硕士毕设展示，捣鼓一下未来适合AR眼镜的文本输入方式~</title>
        <link rel="alternate" href="https://blog.aayu.today/leisure/forever/20240615/"/>
        <content type="html">&lt;h2 id=&#34;视频展示&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#视频展示&#34;&gt;#&lt;/a&gt; 视频展示&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;media-container&#34;&gt;&lt;div class=&#34;player&#34; data-type=&#34;video&#34; data-src=&#39;[{&#34;name&#34;:&#34;VirTap：基于可穿戴传感器的文本输入识别方法研究&#34;,&#34;url&#34;:&#34;https://pan.aayu.today/workspace/video/VirTap.mp4&#34;}]&#39;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h2 id=&#34;研究背景&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#研究背景&#34;&gt;#&lt;/a&gt; 研究背景&lt;/h2&gt;
&lt;p&gt;随着增强现实（AR）和虚拟现实（VR）等新兴设备的日益普及，传统的文本输入方式如键盘和鼠标已难以满足用户的需求。现有较成熟的文本输入解决方案一是基于计算机视觉的手势识别，二是依赖手持控制器的文本输入。然而，也存在着诸如设备成本高昂、使用易疲劳、文本输入效率低下等问题。&lt;/p&gt;
&lt;p&gt;基于可穿戴传感器的文本输入技术是一种有前景的研究方向。通过佩戴诸如指环、手环和手套等形态的传感器设备，捕捉用户的手指和手部动作，并将其转换为文本信息。但现有研究提出了不同于 QWERTY 标准键盘的输入规则，从而导致输入方式的不直观、不易学和易疲劳。此外，难以广泛应用于不同的终端设备，需要设计特定的接口和软件支持，也限制了该技术的普遍适用性。针对以上不足，本研究探索了一种新的文本输入识别方法，通过手腕可穿戴传感器，结合 QWERTY 键盘的敲击习惯，实现一种更直观、自然和高效的文本输入体验。&lt;/p&gt;
&lt;h2 id=&#34;硬件资源概况&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#硬件资源概况&#34;&gt;#&lt;/a&gt; 硬件资源概况&lt;/h2&gt;
&lt;p&gt;本研究使用六轴姿态传感器 LSM6DSL 获取手指敲击动作的加速度和角速度数据，采样频率设置为 104Hz，加速度计测量范围设置为 ±4G，陀螺仪测量范围设置为 ±2000dps。连续的姿态传感器数据包括了参与者所有的手部动作。为了获取手指的敲击信号，本研究复刻了嘉立创 EDA 开源硬件平台的 QF ZERO V2 开源项目作为后续实验的硬件基础，如图 1 所示。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;assets/1.png&#34; alt=&#34;图1　可穿戴设备硬件资源&#34; title=&#34;图1　可穿戴设备硬件资源&#34; width=&#34;600px&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;qwerty-键盘的标准指法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#qwerty-键盘的标准指法&#34;&gt;#&lt;/a&gt; QWERTY 键盘的标准指法&lt;/h2&gt;
&lt;p&gt;QWERTY 键盘的标准指法，也被称为触摸打字或盲打，是一种在没有看键盘的情况下打字的技能。这种指法建立在键盘布局和手指位置的记忆上，允许打字者高效且准确地输入文本。示意图如图 2 所示。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;assets/2.png&#34; alt=&#34;图2　QWERTY键盘的标准指法示意图&#34; title=&#34;图2　QWERTY键盘的标准指法示意图&#34; width=&#34;600px&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）基准位置：&lt;/strong&gt; 每只手除拇指外的四个手指被分配给一行特定的键。例如，左手的食指、中指、无名指和小指分别负责 “F”、“D”、“S” 和 “A” 键（以及这些键上方和下方的键）。对于右手，食指、中指、无名指和小指分别负责 “J”、“K”、“L” 和 “；” 键（以及这些键上方和下方的键）。左手拇指和右手拇指通常用于敲击空格键；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）盲打定位：&lt;/strong&gt; 标准的 QWERTY 键盘上，“F” 键和 “J” 键上会有个突起的小横杠，用于盲打时左手食指和右手食指的定位；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）打字动作：每次敲击键时，相应的手指应移动到目标键，然后返回到其基准位置。&lt;/strong&gt; 这种打字方式确保每个手指负责特定的键，从而提高打字效率。&lt;/p&gt;
&lt;p&gt;本研究基于 QWERTY 键盘的标准指法，招募 10 名志愿者采集了 26 个英文字母和空格的手指敲击动作数据，并对其进行标注，最终得到 22107 个标注好的手指敲击动作样本。&lt;/p&gt;
&lt;h2 id=&#34;敲击动作识别模型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#敲击动作识别模型&#34;&gt;#&lt;/a&gt; 敲击动作识别模型&lt;/h2&gt;
&lt;p&gt;本研究通过传感器信号的尖锐变化来判定是否发生敲击事件。基于手指敲击数据集，本研究构建了一个基于卷积神经网络的敲击动作识别模型，如图 3 所示。为了更高效的识别敲击的字符，将手指敲击数据集划分为左手数据集和右手数据集。其中，左手模型输出的样本标签为 15 个英文字母、左手空格和左手负样本标签共 17 个类别；右手模型输出的样本标签为 11 个英文字母、右手空格和右手负样本标签共 13 个类别。整个网络包含约 34k 个可训练参数，在 100 个 epoch 中进行训练，训练的 batch 大小为 16，使用 Adam 优化器，学习率设置为 1e-3，权重衰减设置为 1e-3。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;assets/3.png&#34; alt=&#34;图3　敲击动作识别模型技术路线图&#34; title=&#34;图3　敲击动作识别模型技术路线图&#34; width=&#34;600px&#34; /&gt;&lt;/p&gt;
&lt;p&gt;打字速度通常使用每分钟字数 WPM 进行评估，公式如下所示：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34; display=&#34;block&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;/mfrac&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mn&gt;60&lt;/mn&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;WPM = \frac{|T|-1}{S} \times 60 \times \frac{1}{5}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.113em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.427em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;×&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;×&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.00744em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.32144em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;式中：|T| 是最终得到的字符串的长度，S 是从输入短语的第一个点击到最后一个点击的经过时间（单位为秒），包括用于纠正输入错误的时间（例如删除)。&lt;/p&gt;
&lt;p&gt;本研究通过统计 1 分钟内正确敲击的字符数，除以用来评估的待测试文本总字符数，得到模型实时敲击预测准确率，根据 WPM 公式计算得到打字速度。实验发现，预测准确率和打字速度会随着测试者对 QWERTY 标准指法的熟练程度而上升。经过一段时间的练习以及少量敲击样本的微调后，本研究构建的模型最终可以达到 97.06% 的实时敲击预测准确率，WPM 为 13.6。评估结果如图 4 所示。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;assets/4.png&#34; alt=&#34;图4　准确率和打字速度评估结果&#34; title=&#34;图4　准确率和打字速度评估结果&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;文本输入识别框架&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#文本输入识别框架&#34;&gt;#&lt;/a&gt; 文本输入识别框架&lt;/h2&gt;
&lt;p&gt;本研究提出了文本输入识别框架 VirTap，支持任何带有蓝牙功能的终端设备，为其提供文本输入功能，包括但不限于手机、电脑、平板，以及 VR 头显和 AR 眼镜等混合现实设备。框架结构细分为 Web 端模块、云端模块和 Android 端模块。框架的架构和模块间的依赖关系及数据流向可见于图 5。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;assets/5.png&#34; alt=&#34;图5　文本输入识别框架VirTap架构图&#34; title=&#34;图5　文本输入识别框架VirTap架构图&#34; width=&#34;600px&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;android-端界面展示&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#android-端界面展示&#34;&gt;#&lt;/a&gt; Android 端界面展示&lt;/h3&gt;
&lt;p&gt;Android 端界面实现如图 6 所示。应用主界面如（A）所示，相机预览画面占主体显示。当点击连接手环按钮后，应用跳转到（B）所示界面，设备列表展示了扫描到的 BLE 设备，在列表项上单击可选中该设备，支持同时选中多个设备。当 BLE 设备连接成功后，主界面相机预览画面上叠加展示了当前可穿戴设备的数据流信息，如（C）所示。主界面右上角是一个设置按钮，可以用来配置云端 TCP 服务 IP 地址和端口，以及外部终端设备的蓝牙名称，如（D）所示。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;assets/6.png&#34; alt=&#34;图6　Android端界面：（A）应用主界面，（B）BLE设备选择界面，（C）设备数据预览界面，（D）TCP和蓝牙设置界面&#34; title=&#34;图6　Android端界面：（A）应用主界面，（B）BLE设备选择界面，（C）设备数据预览界面，（D）TCP和蓝牙设置界面&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;web-端界面展示&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web-端界面展示&#34;&gt;#&lt;/a&gt; Web 端界面展示&lt;/h3&gt;
&lt;h4 id=&#34;数据采集界面&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据采集界面&#34;&gt;#&lt;/a&gt; 数据采集界面&lt;/h4&gt;
&lt;p&gt;Web 端数据采集界面如图 7 所示。整体布局划分为三个部分，左右两边展示可穿戴设备实时数据流。中间区域是 QWERTY 标准指法敲击示意图，图片上方是一个进度条和两个按钮。当开始敲击数据采集时，进度条会以 1 秒为周期进行闪动，结合 “叮” 的音效辅助志愿者完成一次敲击。按钮功能分别是连接云端以及开始或结束敲击数据采集。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;assets/7.png&#34; alt=&#34;图7　Web端数据采集界面&#34; title=&#34;图7　Web端数据采集界面&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;数据预览界面&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据预览界面&#34;&gt;#&lt;/a&gt; 数据预览界面&lt;/h4&gt;
&lt;p&gt;Web 端数据预览界面如图 8 所示。整体布局划分为左右两个部分，左边区域上方展示了当前数据所属志愿者、采集时间、采集批次，以及候选敲击数据检测算法的三个超参数。下方是敲击数据的表格展示。整体布局的右边区域就是通过折线图形式展示的敲击数据。通过该界面可以对采集到的敲击数据进行预处理，得到候选敲击数据并高亮显示。通过下载按钮可以对预处理后的数据文件进行保存。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;assets/8.png&#34; alt=&#34;图8　Web端数据预览界面&#34; title=&#34;图8　Web端数据预览界面&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;数据标注界面&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据标注界面&#34;&gt;#&lt;/a&gt; 数据标注界面&lt;/h4&gt;
&lt;p&gt;数据标注界面如图 9 所示。整体布局和数据预览界面非常相似，左上角区域去掉了候选敲击数据检测算法的三个超参数，添加了一个文本输入框用来标记当前样本标签。图表组件隐藏了 FPS 帧率图显示，只对当前正在校验的候选敲击数据进行高亮显示。下载按钮旁边添加了一个播放按钮，用来控制是否开启视频组件的敲击片段循环播放功能。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;assets/9.png&#34; alt=&#34;图9　Web端数据标注界面&#34; title=&#34;图9　Web端数据标注界面&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;模型评估界面&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#模型评估界面&#34;&gt;#&lt;/a&gt; 模型评估界面&lt;/h4&gt;
&lt;p&gt;模型评估界面如图 10 所示。和数据采集界面类似，整体布局划分为了三个部分，左右两边展示可穿戴设备实时敲击数据流。数据流下方是云端反馈的敲击预测 Top5 结果及其置信度分数。中间区域从上往下被划分为 4 个部分。第一部分是两个按钮和一个下拉选择框。当成功连接云端后，可以从下拉列表中选择一个模型进行评估。第二部分和第三部分是两个文本展示区域，用来展示待实时评估的文本和开启评估后的敲击预测结果。中间区域最下方是评估结果展示区域，显示实时敲击准确率和打字速度评估结果。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;assets/10.png&#34; alt=&#34;图10　Web端模型评估界面&#34; title=&#34;图10　Web端模型评估界面&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;框架支持的场景&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#框架支持的场景&#34;&gt;#&lt;/a&gt; 框架支持的场景&lt;/h3&gt;
&lt;h4 id=&#34;在手机-电脑-平板等智能设备中的文本输入&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#在手机-电脑-平板等智能设备中的文本输入&#34;&gt;#&lt;/a&gt; 在手机、电脑、平板等智能设备中的文本输入&lt;/h4&gt;
&lt;p&gt;以 iPhone 15 Pro 手机为例，接入 VirTap 的流程为：（1）打开框架 Android 端应用程序；（2）在 iPhone 手机蓝牙设置界面扫描到 Android 设备后，点击设备进行连接；（3）在 Android 端应用程序设置界面配置云端 IP 地址、端口和 iPhone 设备的蓝牙名称；（4）点击按钮连接云端和终端设备；（5）佩戴手表，激活六轴姿态传感器，连接手表至 Android 端应用程序；（6）当左手或右手连续敲击空格 4 次即可开始为 iPhone 手机提供文本输入功能。图 11 场景照片展示了 VirTap 框架正在为 iPhone 15 Pro 提供文本输入功能。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;assets/11.png&#34; alt=&#34;图11　VirTap框架在手机设备文本输入场景中的应用案例&#34; title=&#34;图11　VirTap框架在手机设备文本输入场景中的应用案例&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;在混合现实场景中的文本输入&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#在混合现实场景中的文本输入&#34;&gt;#&lt;/a&gt; 在混合现实场景中的文本输入&lt;/h4&gt;
&lt;p&gt;图 12 展示了混合现实场景中的文本输入。用到的设备是 XREAL Air2 AR 眼镜。XREAL Air2 眼镜连接带 DP（DisplayPort）视频信号输出功能的设备，如手机、平板、或空间计算终端才可开启 AR 体验。在本场景演示中，通过将 XREAL Air2 AR 眼镜连接至华为平板，华为平板接入 VirTap 框架中，实现在 AR 空间中的文本输入功能。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;assets/12.png&#34; alt=&#34;图12　VirTap框架在混合现实文本输入场景中的应用案例&#34; title=&#34;图12　VirTap框架在混合现实文本输入场景中的应用案例&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;未来展望&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#未来展望&#34;&gt;#&lt;/a&gt; 未来展望&lt;/h2&gt;
&lt;p&gt;后续我肯定还会继续基于这个研究捣鼓下去，想探索一下基于 &lt;strong&gt;Beam Pro&lt;/strong&gt; 以及上面的&lt;strong&gt;搜狗输入法 XREAL 版&lt;/strong&gt;，将双手十指敲击动作映射为类似「 拼音九键 」一样的输入，不再映射成 26 个英文字符，能进一步提高打字准确率和打字效率～&lt;/p&gt;
&lt;h2 id=&#34;硬件资源链接&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#硬件资源链接&#34;&gt;#&lt;/a&gt; 硬件资源链接&lt;/h2&gt;
&lt;p&gt;QF ZERO V2 智能手表终端：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9vc2h3aHViLmNvbS9kaHgyMzMvZXNwMzJfczNfd2F0Y2g=&#34;&gt;https://oshwhub.com/dhx233/esp32_s3_watch&lt;/span&gt;&lt;/p&gt;
</content>
        <category term="清风明月" scheme="https://blog.aayu.today/categories/leisure/" />
        <category term="永恒" scheme="https://blog.aayu.today/categories/leisure/forever/" />
        <category term="AR" scheme="https://blog.aayu.today/tags/AR/" />
        <updated>2024-06-15T14:01:04.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/leisure/forever/20240220/</id>
        <title>2023 XR 设备体验分享~</title>
        <link rel="alternate" href="https://blog.aayu.today/leisure/forever/20240220/"/>
        <content type="html">&lt;p&gt;不知不觉，我也体验过不少的 AR 眼镜了，如 HoloLens1/2 代，XREAL X/Air2，INMO Go、魅族 MYVU、Blucap Moto 和 Rokid Max Pro，这里想分享一下作为一个普通用户我的佩戴体验，仅供参考哈哈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HoloLens1/2 代：1 和 2 代的缺点就是笨重，我个人坚持不到半小时就不想佩戴了，压脑袋。优点就是有 Windows 生态，开发难度适中，并且不需要外置电源。总结，适合 ToB，不适合 ToC。&lt;/li&gt;
&lt;li&gt;XREAL X/Air2：XREAL X 支持 RGB 摄像头和手势追踪，开发难度适中。缺点就是压鼻子，戴不住，并且手势追踪的延迟较高，生态少。Air2 佩戴体验比 XREAL X 好很多，外观也挺酷，缺点就是没有摄像头，只适合观影和游戏，配合 Win 和 MacOS 电脑端软件可以虚拟多屏办公，实际体验不错。XREAL X 佩戴舒适度满分 10 分的话我给 5 分，Air2 能到 8 分。&lt;/li&gt;
&lt;li&gt;INMO Go：总体来说中规中矩，缺点就是单目光波导，有彩虹纹，近视解决方式不友好。佩戴舒适度能到 7 分。&lt;/li&gt;
&lt;li&gt;魅族 MYVU：优点双目光波导好评，缺点是外出佩戴，半个屏幕都是彩虹纹，影响体验，近视解决方式也是夹片不友好。佩戴舒适度也是 7 分。&lt;/li&gt;
&lt;li&gt;Blucap Moto：新起之秀，官网介绍是专为摩托用户设计的 AR 眼镜，支持各类消息和来电显示，支持导航地图显示。我实际佩戴过程中舒适度能打到 8 分，可以让我在骑单车或小电驴遛街时真正解放手机。近视解决方案是直接定制近视波导片，不用在眼镜上额外增加夹片，不刮睫毛好评哈哈。缺点就是单目光波导，也没有麦克风和扬声器，眼镜功能相比 INMO Go 和 MYVU 少。App 只支持 iOS，目前还不支持 Android。&lt;/li&gt;
&lt;li&gt;Rokid Max Pro：外星科技，能在支持摄像头和手势追踪的同时，重量做到如此的轻，以至于我第一次戴上的时候真的是很震惊哈哈，而且手势识别的延迟也很低，超赞。优点还有 Rokid 生态，秒杀其他友商，欣欣向荣。还有开发者文档和论坛技术支持也很赞。缺点就是也需要做一个近视夹片，外观设计稍逊于 XREAL 系列，佩戴舒适度能给到 8 分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，XREAL X/Air2、Rokid Max Pro 是 BB 技术方案，INMO Go、MYVU 和 Blucap Moto 是阵列光波导技术方案，HoloLens1/2 代没记错的话应该是衍射光波导方案。&lt;/p&gt;
&lt;p&gt;BB 的近视解决方案通常就是近视夹片了，我个人是感觉比较麻烦的，而且夹片也会有概率刮到睫毛。&lt;/p&gt;
&lt;p&gt;阵列光波导是我看好的，体积更小，能做到更接近日常佩戴的眼镜形态，而且近视镜片能做到和波导片直接贴合。目前痛点就是彩虹纹，但据说有望在 2024 年有重大改善哈哈。当前，显示效果和分辨率想达到 BB 方案的高度还有很长的路要走。&lt;/p&gt;
&lt;p&gt;有一个有意思的点是，XREAL X 的近视框架是磁吸式的，所以我剪了两小片磁条，粘贴到 Rokid Max Pro 上，就可以很完美的将 XREAL X 的近视镜吸到 Rokid Max Pro 上了，不剧烈晃动就不会掉。哈哈哈，只要思想不滑坡，办法总比困难多～&lt;/p&gt;
&lt;p&gt;希望未来能有机会体验下雷鸟系的 AR 眼镜，以及最期待的 Apple Vision Pro 嘿嘿，冲冲冲～&lt;/p&gt;
&lt;p&gt;小彩蛋，猜一猜下图都是哪些 AR 设备 😉&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/02/20/202402202215306.jpg&#34; alt=&#34;&#34; width=&#34;400px&#34; /&gt;&lt;/p&gt;
</content>
        <category term="清风明月" scheme="https://blog.aayu.today/categories/leisure/" />
        <category term="永恒" scheme="https://blog.aayu.today/categories/leisure/forever/" />
        <category term="AR" scheme="https://blog.aayu.today/tags/AR/" />
        <updated>2024-02-20T14:12:15.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/feature/rokid/20240124/</id>
        <title>Rokid 空间小程序《我们的地球》开源~</title>
        <link rel="alternate" href="https://blog.aayu.today/feature/rokid/20240124/"/>
        <content type="html">&lt;h2 id=&#34;真机演示&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#真机演示&#34;&gt;#&lt;/a&gt; 真机演示&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;media-container&#34;&gt;&lt;div class=&#34;player&#34; data-type=&#34;video&#34; data-src=&#39;[{&#34;name&#34;:&#34;小破球，转起来，呼啦呼啦向前走，吼吼&#34;,&#34;url&#34;:&#34;https://pan.aayu.today/workspace/video/ourEarth.mp4&#34;}]&#39;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h2 id=&#34;开源地址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#开源地址&#34;&gt;#&lt;/a&gt; 开源地址&lt;/h2&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL3lsc2lzbG92ZS9qc2FyLW91ci1lYXJ0aA==&#34;&gt;https://github.com/ylsislove/jsar-our-earth&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;作品介绍&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#作品介绍&#34;&gt;#&lt;/a&gt; 作品介绍&lt;/h2&gt;
&lt;p&gt;地球在宇宙中的运动是一个壮丽的舞蹈，而赤道面与黄道面则是这个舞蹈中的关键角色。赤道面，是地球自转的平面，将地球分为南北两个半球。而黄道面，则是地球绕太阳公转的平面。当这两个平面相遇时，它们之间形成了一个微妙的夹角。这个夹角，被称为黄赤交角。它的存在，使得太阳在地球上的直射点在一年内在赤道两侧来回移动，从而导致了四季的变化。&lt;/p&gt;
&lt;p&gt;在空间小程序中，来直观感受下地球运动的魅力吧～&lt;/p&gt;
&lt;h2 id=&#34;后期规划&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#后期规划&#34;&gt;#&lt;/a&gt; 后期规划&lt;/h2&gt;
&lt;p&gt;想借助 Web 开发的优势，将 AI 功能融入进空间小程序中。空间小程序的定位是桌面组件，所以将地球当作地球仪摆放在桌子上岂不是很合理哈哈&lt;/p&gt;
&lt;p&gt;既然作为一个桌面组件，我希望能有一种除了手势交互以外的，更自然的交互方式，那就是语音交互啦。&lt;/p&gt;
&lt;p&gt;想象在工作闲暇之余，我可以对着地球说，最近世界各地有哪些好玩有趣的事发生呀，小破球就会通过 AI 自动帮我搜集信息，并进行总结，然后再借助文本转语音在线 api 生成音频，自动播放。这就是在 v1.3.0 版本想实现的功能哈哈&lt;/p&gt;
&lt;p&gt;更进一步说，借助 AI 除了收集文字资料，还可以收集图片和视频资料呀，这样我在了解世界各地发生的好玩的事情时，相关的图片也可以展示在我眼前，体验肯定会更好。或许可以在 v1.4.0 版本实现这个功能～&lt;/p&gt;
&lt;p&gt;欢迎有感兴趣的小伙伴一起开发，也顺便可以治治我的拖延症嘿嘿😉&lt;/p&gt;
</content>
        <category term="Rokid" scheme="https://blog.aayu.today/categories/Rokid/" />
        <category term="Rokid" scheme="https://blog.aayu.today/tags/Rokid/" />
        <category term="空间小程序" scheme="https://blog.aayu.today/tags/%E7%A9%BA%E9%97%B4%E5%B0%8F%E7%A8%8B%E5%BA%8F/" />
        <updated>2024-01-23T17:46:51.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/feature/unity/20240101/</id>
        <title>Unity3D特效学习笔记（1）魔法球</title>
        <link rel="alternate" href="https://blog.aayu.today/feature/unity/20240101/"/>
        <content type="html">&lt;h2 id=&#34;效果展示&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#效果展示&#34;&gt;#&lt;/a&gt; 效果展示&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/07/202401072310971.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建项目&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建项目&#34;&gt;#&lt;/a&gt; 创建项目&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012208061.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装包&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#安装包&#34;&gt;#&lt;/a&gt; 安装包&lt;/h2&gt;
&lt;p&gt;确保 Visual Effect Graph 和 Shader Graph 已经安装，如果没有安装，可以在 Unity 的 Package Manager 中安装。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012211254.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建-visual-effect-graph&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建-visual-effect-graph&#34;&gt;#&lt;/a&gt; 创建 Visual Effect Graph&lt;/h2&gt;
&lt;p&gt;在 Project 视图中，右键点击鼠标，选择 Create -&amp;gt; Visual Effects -&amp;gt; Visual Effect Graph，创建一个 Visual Effect Graph。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012228110.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;把 Visual Effect Graph 拖拽到 Hierarchy 场景中&lt;/p&gt;
&lt;h2 id=&#34;创建-trail-粒子特效&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建-trail-粒子特效&#34;&gt;#&lt;/a&gt; 创建 Trail 粒子特效&lt;/h2&gt;
&lt;p&gt;在画布中按空格，可以创建一个节点，输入 Trail，选择创建&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012229141.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;添加三个变量，分别用来控制路径生成速率，颜色和范围大小&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012242140.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;再添加一个变量，用来控制路径的随机生命周期&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012248250.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在更新粒子节点中，添加 conform to sphere，用来控制粒子的位置&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012309557.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在 GPU 事件中，更改粒子初始化生命周期为继承父级&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012310209.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在输出节点中，先取消激活粒子大小随生命变化，添加一个我们可以控制大小的节点，并设置随机范围为 0.001 到 0.02&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012316317.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;再次激活粒子大小随生命变化，在选中节点时，修改 Inspector 中的组合模式为 Add，使得场景中既可以有我们设置的随机大小，又可以有粒子大小随生命变化的效果&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012320514.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;框选全部，右键，Group Selection，把所有节点组合起来，命名为 Trail，我们的第一个特效就弄好了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012322986.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建-beam-粒子特效&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建-beam-粒子特效&#34;&gt;#&lt;/a&gt; 创建 Beam 粒子特效&lt;/h2&gt;
&lt;p&gt;在旁边我们开始创建第一个特效，按空格，输入 empty，选择创建一个空粒子系统&lt;/p&gt;
&lt;p&gt;系统节点里选择创建一个周期性爆炸粒子，并设置属性如下图&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012330490.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;设置大小和颜色，为了避免周期性爆炸粒子在周期切换的时候闪烁，我们需要添加一个 add color over life，设置颜色随生命变化，透明度设置从 0 到 100 再到 0，这样就可以避免闪烁了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012336171.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;上面的 Blender Mode 设置为 Additive，效果会比 Alpha 模式好一点，可以自己根据情况改变&lt;/p&gt;
&lt;p&gt;将我们设置好的第二种特效框选起来，命名为 Beam&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012343896.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建-shell-粒子特效&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建-shell-粒子特效&#34;&gt;#&lt;/a&gt; 创建 Shell 粒子特效&lt;/h2&gt;
&lt;p&gt;在画布旁边按空格，输入 simply，选择创建一个简单粒子特效&lt;/p&gt;
&lt;p&gt;将纹理贴图设置为默认粒子，混合模式改为 Additive&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012347467.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;创建一个变量用来控制粒子生成速率，并设置粒子的生成位置和速率属性，如下图&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/01/202401012352110.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在粒子输出节点，控制粒子的大小和颜色&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/02/202401020003836.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在粒子更新节点，为了让粒子的运动更加炫酷，就需要给粒子的位置叠加一个噪声，节点如下图&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/02/202401020015044.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;将我们设置好的第三种特效框选起来，命名为 Shell&lt;/p&gt;
&lt;p&gt;可以随意更改颜色，大小，速率等变量，至此，就可以得到一个很炫酷的魔法球特效了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2024/01/02/202401020029423.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</content>
        <category term="Unity3D" scheme="https://blog.aayu.today/categories/unity/" />
        <category term="Unity3D" scheme="https://blog.aayu.today/tags/Unity3D/" />
        <updated>2024-01-01T14:00:52.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/feature/rokid/20231125/</id>
        <title>Rokid 新项目构建过程中，可能遇到的问题及解决方案</title>
        <link rel="alternate" href="https://blog.aayu.today/feature/rokid/20231125/"/>
        <content type="html">&lt;p&gt;按照开发者文档构建新项目时，可能会碰到如下报错&lt;/p&gt;
&lt;p&gt;从报错信息中可以看到一条关键信息  &lt;code&gt;Could not resolve com.rokid.uxrplugin:rkuxrplugin:2.3.10&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/11/25/202311251932196.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在自己浏览器输入下面的网址，发现也能正常打开链接，那自己的网络应该就是没问题的，那为什么会报错呢&lt;/p&gt;
&lt;p&gt;原因可能有两个，一个是自己的 Maven 文件没有配置正确，另一个可能就是自己电脑上全局的 gradle.properties 配置文件曾经配置过代理，从而导致 Rokid Maven 仓库访问异常～&lt;/p&gt;
&lt;p&gt;关于第一个原因，正确的 Maven 如何配置，可以看&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdXN0b20ucm9raWQuY29tL3Byb2Qvcm9raWRfd2ViL2M4OGJlNGJjZGU0YzQyYzBiOGI1MzQwOWUxZmExNzAxL3BjL2NuLzExZjg2Nzk4ZGM2YzQ3NTE4ZTMzMGRmNDliMWI1ZTY1Lmh0bWw/ZG9jdW1lbnRJZD1jZGVmNGIyYmVhODU0MmRlYWRiZTk5YWNhNDkyMWI1NyMzLSVFNSU4RiU5MSVFNSVCOCU4MyVFOSU4NSU4RCVFNyVCRCVBRQ==&#34;&gt;官方文档 2.3.10 版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/11/25/202311251932770.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里就有针对不同  Unity 版本的配置文件，直接下载下来，导入到自己的 Unity 项目即可～&lt;/p&gt;
&lt;p&gt;至于第二个原因，就是我误打误撞找到了解决办法哈哈，原先我曾经用 Android Studio 开发过 Android 项目，之前开发时为了解决网络环境，就配置了代理，代理设置就被配置在了全局的 gradle.properties 文件中&lt;/p&gt;
&lt;p&gt;对于 Windows，这个文件在  &lt;code&gt;C:\Users\用户名\.gradle&lt;/code&gt;  目录下，对于 Mac 用户的话，这个文件应该在  &lt;code&gt;~/.gradle/gradle.properties&lt;/code&gt;  这里&lt;/p&gt;
&lt;p&gt;配置过代理后的 gradle.properties 应该会有这四行配置&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/11/25/202311251933514.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;而恰巧不巧的是，这里代理用的 socks 版本和我电脑上 v2rayN 代理软件 的 socks 版本不匹配，所以在 unity 或 android studio 里构建安卓项目是就会构建不成功&lt;/p&gt;
&lt;p&gt;解决办法也很简单，就把第 15、16 行 https 配置注释掉就好，只用 http 代理&lt;/p&gt;
&lt;p&gt;修改完后，再次在 unity 里构建项目，构建成功，问题完美解决～&lt;/p&gt;
&lt;h2 id=&#34;参考链接&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#参考链接&#34;&gt;#&lt;/a&gt; 参考链接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6bTE0NzU1OTg4OTEvYXJ0aWNsZS9kZXRhaWxzLzg4NTMwMDAy&#34;&gt;解决 Android Studio 之 Cause: dl.google.com:443 failed to respond&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC84NTI5ZGM4MmY4MTI=&#34;&gt;解决：Android Studio 之 Cause: dl.google.com:443 failed to respond&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="Unity3D" scheme="https://blog.aayu.today/categories/unity/" />
        <category term="Rokid" scheme="https://blog.aayu.today/categories/unity/Rokid/" />
        <category term="Unity3D" scheme="https://blog.aayu.today/tags/Unity3D/" />
        <category term="Rokid" scheme="https://blog.aayu.today/tags/Rokid/" />
        <updated>2023-11-25T11:31:42.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/leisure/forever/20231123/</id>
        <title>AR 应用创意分享：The Seed</title>
        <link rel="alternate" href="https://blog.aayu.today/leisure/forever/20231123/"/>
        <content type="html">&lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;此帖正在参与 Rokid 活动，如果觉得不错的话，欢迎点赞支持～&lt;br /&gt;
 帖子链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mb3J1bS5yb2tpZC5jb20vcG9zdC9kZXRhaWwvOTE2&#34;&gt;https://forum.rokid.com/post/detail/916&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以转载，但请注明出处，谢谢～&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;前两天分享过两个 idea 了，分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Assistant（&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mb3J1bS5yb2tpZC5jb20vcG9zdC9kZXRhaWwvODQzJUVGJUJDJTg5&#34;&gt;https://forum.rokid.com/post/detail/843）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;魔刀千刃（&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mb3J1bS5yb2tpZC5jb20vcG9zdC9kZXRhaWwvODg4JUVGJUJDJTg5&#34;&gt;https://forum.rokid.com/post/detail/888）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天发现有小坏蛋原封不动的 copy 了我的魔刀千刃 idea，如果喜欢我的创意，欢迎转载，但请不要直接 copy&lt;/p&gt;
&lt;p&gt;更何况 copy 都没把图片 copy 过去，有小伙伴看到的话不就看的莫名其妙嘛，这就更不能忍了 (* ￣︿￣)&lt;/p&gt;
&lt;p&gt;目前该帖子已经有 60 的浏览量了，希望 rokid 小助手最后评选时可以将该浏览量合并到原创帖子头上&lt;/p&gt;
&lt;p&gt;尊重原创，保护每一个来之不易的 idea ~&lt;/p&gt;
&lt;p&gt;~~&lt;/p&gt;
&lt;p&gt;吐槽结束，这次的想法实际上也在我脑子里琢磨了很久了，实际上，在我 7、8 年前第一次看《刀剑神域》小说的时候，我就一直梦想着 AR 世界的未来～&lt;/p&gt;
&lt;p&gt;应用名称：The Seed&lt;br /&gt;
 目标人群：喜欢《刀剑神域》的开发者～&lt;br /&gt;
 应用场景：&lt;/p&gt;
&lt;p&gt;如果有小伙伴也看过《刀剑神域》，不知道是不是也和我一样，被里面可以完全潜行的 VRMMO（虚拟现实大型多人在线）游戏所吸引呢&lt;/p&gt;
&lt;p&gt;只要戴上头盔，我们的大脑就可以畅游在计算机生成的虚拟世界里，直接用意识操控自己角色奔跑，跳跃，使用帅气的剑技，打怪升级等等，每次想到这个场景我都会很激动哈哈&lt;/p&gt;
&lt;p&gt;当然了，以目前的科技水平来说，想要实现小说里的场景，还有很长很长的路要走，人脑方面的研究也还有很多工作要做，希望此生可以活得长久一点，在有生之年可以见证这个场景的到来 😉&lt;/p&gt;
&lt;p&gt;The Seed 是小说里 VRMMO 系列游戏的种子，基于该种子所制作的一系列 VRMMO 游戏都有可能相互连接，用同一名角色就能在无数的 VRMMO 间漫游，以下内容取自百度百科&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Seed 是能制作、管理小型 VRMMO 的免费软件。茅场晶彦托付给桐人的 “世界的种子”。从运作 VRMMO 必需的 Cardinal 到游戏的制作工具都包在里面，只要准备好 3D 物件和服务器就能建立出 VRMMO 环境。用 The Seed 开发出的 VRMMO 间，是能相连的，因为其潜藏着 “不同游戏间的角色可以相互转换”（能转换的只有角色本身，金钱、道具等都会被清空）的最高法则，因此，用同一名角色就能在无数的 VRMMO 间漫游。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然人脑的研究还有很长的一段路要走，但刀剑神域里炫酷的游戏操作界面，我还是很希望能实现的呢，比如下图&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;assets/test-20231123204518-nywwbu1.gif&#34; alt=&#34;test&#34; /&gt;&lt;/p&gt;
&lt;p&gt;真的很炫酷啊！！！手势往下一滑，菜单就直接出现在眼前，动作是多么的顺其自然&lt;/p&gt;
&lt;p&gt;所以，后面等有时间了，我应该会好好捣鼓一下 Rokid 的手势识别功能。从我想实现的 The Seed 的这个应用名称来看，我所希望的，就是能设计出一套自己心目中理想的 AR 应用架构，在这个架构里，我会提供类似刀剑神域一样的手势识别功能和界面～&lt;/p&gt;
&lt;p&gt;The Seed 就像一个种子，希望有和我一样是刀剑迷的开发者都能基于 The Seed 开发出自己心目中的 AR 应用或游戏～&lt;/p&gt;
&lt;p&gt;此生无悔入刀剑，来世愿入 SAO！&lt;/p&gt;
</content>
        <category term="清风明月" scheme="https://blog.aayu.today/categories/leisure/" />
        <category term="永恒" scheme="https://blog.aayu.today/categories/leisure/forever/" />
        <category term="AR" scheme="https://blog.aayu.today/tags/AR/" />
        <updated>2023-11-23T13:33:01.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/leisure/forever/20231122/</id>
        <title>AR 应用创意分享：魔刀千刃！</title>
        <link rel="alternate" href="https://blog.aayu.today/leisure/forever/20231122/"/>
        <content type="html">&lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;此帖正在参与 Rokid 活动，如果觉得不错的话，欢迎点赞支持～&lt;br /&gt;
 帖子链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mb3J1bS5yb2tpZC5jb20vcG9zdC9kZXRhaWwvODg4&#34;&gt;https://forum.rokid.com/post/detail/888&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以转载，但请注明出处，谢谢～&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;嘿嘿，昨天写了一个 idea（&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mb3J1bS5yb2tpZC5jb20vcG9zdC9kZXRhaWwvODQz&#34;&gt;The Assistant&lt;/span&gt;），是关于我畅想的未来 AR 眼镜在办公方面的应用～&lt;/p&gt;
&lt;p&gt;今天就再分享一个小 idea 吧，其实在我的脑海里也徘徊很久了哈哈，正好趁 Rokid 活动的机会分享出来～&lt;/p&gt;
&lt;p&gt;应用名称：魔刀千刃&lt;br /&gt;
目标人群：游戏用户，动漫迷&lt;br /&gt;
应用场景：&lt;/p&gt;
&lt;p&gt;从名称上就可以看出，这个 idea 来源于国漫刺客伍六七。之前看动漫的时候，我就被主角使用的武器所吸引，世人对魔刀千刃的评价是 “只攻不防，天下无双”，帅的一批&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/11/22/202311222053957.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;那时候我就在想，像魔刀千刃这种帅气的武器只可能在游戏或动漫里出现了，真的没办法在现实生活中拥有吗？&lt;/p&gt;
&lt;p&gt;魔刀千刃的刀刃是由上千块碎片组成，可以变换成不同的形状，用不同的方式攻击敌人。而想要实现这样的效果的话，实际上在 Unity3D 里可以通过对模型做各种变换来实现，那么，万事俱备，只欠一副可以将模型在现实世界可视化出来的东西了，那就是 Rokid AR 眼镜了～&lt;/p&gt;
&lt;p&gt;有小伙伴可能会问，现在市面上 AR 眼镜也不少呀，为什么选择 Rokid 的呢&lt;/p&gt;
&lt;p&gt;实际上，如果想要实现我想要的效果的话，AR 眼镜上的手势识别功能就必不可少了，因为我需要跟踪手部来渲染魔刀千刃的挥舞动作，所以就要筛选出能进行手势识别的 AR 眼镜，比如微软的 HoloLens2，XREAL Light 和 Rokid Max Pro 等，刚列的这三个设备我都体验过～HoloLens2 的功能很强大，但可惜设备太重了，佩戴舒适度很差，戴十几分钟就不想戴了；XREAL Light 的外观要酷一点，但可惜手势追踪的延迟很高，并且眼镜的重量也有 100 多克，压鼻子的感觉很明显，也无法长时间佩戴～&lt;/p&gt;
&lt;p&gt;Rokid Max Pro 实际体验的时候，说实话，真的让我有点惊讶了。首先，戴上的第一感觉就是压鼻子的感觉很轻，也不滑，佩戴舒适度的感觉很好！这也是我最看重的点。在我看来，一副 AR 眼镜，佩戴舒适度是最重要的，其次才是功能啊，价格啊什么的。功能再强，但佩戴不舒服的设备，注定是要吃灰的～&lt;/p&gt;
&lt;p&gt;啊哈有点跑题了，哈哈回到正题，所以当我体验到 Rokid AR 眼镜的时候，我觉得或许我脑海里徘徊已久的这个 idea 有机会可以实现了，嘿嘿&lt;/p&gt;
</content>
        <category term="清风明月" scheme="https://blog.aayu.today/categories/leisure/" />
        <category term="永恒" scheme="https://blog.aayu.today/categories/leisure/forever/" />
        <category term="AR" scheme="https://blog.aayu.today/tags/AR/" />
        <updated>2023-11-22T13:24:36.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/leisure/forever/20231121/</id>
        <title>AR 应用创意分享：The Assistant</title>
        <link rel="alternate" href="https://blog.aayu.today/leisure/forever/20231121/"/>
        <content type="html">&lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;此帖正在参与 Rokid 活动，如果觉得不错的话，欢迎点赞支持～&lt;br /&gt;
 帖子链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mb3J1bS5yb2tpZC5jb20vcG9zdC9kZXRhaWwvODQz&#34;&gt;https://forum.rokid.com/post/detail/843&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以转载，但请注明出处，谢谢～&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;应用名称：The Assistant&lt;br /&gt;
 目标人群：办公人群&lt;br /&gt;
应用场景：&lt;/p&gt;
&lt;p&gt;功能一：多屏协同办公小助手&lt;br /&gt;
当我外出时，比如在高铁上或飞机上，不需要再携带笔记本电脑或 ipad，只需要带一个 Rokid AR 眼镜，搭配用户自己的手机，或 Rokid Station，就可以随时随地拥有多个虚拟屏幕进行办公～&lt;/p&gt;
&lt;p&gt;有小伙伴可能会问，虽然不用带笔记本电脑啦，但要办公还是需要鼠标和键盘呀，所以实际上还是不方便嘛。哈哈这个问题我也想过了，一个不错的消息是目前学术界也有一些针对 AR 文本输入的研究。举个栗子，去年苏黎世联邦理工学院 SIPLAB 实验室提出了一个 TapType 技术，用户可以通过佩戴手环实现虚拟文本输入，示意图如下～感兴趣的小伙伴也可以看论文细节：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zaXBsYWIub3JnL3Jlc2VhcmNoI3RhcHR5cGU=&#34;&gt;https://siplab.org/research#taptype&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/11/21/202311212302143.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;因此，笨重繁琐的键盘我相信在未来会被更先进的文本输入技术取代，AR 眼镜都能取代显示屏了，那新技术取代键盘不也是理所当然的事情嘛哈哈&lt;/p&gt;
&lt;p&gt;更进一步的话，手势识别，眼动追踪等技术的成熟，我相信也会渐渐取代鼠标的应用～&lt;/p&gt;
&lt;p&gt;对了，据说华为 Mate60 系列手机接上 AR 眼镜后，会直接激活电脑模式，有 mate60 系列手机的小伙伴也可以试一下，哈哈&lt;/p&gt;
&lt;p&gt;功能二：实时分析小助手&lt;/p&gt;
&lt;p&gt;AR 眼镜就是自己的另一双眼睛！当走在大街上的时候，通过摄像头捕获实时音视频流，传输到后端对视频流进行实时分析，实现七龙珠里的战五渣战斗力检测仪不是指日可待吗嘿嘿～&lt;/p&gt;
&lt;p&gt;功能三：专家助手&lt;/p&gt;
&lt;p&gt;如果有体验过微软 HoloLens2 设备的话，应该会知道 HoloLens2 会提供一个远程专家协助应用，可以和另一个人进行实时音视频通话，对方可以看到自己 AR 眼镜前的场景，并通过手势等标注工具对场景进行标注，实现远程指导等&lt;/p&gt;
&lt;p&gt;这个就是很实用的应用，我自己就曾经通过 WebRTC 技术实现了将 HoloLens2 的实时音视频流传输到了 Web 端进行展示，旁观者可以通过看 Web 界面看到我眼镜端的画面，实现了旁观者视角～&lt;/p&gt;
&lt;p&gt;所以我觉得未来嘛，想要让专家对自己正在操作的东西进行指导的话，双方直接戴上 AR 眼镜，好，自己操作的东西直接展示在专家眼前了，专家可以直接通过语音，手势等方式，对场景进行标注，标注可以直接实时反映在我面前，再复杂的操作也都能 so easy 啦～&lt;/p&gt;
</content>
        <category term="清风明月" scheme="https://blog.aayu.today/categories/leisure/" />
        <category term="永恒" scheme="https://blog.aayu.today/categories/leisure/forever/" />
        <category term="AR" scheme="https://blog.aayu.today/tags/AR/" />
        <updated>2023-11-21T13:24:36.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/skill/miscellaneous/20231022/</id>
        <title>USB接口介绍</title>
        <link rel="alternate" href="https://blog.aayu.today/skill/miscellaneous/20231022/"/>
        <content type="html">&lt;h1 id=&#34;usb接口介绍&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#usb接口介绍&#34;&gt;#&lt;/a&gt; USB 接口介绍&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;参考视频：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW5qNDExdjdMdS8=&#34;&gt;四层板 PCB 设计保姆级教程（1）：3.0HUB 设计概述&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;usb-接口定义&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#usb-接口定义&#34;&gt;#&lt;/a&gt; USB 接口定义&lt;/h2&gt;
&lt;p&gt;USB 是通用串行总线的英文缩写，也是一种输入输出接口的技术规范，被广泛的应用于个人电脑和移动设备等通信产品。&lt;/p&gt;
&lt;p&gt;USB 接口自 1994 年推出以来，经过不断的发展，从最初的 USB1.0/1.1，USB2.0，USB3.x，最终发展到如今的 USB4，传输速率也从最开始的 1.5Mbps 提升到了最新的 40Gbps。&lt;/p&gt;
&lt;p&gt;需要注意的是，USB 不是某一个接口，每一代 USB 协议都会衍生出一系列支持该通讯速率的接口设备。&lt;/p&gt;
&lt;p&gt;下面是一些常见的 USB 接口设备。&lt;/p&gt;
&lt;p&gt;​&lt;img data-src=&#34;assets/image-20231020220413-onu3xwd.png&#34; alt=&#34;image&#34; /&gt;​&lt;/p&gt;
&lt;h2 id=&#34;usb-版本区分&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#usb-版本区分&#34;&gt;#&lt;/a&gt; USB 版本区分&lt;/h2&gt;
&lt;p&gt;目前使用最广泛的是 USB2.0 以及 USB3.x&lt;/p&gt;
&lt;p&gt;习惯将 USB3.1Gen1 叫做 USB3.0&lt;/p&gt;
&lt;p&gt;将 USB3.1Gen2 叫做 USB3.1&lt;/p&gt;
&lt;p&gt;将 USBGen2*2 叫做 USB3.2&lt;/p&gt;
&lt;p&gt;​&lt;img data-src=&#34;assets/image-20231020220759-nsljzuq.png&#34; alt=&#34;image&#34; /&gt;​&lt;/p&gt;
&lt;h2 id=&#34;usb-接口选型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#usb-接口选型&#34;&gt;#&lt;/a&gt; USB 接口选型&lt;/h2&gt;
&lt;p&gt;​&lt;img data-src=&#34;assets/image-20231020221041-ce0pt9x.png&#34; alt=&#34;image&#34; /&gt;​&lt;/p&gt;
&lt;p&gt;​&lt;img data-src=&#34;assets/image-20231020221136-nzitdyf.png&#34; alt=&#34;image&#34; /&gt;​&lt;/p&gt;
</content>
        <category term="不看会后悔的实用技巧分享" scheme="https://blog.aayu.today/categories/skill/" />
        <category term="杂七杂八" scheme="https://blog.aayu.today/categories/skill/miscellaneous/" />
        <category term="USB" scheme="https://blog.aayu.today/tags/USB/" />
        <updated>2023-10-22T15:30:38.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/feature/unity/20231021/</id>
        <title>Unity3D优化笔记（10）其他优化</title>
        <link rel="alternate" href="https://blog.aayu.today/feature/unity/20231021/"/>
        <content type="html">&lt;h2 id=&#34;代码优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#代码优化&#34;&gt;#&lt;/a&gt; 代码优化&lt;/h2&gt;
&lt;p&gt;== 使用 AssetBundle 作为资源加载方案。== 而且经常一起使用的资源可以打在同一个 AssetBundle 包中。尽量避免同一个资源被打包进多个 AB 包中。&lt;/p&gt;
&lt;p&gt;压缩方式尽量使用 LZ4，少用或不要用 LZMA 的压缩方式。如果确定后续开发不会升级 Unity 版本，则可以尝试启用打包选项 BuildAssetBundleOption.DisableWriteType，这样 TypeTree 信息不会被打到 AB 包中，可以极大减小包体大小以及运行加载时的内存开销。&lt;/p&gt;
&lt;p&gt;使用 AssetBundle 或者 Addressables 加载的资源，如果不使用，要记得卸载它们，否则会造成内存泄漏。&lt;/p&gt;
&lt;p&gt;不用的资源要释放掉，不用的引用类型的变量也要赋值为 null，不要让它们一直占着内存中。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;加载资源时尽量使用异步加载。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;频繁创建和销毁对象，可以使用对象池。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;切换场景时，旧的场景要释放掉，不用的资源也可以考虑释放掉&lt;/mark&gt;，也可以考虑用 System.GC.Collect 来进行一次垃圾回收。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;锁定游戏的帧率&lt;/mark&gt;。帧率为 30，游戏会明显卡顿，但是对于手游来说，消耗手机的电量比较少。帧率为 45，游戏有一点点卡，但还凑合，消耗电量中等。帧率为 60，游戏很流畅，但消耗手机的电量会比较多。可以用 Application.targetFrameRate 来锁定帧率，也可以用 UnityEngine.Rendering 命名空间中的 OnDemandRendering.renderFrameInterval 来锁定帧率。&lt;/p&gt;
&lt;p&gt;尽量少用 foreach 语句，可以改为 for 语句。因为每次使用 foreach 语句会造成微量的内存垃圾。&lt;/p&gt;
&lt;p&gt;要判断 GameObject 型对象.tag 是不是某个标签，使用 GameObject 型对象.CompareTag 方法会更高效。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;尽量少用 GameObject.Find 方法和 Object.FindObjectOfType 方法来查找游戏对象，可以提前把要查找的游戏对象存储在变量、列表、字典等容器中，方便查找。也可以用 GameObject.FindGameObjectWithTag 方法来查找游戏对象。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;在 UI 显示字符串的时候，如果一些内容是固定的，我们可以把它拆分开来，这样可以减少使用 + 号来拼接的次数，减少内存垃圾的产生&lt;/mark&gt;。例如 “杀敌数：999”，其中 “杀敌数：” 是固定的，冒号后面的数字才是会变的，那么我们可以用两个 Text 组件分别记录它们，改变的时候只改变冒号后面的数字。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;频繁对字符串赋新的值，或者频繁拼接字符串的时候，可以使用 StringBuilder 代替 string&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;如果要频繁操作某脚本，不要每次都用 GetComponent 方法来获取这些脚本。可以用一个变量存储起获得的这个脚本，之后要访问它，就直接访问这个变量即可。也可以考虑在生命周期方法 Awake 或者 Start 中声明变量来存储，之后访问这个变量即可。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;尽量少用正则表达式。虽然正则表达式的形式看上去比较简便，但是使用它会造成一定的性能消耗，且会产生内存垃圾。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;尽量少用 LINQ 语法，因为每次使用 LINQ 都会产生一定量的内存垃圾。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;尽量少用 Camera.main 来访问主摄像机&lt;/mark&gt;，因为每次访问它，实际上 Unity 都是从场景中查找它的。可以声明一个变量存储它，在生命周期方法 Awake 或 Start 中获取主摄像机的应用。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;在 Animator、Shader 中使用 Get 方法和 Set 方法时，不传入字符串作为参数，而是传入哈希值&lt;/mark&gt;。例如 Animator 组件可以使用 Animator.StringToHash 方法获得指定字符串的哈希值，再把它作为参数传入 Animator 组件的 Get 方法或 Set 方法中进行使用。例如 Shader，则可以用 Shader.PropertyToID 方法来获取指定属性的 ID&lt;/p&gt;
&lt;p&gt;使用非分配物理 API。例如使用 Physics.RaycastNonAlloc 方法代替 Physics.RaycastAll 方法，使用 Physics.SphereCastNonAlloc 方法代替 Physics.SphereCastAll 方法，以此类推。Physics2D 类也有类似的方法。&lt;/p&gt;
&lt;p&gt;一般情况下，整数的数学运算比浮点数的数学运算效率高，浮点数的数学运算比矢量的数学运算效率高。可以灵活运用数学的加法交换律、加法结合律、乘法交换律、乘法结合律，在保证结果不变的前提下，调整运算顺序，减少浮点数的数学运算和矢量的数学运算。&lt;/p&gt;
&lt;p&gt;使用高效的算法进行计算&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;每次执行 Debug.Log 来打印信息会消耗极少量的性能，如果要在游戏正式发布之后不执行某些 Debug.Log 的语句，但又不想把这些代码删掉，则可以使用宏来禁止在游戏正式发布之后执行 Deubg.Log 的语句&lt;/mark&gt;。例如使用 #if 语句或者 Conditional 特性。&lt;/p&gt;
&lt;p&gt;尽量减少在生命周期方法 Update、FixedUpdate、LateUpdate 中的逻辑。其中有些不需要频繁执行的逻辑，可以使用协程或者 Invoke 方法，每隔指定的秒数执行一次或每隔指定的帧数执行一次。&lt;/p&gt;
&lt;p&gt;尽量避免频繁的装箱拆箱操作。也可以使用泛型，这样就能避免装箱拆箱。但是要注意，Lua 热更新对泛型的支持不太好。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;如果物体身上添加了刚体组件，则尽量用刚体组件的方法来移动它，而不是用 Transform 类的方法来移动它。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;如果物体身上添加了 CharacterController 组件，则尽量用 CharacterController 组件的方法来移动它，而不是用 Transform 类的方法来移动它。同理，如果物体身上添加了刚体组件，则应尽量用刚体组件的方法来移动它，而不是用 Transform 类的方法来移动它。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;应尽量避免 DontDestroyOnLoad 中加载的资源过多&lt;/mark&gt;，因为它在切换场景的时候不会被释放，声明的变量以及加载的资源会一直占用着内存。我们可以考虑把一些资源不用的资源释放掉，需要的时候再加载它。&lt;/p&gt;
&lt;p&gt;不使用组件可以删掉，这样可以节省一些内存。常见的有 AudioSource 组件、Animator 组件、Animation 组件等，如果它们不需要使用，则可以删掉。&lt;/p&gt;
&lt;p&gt;写一个类继承 AssetPostProcessor，然后定义里面特定的方法，以此来自动设置资源导入 Unity 之后的属性。&lt;/p&gt;
&lt;p&gt;尽量避免闭包。因为闭包会产生额外的内存开销。&lt;/p&gt;
&lt;h2 id=&#34;场景优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#场景优化&#34;&gt;#&lt;/a&gt; 场景优化&lt;/h2&gt;
&lt;p&gt;对始终静止不动的游戏对象使用静态合批技术。&lt;/p&gt;
&lt;p&gt;尽量使用同一个材质，以便使用动态合批技术。&lt;/p&gt;
&lt;p&gt;使用 GPU Instancing 技术。&lt;/p&gt;
&lt;p&gt;使用遮挡剔除。&lt;/p&gt;
&lt;p&gt;进入游戏后的第一个场景要尽量简单，这样可以减少游戏的启动时间。可以先进一个简单的场景，再进行异步加载，之后再进入游戏的主要的场景。&lt;/p&gt;
&lt;p&gt;尽量避免 Hierarchy 窗口的层级结构过深。例如一个物体有很多个子物体，这些子物体又有其它子物体，这些子物体又有其它子物体，继续这样下去就会导致层级结构过深，我们应尽量减少这种情况。&lt;/p&gt;
&lt;p&gt;Edit——Project Settings——Quality，可以对不同平台中游戏的品质进行设置。&lt;/p&gt;
&lt;p&gt;如果使用了后期处理技术，例如 Post Processing 等插件，调整屏幕效果的属性，不要使用太绚丽的特效，可以优化性能。&lt;/p&gt;
&lt;p&gt;要优化 Terrain 地形，可以使用 Unity 资源商店的插件，例如 Terrain To Mesh 插件可以把地形烘焙成网格。&lt;/p&gt;
&lt;p&gt;场景要尽可能简单，尽量多使用预制体，用代码动态创建它们出来，并管理它们。&lt;/p&gt;
&lt;h2 id=&#34;shader-优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#shader-优化&#34;&gt;#&lt;/a&gt; Shader 优化&lt;/h2&gt;
&lt;p&gt;修改 Shader 的代码，或者自定义一个 Shader&lt;/p&gt;
&lt;p&gt;修改渲染管线的源码，改成符合自己项目的渲染管线，或者自定义渲染管线。&lt;/p&gt;
&lt;h2 id=&#34;结尾&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#结尾&#34;&gt;#&lt;/a&gt; 结尾&lt;/h2&gt;
&lt;p&gt;可以使用 Unity UPR 对整个项目进行性能分析，找出问题后，再手动优化它们。&lt;/p&gt;
&lt;p&gt;Unity UPR 网址：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly91cHIudW5pdHkuY24vaW5zdHJ1Y3Rpb25zL2Rlc2t0b3A=&#34;&gt;https://upr.unity.cn/instructions/desktop&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 Unity UPR 中的 Asset Checker 能对本地的整个 Unity 项目进行性能分析，帮助我们找出问题。&lt;/p&gt;
</content>
        <category term="Unity3D" scheme="https://blog.aayu.today/categories/unity/" />
        <category term="Unity3D" scheme="https://blog.aayu.today/tags/Unity3D/" />
        <updated>2023-10-21T14:52:00.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/feature/unity/20231020/</id>
        <title>Unity3D优化笔记（9）合并网格、动画、音频、物理优化</title>
        <link rel="alternate" href="https://blog.aayu.today/feature/unity/20231020/"/>
        <content type="html">&lt;h2 id=&#34;合并网格mesh-combine&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#合并网格mesh-combine&#34;&gt;#&lt;/a&gt; 合并网格（Mesh Combine）&lt;/h2&gt;
&lt;p&gt;对使用相同材质的模型可以使用第三方插件（例如：Easy Mesh Combine Tool）合并网格&lt;/p&gt;
&lt;p&gt;合并后，所有被合并的模型被整合成一个新的模型，DrawCall 和 Shader Caster 会下降，但顶点个数和三角面个数可能会增多，所以需要根据实际情况来使用&lt;/p&gt;
&lt;h2 id=&#34;动画优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#动画优化&#34;&gt;#&lt;/a&gt; 动画优化&lt;/h2&gt;
&lt;p&gt;恰当地设置 Animator 组件的 Culling Mode。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Always Animate 表示如果该动画不可见，也会播放它。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;Cull Update Transformations 表示如果该动画不可见，则不会渲染该动画，但是依然会根据该动画的播放来改变游戏对象的位置、旋转、缩放&lt;/mark&gt;，这样是常用的选项。&lt;/li&gt;
&lt;li&gt;Cull Completely 表示完全不会播放该动画，不但不会渲染该动画，而且也不会改变游戏对象的位置、旋转、缩放。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;禁用 SkinMesh Renderer 组件的 Update When Offscreen 可以让角色在不可见的时候动画不更新，这样可以减少计算量，提升性能。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;对于 Animator 组件，可以使用 Animator.StringToHash 方法获得指定字符串的哈希值&lt;/mark&gt;，再把它作为参数传入 Animator 型对象.GetXXX 方法和 Animator 型对象.SetXXX 方法中进行使用。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;不用的 Animation 组件和 Animator 组件可以考虑删掉，因为只要它们存在，就会消耗性能来检测当前的状态和过渡条件。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;一些简单的动画可以使用 DoTween、iTween 等插件实现&lt;/mark&gt;，而不需要每个动画都用 Animator 来实现。&lt;/p&gt;
&lt;h2 id=&#34;音频优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#音频优化&#34;&gt;#&lt;/a&gt; 音频优化&lt;/h2&gt;
&lt;p&gt;Unity 支持后缀为.wav、.ogg、.mp3 的音频文件，但&lt;mark&gt;建议使用 .wav，因为 Unity 对它的支持特别好&lt;/mark&gt;。注意：Unity 在构建项目时总是会自动重新压缩音频文件，因此无需刻意提前压缩一个音频文件再导入 Unity，因为这样只会降低该音频文件最终的质量。&lt;/p&gt;
&lt;p&gt;把音频文件导入 Unity 后，选中它，可以在 Inspector 窗口设置它的属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建议勾选 Force To Mono，这样就会把这个音频文件设置为单声道。可以节省该资源所占据的空间。因为很少有移动设备实际配备立体声扬声器。在移动平台项目中，将导入的音频剪辑强制设置为单声道会使其内存消耗减半。此设置也适用于没有立体声效果的任何音频，例如大多数 UI 声音效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 Load Type 选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小文件（小于 200kb）选择 Decompress on Load&lt;/li&gt;
&lt;li&gt;中等大小的文件（大于等于 200kb）选择 Compressed In Memory&lt;/li&gt;
&lt;li&gt;比较大的文件（如背景音乐）选择 Streaming&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 Compression Format 的选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PCM 表示不压缩&lt;/li&gt;
&lt;li&gt;Vorbis 表示压缩，但也会尽量保证音频的质量&lt;/li&gt;
&lt;li&gt;ADPCM 表示压缩，且压缩的程度比 Vobis 更高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;mark&gt;由于 PCM 不会压缩音频，所以占用的空间大，应尽量少用，长时间的音频文件可以使用 Vorbis，短时间的音频文件可以使用 ADPCM&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;Sample Rate Setting 用于控制音频文件的采样率，对于移动平台，采样率不需要太高，建议选择 Override Sample Rate，然后在下方的 Sample Rate 选择 22050Hz，一般这样就够用了。&lt;/p&gt;
&lt;h2 id=&#34;物理优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#物理优化&#34;&gt;#&lt;/a&gt; 物理优化&lt;/h2&gt;
&lt;p&gt;&lt;mark&gt;使用简单的碰撞器进行碰撞检测&lt;/mark&gt;，如球体碰撞器、盒子碰撞器、胶囊体碰撞器，&lt;mark&gt;少用网格碰撞器等复杂的碰撞器&lt;/mark&gt;。即使用多个简单的碰撞器组合在一起，也往往比使用网格碰撞器的性能要好。&lt;/p&gt;
&lt;p&gt;如果要把多个碰撞器组合成一个碰撞器，可以用复合碰撞器。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;如果同一个功能既可以用碰撞器来做，也可以用触发器来做，则往往使用触发器来做，性能更好。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;尽量减少刚体组件，因为刚体组件的物理计算较多。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;如果勾选刚体组件的 Is Kinematic，则性能会有所提高。但这样一来，这个刚体只会给别的刚体施加力，自己不会受到别的刚体施加的力的作用。&lt;/p&gt;
&lt;p&gt;Edit——Project Settings——Player—— 勾选 Optimization 下方的 Prebake Collision Meshes，可以提高碰撞的效率，但是构建游戏的时间会增长。&lt;/p&gt;
&lt;p&gt;Edit——Project Settings——Physics 或者 Physics 2D—— 设置 Layer Collision Matrix。它规定了哪些 Layer 层的游戏对象可以彼此碰撞，哪些 Layer 层的游戏对象会忽略碰撞。如果有些 Layer 层的游戏对象之前不需要进行碰撞，则可以在这里设置，取消勾选则表示不会碰撞。&lt;/p&gt;
&lt;p&gt;Edit——Project Settings——Time—— 稍微调大 Fixed Timestep，这样可以稍微提升游戏性能，但是物体的运动可能会出现问题。&lt;/p&gt;
</content>
        <category term="Unity3D" scheme="https://blog.aayu.today/categories/unity/" />
        <category term="Unity3D" scheme="https://blog.aayu.today/tags/Unity3D/" />
        <updated>2023-10-20T13:34:24.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/feature/unity/20231019/</id>
        <title>Unity3D优化笔记（8）UI优化、模型优化和LOD技术</title>
        <link rel="alternate" href="https://blog.aayu.today/feature/unity/20231019/"/>
        <content type="html">&lt;h2 id=&#34;ui-优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ui-优化&#34;&gt;#&lt;/a&gt; UI 优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;尽量避免使用 IMGUI 来做游戏时的 UI，因为 IMGUI 的开销比较大。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;如果一个 UGUI 的控件不需要进行射线检测，则可以取消勾选 Raycast Target。&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;尽量&lt;mark&gt;避免使用完全透明的图片和 UI 控件&lt;/mark&gt;。因为即使完全透明，我们看不见它，但它仍然会产生一定的性能开销。如果 UI 中一定要用到很多张完全透明的图片，则建议把这些完全透明的图片由单独的摄像机进行渲染，且这些 UI 不要叠加到场景摄像机的渲染范围内。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;尽量避免 UI 控件的重叠&lt;/mark&gt;。如果多个 UI 有重叠的部分，则会稍微增加一些额外的计算和渲染的开销。虽然这部分开销通常是非常小的，但我们最好也尽量避免这种情况。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;UI 的文字使用 TextMeshPro 比使用 Text 的性能更好。但是 TextMeshPro 对中文的支持不太好。&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;模型优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#模型优化&#34;&gt;#&lt;/a&gt; 模型优化&lt;/h2&gt;
&lt;p&gt;模型导入 Unity 后，可以选中这个模型，在 Inspector 窗口设置它的属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 Model 选项卡&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;mark&gt;启用 Mesh Compression 可以压缩模型，压缩程度越高，模型精度越低，但是模型也会节省一些空间。&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;如果该模型不需要用代码来读写，则可以取消勾选 Read/Write Enabled。&lt;/li&gt;
&lt;li&gt;设置 Optimize Game Objects 可以优化模型，通常默认选择 Everything。&lt;/li&gt;
&lt;li&gt;如果该模型不需要使用法线，则可以把 Normals 设置为 None。&lt;/li&gt;
&lt;li&gt;如果该模型不需要用混合变形法线，则可以把 Blend Shape Normals 设置为 None。&lt;/li&gt;
&lt;li&gt;如果该模型不需要使用切线，则可以把 Tangents 设置为 None。&lt;/li&gt;
&lt;li&gt;如果该模型不需要用光照 UV 贴图，则可以取消勾选 Swap UVs 和 Generate Lightmap UVs。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 Rig 选项卡&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Animation Type 如果选择 Generic Rig 会比 Humanoid Rig 性能更好，但无法使用动画重定向。一般使用 Humanoid Rig 是为了对人型的角色进行动画重定向，所以要根据自己的情况来选择。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;如果模型不需要使用动画，例如一些完全不会动的石头等物体，则可以将 Animation Type 选择为 None。&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;Skin Weights 默认是 4，对于一些不重要的动画对象，本变量可以设置为 1，这样可以节省计算量。&lt;/li&gt;
&lt;li&gt;建议勾选 Optimize Bones，这样会自动剔除没有蒙皮顶点的骨骼。&lt;/li&gt;
&lt;li&gt;勾选 Optimize Game Object 可以提高角色动画的性能，但是在某些情况下可能会导致角色动画出现问题，是否勾选要看动画效果而定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 Animation 选项卡&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果模型不需要使用动画，则可以取消勾选 Import Animation。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;mark&gt;设置 Anim.Compression 可以调整动画的压缩方式&lt;/mark&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Off 表示不压缩动画，这样动画文件可能会占用较大的空间，但是在运行时不会有任何信息损失，&lt;/li&gt;
&lt;li&gt;Keyframe Reduction 表示使用关键帧算法来压缩动画，这样会显著减小动画文件的大小，同时保持相对较高的动画质量，&lt;/li&gt;
&lt;li&gt;Optimal 表示会尽可能高地压缩网格，但是这样也会导致压缩时间增加。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 Materials 选项卡&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果使用 Untiy 的默认材质，则可以把 Material Creation Mode 设置为 None。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Edit——Project Settings——Player—— 勾选 Optimize Mesh Data，这样一来，Unity 会在构建的时候中对网格数据进行优化处理，以达到提高游戏性能的效果。但是这样往往会修改网格，我们勾选之后应该要进行测试，确保没有问题，再确定启用它。&lt;/p&gt;
&lt;p&gt;把多个模型的网格合并为一个网格。可以使用自己写代码，使用 Unity 自带的 CombineMeshes 方法，也可以使用资源商店的插件，在资源商店搜 Mesh Combine 可以搜索到相关的插件，例如 Easy Mesh Combine Tool 等插件。&lt;/p&gt;
&lt;p&gt;减少模型的顶点、面、材质、骨骼、蒙皮网格。这一般由美术人员来完成。&lt;/p&gt;
&lt;h2 id=&#34;lodlevel-of-detail&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#lodlevel-of-detail&#34;&gt;#&lt;/a&gt; LOD（Level of Detail）&lt;/h2&gt;
&lt;p&gt;LOD 是 Level of Detail 的简称，意思是细节层次，它是一种优化技术。&lt;/p&gt;
&lt;p&gt;LOD 的原理，就是我们可以为一个游戏对象设定多个模型，这些模型消耗的游戏性能由高到低排列。会根据摄像机距离模型的远近自动显示对应的模型。近的时候显示最精细的模型，距离中等的时候显示没那么精细的模型，远的时候显示粗糙的模型，最远的时候可以隐藏该模型。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;使用 LOD 技术能起到优化渲染性能的效果。但是使用 LOD 技术也会增加内存占用。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;在 Unity 中可以使用 LODGroup 组件来实现 LOD 技术。&lt;/p&gt;
</content>
        <category term="Unity3D" scheme="https://blog.aayu.today/categories/unity/" />
        <category term="Unity3D" scheme="https://blog.aayu.today/tags/Unity3D/" />
        <updated>2023-10-19T15:56:10.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/feature/unity/20231018/</id>
        <title>Unity3D优化笔记（7）光照优化、图片优化</title>
        <link rel="alternate" href="https://blog.aayu.today/feature/unity/20231018/"/>
        <content type="html">&lt;h2 id=&#34;光照优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#光照优化&#34;&gt;#&lt;/a&gt; 光照优化&lt;/h2&gt;
&lt;p&gt;&lt;mark&gt;减少不必要的光源的使用&lt;/mark&gt;，调节好每个 Light 组件的属性，平衡视觉效果和游戏性能。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;优先考虑使用烘焙光照或者混合光照，此时可以配合光照探针使用&lt;/mark&gt;。Lighting 窗口可以设置烘焙光照的参数。减少启用的阴影投射。&lt;/p&gt;
&lt;p&gt;根据摄像机距离光源的距离，用脚本来决定是否启用光源和阴影。但是这样就会花费一些性能来计算摄像机到光源的距离。&lt;/p&gt;
&lt;p&gt;可以考虑设置光照的阴影。无阴影的性能最好，硬阴影的性能稍差，软阴影的视觉效果最好，但是性能是这三者中最差的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;备注：&lt;mark&gt;光照和阴影最影响项目的性能，其次才是模型网格和贴图。把实时光照改成烘焙光照，可以使游戏性能大幅度增加。&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意 MeshRenderer 组件上的属性，默认情况下，Unity 会启用阴影投射和接收、光照探针采样、反射探针采样和运动矢量计算。如果项目不需要这些功能中的一个或多个，请确保关闭它们。2D 游戏尤其要注意，往往都不需要它们。&lt;/p&gt;
&lt;p&gt;远处的景物，如果确定玩家无法到达，则可以不用模型，而是把远处的景物做成一张贴图放到天空盒的材质中，给天空盒使用。也可以使用反射探针烘焙出一张贴图，然后放到天空盒的材质。&lt;/p&gt;
&lt;h2 id=&#34;图片优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#图片优化&#34;&gt;#&lt;/a&gt; 图片优化&lt;/h2&gt;
&lt;p&gt;如果这张图片是应用在移动端的，则 == 导入 Unity 前，可以对这张图的每条边进行调整，确保每条边的长度都是 2 的正整数次方个像素。== 例如 2、4、8、16...256、512、1024、2048、4096...。&lt;mark&gt;这个做法只对移动端有效。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;图片导入 Unity 后，可以选中这张图片，在 Inspector 窗口设置它的属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置这些属性，可以在&lt;mark&gt;发布不同的平台，分别对该图片进行相应的压缩。可以在合理的范围内减小 Max Size&lt;/mark&gt;，对于许多移动端的游戏，2048x2048 或 1024x1024 足以满足纹理图集的要求，而 512x512 足以满足应用于 3D 模型的纹理的要求。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;如果图片不需要读写，则可以取消勾选 Read/Write Enabled，如果勾选可能导致双倍的内存占用。&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;Filter Mode 一般选择 Bilinear 即可平衡性能和视觉效果&lt;/mark&gt;，如果选择 Point (no filter)，则视觉效果不太行，但性能开销也小，如果选择 Trilinera，则视觉效果最好，但性能开销最大。Aniso Level 一般选择 1，只有个别比较重要的图片才需要设置为大于等于 2 的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图片导入 Unity 后，会默认生成 Mip Maps 格式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当摄像机到这幅贴图距离近，则显示最原始的图片，&lt;mark&gt;当摄像机距离这幅贴图的距离远，则这幅贴图会变模糊，以此降低渲染的性能消耗。&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;但由于之前显示的一幅图，现在变成了有多幅，所以这样会略微增加内存消耗。&lt;mark&gt;如果确定本游戏的摄像机到图片的距离几乎不怎么变化，则可以禁用这个功能。&lt;mark&gt;点击该贴图，在 Inspector 面板的 Advanced 中&lt;/mark&gt;取消勾选 Generate Mip Maps，这样就不会生成 Mip Maps，增加游戏性能。&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;如果是 2D 游戏则可以禁用这个功能。如果是 UI 贴图，也可以禁用这个功能。&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图片导入 Unity 后，可以选中这张图片，在 Inspector 窗口设置它在各个平台的 Format 和 Compressor Quality。Format 可以参考官方文档：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9jbGFzcy1UZXh0dXJlSW1wb3J0ZXJPdmVycmlkZS5odG1s&#34;&gt;https://docs.unity3d.com/2021.3/Documentation/Manual/class-TextureImporterOverride.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;用 Sprite Atlas 把图片打包成图集。但是这样一来，要使用图集中的任意一张图片，都会先加载这整个图集，这样占用的内存会增加。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;Sprite Atlas 的优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减小资源文件所占的大小&lt;/li&gt;
&lt;li&gt;打包到同一个 Sprite Atlas 图集中的图片会共享相同的纹理数据，减少了重复的存储，往往能起到优化内存的作用&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;可以减少 DrawCall，提高游戏的渲染性能&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sprite Atlas 的缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要手动将图片添加到 Sprite Atlas，增加了额外的工作量&lt;/li&gt;
&lt;li&gt;当加载图集中的任意一张图，都会先加载整个图集。如果把一些不常用的图打包到同一个图集中，则会浪费内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在代码中控制加载 Sprite Atlas&lt;/p&gt;
&lt;figure class=&#34;highlight csharp&#34;&gt;&lt;figcaption data-lang=&#34;C#&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token return-type class-name&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt;&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;Awake&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	spriteAtlas &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; Resources&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token generic-method&#34;&gt;&lt;span class=&#34;token function&#34;&gt;Load&lt;/span&gt;&lt;span class=&#34;token generic class-name&#34;&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;lt;&lt;/span&gt;SpriteAtlas&lt;span class=&#34;token punctuation&#34;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;MySpriteAtlas&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token return-type class-name&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt;&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;Update&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;Input&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;KeyCode&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;Q&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;		image1&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;sprite &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; spriteAtlas&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;GetSprite&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;trees_0&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;Input&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;KeyCode&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;W&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;		image2&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;sprite &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; spriteAtlas&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;GetSprite&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;trees_1&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
        <category term="Unity3D" scheme="https://blog.aayu.today/categories/unity/" />
        <category term="Unity3D" scheme="https://blog.aayu.today/tags/Unity3D/" />
        <updated>2023-10-18T04:40:45.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/feature/unity/20231017/</id>
        <title>Unity3D优化笔记（6）遮挡剔除</title>
        <link rel="alternate" href="https://blog.aayu.today/feature/unity/20231017/"/>
        <content type="html">&lt;p&gt;正常情况下，如果一个障碍物 A 挡住了后面的物体 B，虽然我们看不见物体 B，但是 Unity 仍然会消耗性能来渲染这个物体 B。这样 CPU 和 GPU 就会有一部分性能白白浪费在渲染物体 B 身上。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;如果想在一个障碍物挡住了后面的物体后，不渲染被挡住的物体，则可以使用遮挡剔除。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;官方文档：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL2NuL2N1cnJlbnQvTWFudWFsL09jY2x1c2lvbkN1bGxpbmcuaHRtbA==&#34;&gt;https://docs.unity3d.com/cn/current/Manual/OcclusionCulling.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以一堵墙挡住几个小球为例，选中这堵墙，在 Inspector 窗口右上角的 Static 右侧的下拉菜单处选择 Occluder Static，则这堵墙就是遮挡物。分别选中这些小球，在 Inspector 窗口右上角的 Static 右侧的下拉菜单处选择 Occludee Static，则这些小球就是被遮挡物。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;注意，无论是勾选了 Occluder Static 还是 Occludee Static，勾选后物体就无法运动了。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;对于一个物体，两个标签都可以勾选，这样它既可以遮挡剔除别的物体，也可以被别的物体遮挡剔除。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;有时候被遮挡物只勾 Occludee Static，烘焙之后可能看不出遮挡剔除的效果，建议把 Occluder Static 也勾上，再重新烘焙，或许就能看出效果了。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;选中摄像机，要确保它启用了 Occlusion Culling 属性。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;设置完之后，要创建一个遮挡区域，当摄像机处于这个遮挡区域中，遮挡剔除才会生效。&lt;/p&gt;
&lt;p&gt;创建遮挡区域的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法 1、打开 Occlusion Culling 窗口。打开方法：Window——Rendering——Occlusion Culling——Bake。打开之后，选择 Object 选项卡，点击 Occlusion Areas，点击 Create New 右侧的 Occlusion Area。&lt;/li&gt;
&lt;li&gt;方法 2、创建一个空物体，在它身上添加 Occlusion Area 组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Occlusion Area 组件的 Size 决定了遮挡剔除区域的范围，它越大，烘焙之后生成的遮挡剔除区域就越大。Center 控制遮挡区域中心点的世界坐标。&lt;mark&gt;Is View Volume 表示是否定义视图体积，只有启用了这个选项，Occlusion Area 组件才可能生效。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;之后，要让遮挡剔除生效，还要在 Occlusion Culling 窗口的 Bake 选项卡中点击右下方的 Bake 按钮，进行烘焙，遮挡剔除才可能生效。&lt;mark&gt;而且以后每次调整完场景的遮挡物、被遮挡物、Occlusion Area 组件的范围，都要这样烘焙一次&lt;/mark&gt;。如果点击旁边的 Clear 按钮，则会清除之前烘焙的数据。&lt;/p&gt;
&lt;p&gt;烘焙完之后，当摄像机在 Occlusion Area 组件的范围内，则被遮挡的物体不会被渲染。遮挡物实际上遮挡了摄像机视锥体的范围，只要物体完全没有出现在摄像机视锥体的范围内，则都不会被渲染。&lt;mark&gt;但是一旦物体的任意一小部分暴露在了摄像机视锥体的范围内，则这个物体整个会被渲染出来&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;当摄像机移出了 Occlusion Area 组件的范围，则遮挡剔除会失效。&lt;/p&gt;
&lt;p&gt;Occlusion Culling 窗口：&lt;/p&gt;
&lt;p&gt;Object 选项卡。通过点击 All、Renderers、Occlusion Areas 按钮可以筛选 Hierarchy 窗口的内容。之后，在 Hierarchy 窗口或 Scene 窗口中选择一个筛选出来的游戏对象，就可以 Occlusion Culling 窗口中查看它的遮挡剔除设置。&lt;/p&gt;
&lt;p&gt;Bake 选项卡。用于烘焙。&lt;mark&gt;遮挡剔除必须烘焙之后才可能生效&lt;/mark&gt;。Set default parameters 用于将参数重置为默认值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Smallest Occluder 表示用于遮挡其它游戏对象的最小游戏对象的大小，以米为单位，数值越小遮挡的效果越精确，但是性能开销也越大。Smallest Hole 表示摄像机可以看到的最小间隙的直径，以米为单位，需要注意的是，设置过小的&lt;/li&gt;
&lt;li&gt;Smallest Hole 值可能会导致一些细微的间隙被错误地认为是可见的，从而导致部分遮挡物不被正确地剔除。&lt;/li&gt;
&lt;li&gt;Backface Threshold 的数值越小，烘焙所产生的文件所占空间就越小，但也可能造成视觉上的失真。Bake 按钮用于烘焙。Clear 按钮用于清除上一次烘焙的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Visualization 选项卡。选择后，可以在 Scene 窗口看到遮挡剔除的效果。此时在 Scene 窗口可以看到三个选项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Camera Volumes。启用后，可以在 Scene 窗口看到黄色区域，当摄像机在这个黄色区域内，遮挡剔除才可能会生效，摄像机离开这个区域，则遮挡剔除就会失效。我们还可以看到灰线，这些灰线指示摄像机当前位置所对应的遮挡剔除数据中的单元格以及当前单元格中的细分。Bake 选项卡 Smallest Hole 参数设置定义了单元格内细分的最小大小，它的值越小，每个单元格产生的细分越多且越小，从而使精度提高并且文件增大。&lt;/li&gt;
&lt;li&gt;Visibility Lines。启用后，我们会看到绿色的区域，它表示摄像机可以看到的范围。&lt;/li&gt;
&lt;li&gt;Portals。启用后，我们可以看到一些线，它们代表遮挡数据中单元格之间的连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进行遮挡剔除的烘焙时，不会烘焙动态的游戏对象的信息到遮挡剔除的数据中。动态的游戏对象只能作为被遮挡物，而不能充当遮挡物。要让动态的游戏对象成为遮挡剔除中的被遮挡物，可以选中它，启用它身上 Mesh Renderer 组件身上的 Dynamic Occlusion 属性。&lt;/p&gt;
&lt;h2 id=&#34;在代码中控制遮挡剔除&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#在代码中控制遮挡剔除&#34;&gt;#&lt;/a&gt; 在代码中控制遮挡剔除&lt;/h2&gt;
&lt;p&gt;使用 Occlusion Portal 组件也可以实现遮挡剔除。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;例如可以在一堵墙上添加 Occlusion Portal 组件。而且这堵墙不勾选 Inspector 窗口右上角下拉菜单的 Occluder Static 和 Occludee Static，但是被它遮挡的物体仍然要勾选 Occluder Static 和 Occludee Static。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;设置好之后，打开 Occlusion Culling 窗口，在 Bake 选项卡进行烘焙。&lt;/p&gt;
&lt;p&gt;这样一来，Occlusion Portal 组件就会生效。当取消勾选它的 Open 属性后，被这堵墙就会使用遮挡剔除。当勾选它的 Open 属性后，被这堵墙就不会使用遮挡剔除。我们可以使用代码来控制 Open 属性，控制这堵墙在什么时候使用遮挡剔除，什么时候不使用遮挡剔除。&lt;/p&gt;
&lt;p&gt;Occlusion Portal 组件的 Center 属性控制了中心的位置，Size 属性控制了遮挡的范围。点击 Edit Bounds 左侧的按钮后，可以在 Scene 窗口手动调节 Occlusion Portal 组件的遮挡范围。每次调整完，或者修改过场景，都要重新烘焙。&lt;/p&gt;
</content>
        <category term="Unity3D" scheme="https://blog.aayu.today/categories/unity/" />
        <category term="Unity3D" scheme="https://blog.aayu.today/tags/Unity3D/" />
        <updated>2023-10-17T05:43:03.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/feature/unity/20231016/</id>
        <title>Unity3D优化笔记（5）静态合批、动态合批和GPU Instancing</title>
        <link rel="alternate" href="https://blog.aayu.today/feature/unity/20231016/"/>
        <content type="html">&lt;h2 id=&#34;静态合批&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#静态合批&#34;&gt;#&lt;/a&gt; 静态合批&lt;/h2&gt;
&lt;p&gt;静态合批也叫静态批处理，是 Unity 的一种优化技术。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;对于始终静止不动的物体使用静态合批后，CPU 会把它们合并为一个批次发送给 GPU 处理，这样可以减少 Draw Call 带来的性能消耗，从而提升游戏性能。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;官方文档：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL2NuL2N1cnJlbnQvTWFudWFsL3N0YXRpYy1iYXRjaGluZy5odG1s&#34;&gt;https://docs.unity3d.com/cn/current/Manual/static-batching.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;要使用静态合批，必须确保 Edit——Project Settings——Player——Other Settings——Static Batching 是勾选的。&lt;/p&gt;
&lt;p&gt;把一个物体设置为静态的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选中该物体，点击在 Inspector 窗口右上角的 Static 右方的下拉菜单，选择 Batching Static。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;mark&gt;使用静态合批虽然可以提升游戏性能，但是设置为静态的物体在整个游戏中就不能再运动了，强行使它们运动会出问题。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;而且即使按照以上步骤进行了静态合批，也不一定保证会成功，必须满足以下全部条件，静态合批才会成功：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;游戏对象处于激活状态。&lt;/li&gt;
&lt;li&gt;游戏对象有一个 Mesh Filter 组件，并且该组件已启用。&lt;/li&gt;
&lt;li&gt;Mesh Filter 组件具有对网格的引用。&lt;/li&gt;
&lt;li&gt;网格已启用 Read/Write 功能。&lt;/li&gt;
&lt;li&gt;网格的顶点计数大于 0。&lt;/li&gt;
&lt;li&gt;该网格尚未与另一个网格组合。&lt;/li&gt;
&lt;li&gt;游戏对象有一个 Mesh Renderer 组件，并且该组件已启用。&lt;/li&gt;
&lt;li&gt;网格渲染器组件不将任何材质与 DisableBatching 标记设置为 true 的着色器一起使用。&lt;/li&gt;
&lt;li&gt;要批处理在一起的网格使用相同的顶点属性。例如，Unity 可以将使用顶点位置、顶点法线和一个 UV 的网格与另一个 UV 进行批处理，但不能将使用顶点定位、顶点法线、UV0、UV1 和顶点切线的网格进行批处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即使静态合批成功，&lt;mark&gt;合出来的每个批次可以包含的网格顶点数是有限的，最多是 64000 个顶点。如果超过这个数，则会创建到另一个批次中。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;如果要在游戏运行时进行静态合批，则可以使用 StaticBatchingUtility 类的 Combine 方法。&lt;/p&gt;
&lt;p&gt;StaticBatchingUtility.Combine (GameObject 根物体)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对指定的根物体的所有子孙物体进行静态合批。&lt;/li&gt;
&lt;li&gt;只有当它们符合静态合批的所有条件，静态合批才会成功。&lt;/li&gt;
&lt;li&gt;成功之后，这些物体就不能再运动了，强行运动会出问题。但是该根物体仍然允许运动。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;StaticBatchingUtility.Combine (GameObject [] 要进行静态合批的游戏对象，GameObject 根物体)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对指定的游戏对象进行静态合批，并指定它们静态合批的根物体。&lt;/li&gt;
&lt;li&gt;只有当它们符合静态合批的所有条件，静态合批才会成功。&lt;/li&gt;
&lt;li&gt;成功之后，这些物体就不能再运动了，强行运动会出问题。但是该根物体仍然允许运动。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;动态合批&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#动态合批&#34;&gt;#&lt;/a&gt; 动态合批&lt;/h2&gt;
&lt;p&gt;动态合批也叫动态批处理，是 Unity 的一种优化技术。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;对移动的物体使用动态合批后，则 Unity 不会一个个绘制它们，而是把它们合并为一个批次（Batch）&lt;/mark&gt;，再由 CPU 把它们一次性提交给 GPU 进行处理，这样可以减少 Draw Call 带来的性能消耗，从而提高性能。&lt;/p&gt;
&lt;p&gt;官方文档：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL2NuL2N1cnJlbnQvTWFudWFsL2R5bmFtaWMtYmF0Y2hpbmcuaHRtbA==&#34;&gt;https://docs.unity3d.com/cn/current/Manual/dynamic-batching.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;动态合批默认是由 Unity 自动完成&lt;/mark&gt;。可以在 Edit——Project Settings——Player——Other Settings——Dynamic Batching 查看。&lt;mark&gt;默认 Dynamic Batching 是勾选的&lt;/mark&gt;，当条件满足时，&lt;mark&gt;Unity 会自动对使用了相同材质（Material）的物体进行动态合批&lt;/mark&gt;。如果取消勾选，则不会进行动态合批。&lt;/p&gt;
&lt;p&gt;即使勾选了 Dynamic Batching，也必须同时满足以下条件，动态合批才会成功：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Unity 不能对包含超过 900 个顶点属性和 225 个顶点的网格应用动态批处理。这是因为网格的动态批处理对每个顶点都有开销。例如，如果你的着色器使用顶点位置、顶点法线和单个 UV，那么 Unity 最多可以批处理 225 个顶点。然而，如果你的着色器使用顶点位置、顶点法线、UV0、UV1 和顶点切线，那么 Unity 只能批处理 180 个顶点。&lt;/li&gt;
&lt;li&gt;如果 GameObjects 使用不同的材质实例，Unity 就不能将它们批处理在一起，即使它们本质上是相同的。唯一的例外是阴影施法者的渲染。&lt;/li&gt;
&lt;li&gt;带有光贴图的游戏对象有额外的渲染参数。这意味着，如果你想批处理光照贴图的游戏对象，它们必须指向相同的光照贴图位置。&lt;/li&gt;
&lt;li&gt;Unity 不能完全将动态批处理应用于使用多通道着色器的 GameObjects。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;几乎所有的 Unity 着色器都支持正向渲染中的多个光源。为了实现这一点，他们为每个光处理一个额外的渲染通道。Unity 只批处理第一个渲染通道。它不能批处理额外的逐像素灯光的绘制调用。&lt;/p&gt;
&lt;p&gt;遗留延迟渲染路径不支持动态批处理，因为它在两个渲染通道中绘制 GameObjects。第一个通道是灯光预通道，第二个通道渲染 GameObjects。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;其中我们要注意的是，物体必须使用相同的材质，才有可能成功进行动态合批。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;使用动态合批往往能减少 CPU 和 GPU 的开销，提升游戏性能，但同时也会占用一定的内存。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;是否要开启动态合批，要根据自己的项目来定。可以尝试启用，在性能分析器中看看效果如果，如果效果好，再确定启用它。&lt;/p&gt;
&lt;h2 id=&#34;gpu-instancing&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#gpu-instancing&#34;&gt;#&lt;/a&gt; GPU Instancing&lt;/h2&gt;
&lt;p&gt;GPU Instancing 是 Unity 的一种优化技术。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;使用 GPU Instancing 可以在一个 Draw Call 中同时渲染多个相同或类似的物体&lt;/mark&gt;，从而减少 CPU 和 GPU 的开销。&lt;/p&gt;
&lt;p&gt;官方文档：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9HUFVJbnN0YW5jaW5nLmh0bWw=&#34;&gt;https://docs.unity3d.com/Manual/GPUInstancing.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;要启用 GPU Instancing，我们可以选中一个材质，然后在 Inspector 窗口勾选 Enable GPU Instancing，这样就可以了。&lt;/p&gt;
&lt;p&gt;但是即使勾选了 Enable GPU Instancing，也不一定会成功。&lt;/p&gt;
&lt;p&gt;要成功使用 GPU Instancing 进行优化，游戏对象必须同时满足以下条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;mark&gt;使用相同的材质和网格。&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;材质的着色器必须支持 GPU Instancing。例如标准着色器和表面着色器就支持 GPU Instancing。&lt;/li&gt;
&lt;li&gt;网格的顶点布局和着色器必须相同。如果网格的顶点布局或着色器不同，那么它们就无法被合并成一个实例。&lt;/li&gt;
&lt;li&gt;每个实例需要有不同的变换信息（例如位置、旋转、缩放）。虽然多个实例可以使用相同的材质和网格，但是它们必须拥有不同的变换信息才能被正确地实例化并渲染出来。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外需要注意的是，GPU Instancing 与 SRP Batcher 不兼容。如果项目使用了 SRP Batcher，并且配置为优先使用 SRP Batcher 而不是 GPU 实例化，启用 GPU 实例化可能不会生效。SRP Batcher 是 Unity 提供的一种渲染优化技术，它可以将多个网格合并成单个批次进行渲染，从而提高性能。在这种情况下，GPU 实例化将被忽略。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;使用 GPU Instancing 往往能减少 CPU 和 GPU 的开销，提升游戏性能，但同时也会占用一定的内存。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;是否要启用 GPU Instancing，要根据自己的项目来定。可以尝试启用，在性能分析器中看看效果如果，如果效果好，再确定启用它。&lt;/p&gt;
&lt;p&gt;一般来说，当场景中有大量重复的网格实例时，可以尝试启用 GPU Instancing。例如场景中有大量树木、草地、石块等，这些实例具有相同的网格和材质，只是位置、颜色等属性稍有差异，那么启用 GPU Instancing 或许能够显著提高性能。&lt;/p&gt;
</content>
        <category term="Unity3D" scheme="https://blog.aayu.today/categories/unity/" />
        <category term="Unity3D" scheme="https://blog.aayu.today/tags/Unity3D/" />
        <updated>2023-10-16T05:38:40.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/feature/unity/20231006/</id>
        <title>XREAL开发笔记（1）照片溶解特效</title>
        <link rel="alternate" href="https://blog.aayu.today/feature/unity/20231006/"/>
        <content type="html">&lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;最近学了一个照片溶解特效，感觉很炫酷，也可以作为后续项目花里胡哨的基础，便在此将学习过程记录一下吧～&lt;/p&gt;
&lt;p&gt;话不多说，先看看最终效果～&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071342614.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建和配置项目&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建和配置项目&#34;&gt;#&lt;/a&gt; 创建和配置项目&lt;/h2&gt;
&lt;p&gt;选择 3D（URP）项目，然后点击 Create Project 即可创建项目。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/06/202310062329303.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;打开 Unity，File--&amp;gt;Build Settings, 选择 Android，点击 Switch Platform&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071110378.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在 Build Settings 窗口中，选择 Player Settings, 然后按照下面对应的设置进行配置&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071112820.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071115921.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071115680.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071118937.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071118023.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;导入-nrsdk&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#导入-nrsdk&#34;&gt;#&lt;/a&gt; 导入 NRSDK&lt;/h2&gt;
&lt;p&gt;将 NRSDKForUnity_Release_1.10.2 拖入到 Assets 文件夹中，点击 Import 即可导入&lt;/p&gt;
&lt;p&gt;在 Scenes 文件夹下创建个新场景，删除默认的相机，将 NRCameraRig 和 NRInput 拖拽到场景中&lt;/p&gt;
&lt;h2 id=&#34;创建-shader&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建-shader&#34;&gt;#&lt;/a&gt; 创建 Shader&lt;/h2&gt;
&lt;p&gt;在 Assets 下创建 Materials 文件夹，在 Materials 文件夹上右键，点击 Create -&amp;gt; Shader Graph -&amp;gt; URP -&amp;gt; Lit Shader Graph，命名为 Dissolve，双击打开&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071135598.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;小 Tip：双击选项卡可以最大化选项卡，再次双击可以恢复&lt;/p&gt;
&lt;p&gt;首先创建 4 个可以暴露的属性，注意创建属性的类型&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071138114.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;然后将 MainTex 拖拽到画板里，从节点拉出一根线然后在空白书松开，选择 Sample Texture 2D，双击创建新节点，然后把 RGBA 连接到 Base Color&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071141655.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;勾选 Graph Inspector 窗口里的 Alpha Clip，可以看到片元着色器就会多出两个属性，透明度和透明度裁剪阈值，我们的溶解特效就是根据这两个属性实现的。具体来讲就是随机一个高斯噪声，根据噪声透明度和阈值裁剪照片，将透明度小于该值的像素点裁剪掉，通过将阈值从小变到大，从而实现溶解特效。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071145121.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在画板空白处右键，选择 Simple Noise 节点创建，将 X 值调为 30 左右，然后将 Out 连接到 Alpha 变量上&lt;/p&gt;
&lt;p&gt;为了溶解特效更加炫酷，可以将溶解边缘增加发光效果，具体节点和连接如下&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071202381.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;小 Tip：可以框选住一些节点，然后右键选择 Group Selection，可以将这些节点合并成一个节点，方便一起拖拽&lt;/p&gt;
&lt;p&gt;可以在右侧 Graph Inspector 窗口的 Node Settings 里将 AlphaThreshold 模式变为滑动条模式，并给一个默认值 0.5，就可以看到 Step 节点下面的预览图像为二值化后的图像了&lt;/p&gt;
&lt;p&gt;RimColor 将模式变为 HDR，然后默认颜色可以设为红色，这样就可以将溶解边缘设为红色的发光了&lt;/p&gt;
&lt;p&gt;然后再将最后的 Out 连接到片元着色器的 Emission 上，这样溶解边缘发光的 Shader 就配置好啦&lt;/p&gt;
&lt;p&gt;边缘发光的宽度可以通过 RimWidth 属性控制，可以将 RimWidth 也设为滑动条模式，然后范围设为 0 到 5，默认值为 2&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071204576.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;至此，溶解特效的 Shader 就配置好啦，点击左上角的 Save Asset 保存，然后双击选项卡退出最大化&lt;/p&gt;
&lt;h2 id=&#34;创建材质&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建材质&#34;&gt;#&lt;/a&gt; 创建材质&lt;/h2&gt;
&lt;p&gt;在 Assets 里的 Dissolve Shader 上右键，点击 Create -&amp;gt; Material，命名为 Mat_Dissolve&lt;/p&gt;
&lt;p&gt;然后在场景中创建一个 Quad，双击可以聚焦到这个物体，然后将 Mat_Dissolve 拖拽到这个物体上，就可以看到这个物体的材质变成了 Mat_Dissolve&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071211267.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;现在溶解特效就已经可以看出来了&lt;/p&gt;
&lt;p&gt;可以将 Quad 的 Z 值设为 3，即物体在镜头外 3 米的地方，这样就可以在 Game 窗口里看到物体了&lt;/p&gt;
&lt;p&gt;将 NRSDK 里自带的 Image 拖拽到我们在 Shader 里设置的 MainTex 属性上&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071215794.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;然后拖拽 AlphaThreshold 就可以看到效果了&lt;/p&gt;
&lt;p&gt;想要看到炫光还需要一点配置&lt;/p&gt;
&lt;p&gt;首先在场景处右键，选择 Volume -&amp;gt; Global Volume，然后配置文件选择默认已有的 SampleSceneProfile 即可&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071221375.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;然后将 LeftCamera，CenterCamera，RightCamera 的 Post Processing 都打上勾，即启用后处理配置&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071224514.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;然后再回到 Quad，可以在 RimColor 里调整炫光强度&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071225331.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;至此，照片溶解特效就配置好啦&lt;/p&gt;
&lt;h2 id=&#34;编写脚本&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#编写脚本&#34;&gt;#&lt;/a&gt; 编写脚本&lt;/h2&gt;
&lt;p&gt;在 Assets 下创建 Scripts 文件夹，然后在 Scripts 文件夹上右键，点击 Create -&amp;gt; C# Script，命名为 Dissolve，双击打开代码编辑器，代码内容如下&lt;/p&gt;
&lt;figure class=&#34;highlight csharp&#34;&gt;&lt;figcaption data-lang=&#34;C#&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;token namespace&#34;&gt;System&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;Collections&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;token namespace&#34;&gt;UnityEngine&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;Dissolve&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;token type-list&#34;&gt;&lt;span class=&#34;token class-name&#34;&gt;MonoBehaviour&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;readonly&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt;&lt;/span&gt; mAlphaThreshold &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; Shader&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;PropertyToID&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;_AlphaThreshold&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;token return-type class-name&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt;&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;StartDissolve&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token function&#34;&gt;StartCoroutine&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;DissolveEffect&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;token return-type class-name&#34;&gt;IEnumerator&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;DissolveEffect&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token comment&#34;&gt;// 获取当前物体的 MeshRenderer 组件&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token class-name&#34;&gt;MeshRenderer&lt;/span&gt; meshRenderer &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; gameObject&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token generic-method&#34;&gt;&lt;span class=&#34;token function&#34;&gt;GetComponent&lt;/span&gt;&lt;span class=&#34;token generic class-name&#34;&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;lt;&lt;/span&gt;MeshRenderer&lt;span class=&#34;token punctuation&#34;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token comment&#34;&gt;// 获取当前物体的材质&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token class-name&#34;&gt;Material&lt;/span&gt; material &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; meshRenderer&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;material&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token comment&#34;&gt;// 将材质的溶解值缓慢从 0 变为 1，持续 2s&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token keyword&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token class-name&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;float&lt;/span&gt;&lt;/span&gt; i &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; i &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; i &lt;span class=&#34;token operator&#34;&gt;+=&lt;/span&gt; Time&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;deltaTime&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;22&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;            material&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;SetFloat&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mAlphaThreshold&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; i&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;23&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;            &lt;span class=&#34;token keyword&#34;&gt;yield&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;24&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;25&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class=&#34;token comment&#34;&gt;// 重新设置溶解值为 0&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;26&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        material&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;SetFloat&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mAlphaThreshold&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;27&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;28&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在 Quad 上添加一个 Button 组件，并将 Dissolve 脚本先拖拽到 Quad 物体上，然后把 Quad 拖拽到 On Click 事件里，然后选择 Dissolve -&amp;gt; StartDissolve&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071252207.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这样，当控制器的射线点击到 Quad 上时，就会触发溶解特效了&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://image.aayu.today/uploads/2023/10/07/202310071256539.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;最后就是构建成手机 App，然后将 Air2 眼镜切换为 3D 模式，运行应用就可以看到效果啦&lt;/p&gt;
&lt;p&gt;完结撒花～&lt;/p&gt;
</content>
        <category term="Unity3D" scheme="https://blog.aayu.today/categories/unity/" />
        <category term="XREAL" scheme="https://blog.aayu.today/categories/unity/XREAL/" />
        <category term="Unity3D" scheme="https://blog.aayu.today/tags/Unity3D/" />
        <category term="XREAL" scheme="https://blog.aayu.today/tags/XREAL/" />
        <updated>2023-10-06T15:12:33.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/feature/unity/20231005/</id>
        <title>Unity3D优化笔记（4）其他分析工具</title>
        <link rel="alternate" href="https://blog.aayu.today/feature/unity/20231005/"/>
        <content type="html">&lt;h2 id=&#34;unity-frame-debugger-窗口帧调试器窗口&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unity-frame-debugger-窗口帧调试器窗口&#34;&gt;#&lt;/a&gt; Unity Frame Debugger 窗口（帧调试器窗口）&lt;/h2&gt;
&lt;p&gt;Frame Debugger 窗口也叫帧调试器窗口，用于查看每一帧的画面是如何渲染出来的，可以详细查看这一帧的绘制过程。&lt;/p&gt;
&lt;p&gt;打开 Frame Debugger 面板的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Window——Analysis——Frame Debugger&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按下 “Enable”，则会启动帧调试，此时如果运行了游戏，则会自动暂停，然后当前这帧的渲染情况可以在这个窗口中查看。&lt;/p&gt;
&lt;p&gt;上方的 X of X 表示绘制过程中有多少步，可以查看下一步或上一步。&lt;/p&gt;
&lt;p&gt;如果要禁用帧调试，可以按下 “Disable”。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;用 Frame Debugger 窗口查看当前一帧的每一步时，可以配合 Stats 窗口使用，以此来确定哪一个物体造成的性能开销较大&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;绘制的步骤越少，性能越好。&lt;/p&gt;
&lt;p&gt;Frame Debugger 窗口也能看到每一帧的 Shader 信息，但是需要有一定 Shader 基础才能看懂。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大多数平台都支持帧调试器的使用，可以用手机的数据线成功连接到电脑，在手机上运行 Unity 的游戏，Frame Debugger 窗口中会多出该手机设备供我们选择，我们就可以分析该手机设备上运行的 Unity 项目的性能。&lt;/li&gt;
&lt;li&gt;也可以让手机和电脑都连接同一个 wifi，这样一来，Frame Debugger 窗口中也会多出该手机设备供我们选择，我们就可以分析该手机设备上运行的 Unity 项目的性能。&lt;/li&gt;
&lt;li&gt;但是要注意，构建时必须在 Project Settings 窗口中勾选 “Development Build”。而且有些平台可能不支持 Frame Debugger 的使用，例如 WebGL 平台。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;memory-profiler&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#memory-profiler&#34;&gt;#&lt;/a&gt; Memory Profiler&lt;/h2&gt;
&lt;p&gt;&lt;mark&gt;Memory Profiler 可以查看游戏当前一帧具体的内存使用情况&lt;/mark&gt;，我们可以详细地看到各种东西占用了多少内存。&lt;/p&gt;
&lt;p&gt;如果发现某样东西占用了过高的内存，则可以考虑问题是不是出在它身上，从它身上入手来进行优化。也可以分析是不是存在内存泄漏问题，即可以分析是不是某些资源一直占着内存得不到释放，才导致内存占用过高。&lt;/p&gt;
&lt;p&gt;旧版 Unity 安装它的方法：&lt;br /&gt;
Windows——Package Manager——All packages——Memory Profiler——Install&lt;br /&gt;
 如果找不到，说明它可能在当前 Unity 版本下是预览版，可以在 Advanced 下拉菜单选择 Show preview packages，再查找它出来安装&lt;/p&gt;
&lt;p&gt;安装方法：&lt;br /&gt;
Edit——Project Settings——Package Manager—— 勾选 Enable Pre-release Packages—— 关闭窗口 ——Window——Package Manager—— 点击左上方的 + 号 ——Add package by name—— 输入 com.unity.memoryprofiler—— 点击 Add&lt;br /&gt;
 注意：下载的时候可能需要科学上网。&lt;/p&gt;
&lt;p&gt;安装完后打开方式：&lt;br /&gt;
Window——Analysis——Memory Profiler&lt;/p&gt;
&lt;p&gt;点击 Capture New Snapshot 会创建当前这一时刻的内存快照，可以看到这一帧的内存情况。== 它默认会存储在与 Assets 文件夹同级的目录的一个叫做 MemoryCaptures 的文件夹中。== 如果要修改这个路径，也可以点击右上角的三点，点击 Open Preferences，修改 Memory Snapshot Storage Path 的值。&lt;/p&gt;
&lt;p&gt;Single Snapshot 表示用来分析单张内存快照，Compare Snapshots 可以通过对比来分析两张内存快照。&lt;/p&gt;
&lt;p&gt;选中一张内存快照后，点击 Tree Map 可以看出各种资源和脚本所占用的内存，选中其中一块，可以具体地看出到底它们分别占用多少内存。如果某个名字的资源占用的内存高，那么可以考虑问题是不是出在它身上，这样我们就可以从它身上入手来进行优化。但是要注意，有一些名字的资源可能在项目中不找到，因为它们是 Unity 自带的资源。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;在 Unity 编辑器中运行游戏，Memory Profiler 记录的内存情况可能会不准确&lt;/mark&gt;，它会把 Unity 编辑器的一些内存占用情况也记录进去。&lt;mark&gt;我们应该把游戏构建到电脑或者手机，然后在电脑或者手机上运行游戏，再用 Memory Profiler 拍内存快照来分析，此时这些内存快照记录的数据才是准确的。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;构建项目到电脑时，应勾选 Build Settings 窗口的 Development Build、Autoconnect Profiler，这样当发布的游戏运行时，就可以在 Unity 引擎的 Memory Profiler 左上角的下拉菜单选择关联刚才发布的程序，拍下快照查看它的内存占用情况。&lt;/p&gt;
&lt;p&gt;用手机数据线连接到电脑，在手机上运行游戏，并在电脑分析，也必须勾选 Build Settings 窗口的 Development Build、Autoconnect Profiler，而且手机上应勾选 “开启开发者选项”、“USB 调试”、“USB 安装”。当用手机数据线连接到电脑，Memory Profiler 左上的下拉菜单可以选择连接到电脑的手机设备。&lt;/p&gt;
&lt;h2 id=&#34;unity-physics-debugger-窗口物理调试窗口&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unity-physics-debugger-窗口物理调试窗口&#34;&gt;#&lt;/a&gt; Unity Physics Debugger 窗口（物理调试窗口）&lt;/h2&gt;
&lt;p&gt;Physics Debugger 窗口也叫物理调试窗口，使用它可以在 Scene 窗口中查看当前场景中游戏对象的碰撞器、触发器、刚体、关节等与物理模拟相关的东西的范围。尤其是在游戏对象较多的场景中，&lt;mark&gt;使用物理调试窗口可以方便我们观看它们的范围&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;打开方法：Window——Analysis——Physics Debugger&lt;/p&gt;
&lt;p&gt;官方文档：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL2NuL2N1cnJlbnQvTWFudWFsL1BoeXNpY3NEZWJ1Z1Zpc3VhbGl6YXRpb24uaHRtbA==&#34;&gt;https://docs.unity3d.com/cn/current/Manual/PhysicsDebugVisualization.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在 Scene 窗口中勾选 Collision Geometry，则会在 Scene 窗口中显示游戏对象的碰撞几何体，具体的情况可以在 Physics Debugger 窗口中查看到和修改。如果勾选 Mouse Select，则会开启鼠标悬停和鼠标选择功能，方便查看碰撞几何体。&lt;/p&gt;
&lt;p&gt;点击右上方的 Reset 可以重置 Physics Debugger 窗口中的设置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Selected Object Info 表示当前选中的游戏对象的信息。&lt;/li&gt;
&lt;li&gt;Show Physics Scene 表示要在哪些场景中显示碰撞几何体。&lt;/li&gt;
&lt;li&gt;Show Layers 表示哪些 Layer 层的游戏对象要显示碰撞几何体。&lt;/li&gt;
&lt;li&gt;Show Static Colliders 表示显示静态的碰撞器组件的范围。&lt;/li&gt;
&lt;li&gt;Show Triggers 表示显示勾选了 Is Trigger 属性的碰撞器的范围。&lt;/li&gt;
&lt;li&gt;Show Rigidbodies 表示显示 Rigidbody 组件的范围。&lt;/li&gt;
&lt;li&gt;Show Kinematic Bodies 表示显示勾选了 Is Kinematic 的 Rigidbody 组件的范围。&lt;/li&gt;
&lt;li&gt;Show Articulation Bodies 表示显示 Articulation Body 组件的范围。Articulation Body 组件用于模拟机器人、车辆等物体的关节行为。例如可以实现机器人的动作、车辆的悬挂等物理效果。&lt;/li&gt;
&lt;li&gt;Show Sleeping Bodies 表示显示处于睡眠状态的 Rigidbody 组件的范围。当一个刚体在一段时间内没有受到外力作用，则会自动进入睡眠状态，进入睡眠状态的刚体不会参与物理模拟。当它再次受到外力的作用时，它就会从睡眠状态中唤醒，此时就又会重新参与物理模拟了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Collider Types&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Show BoxColliders 表示显示盒子碰撞器的范围。&lt;/li&gt;
&lt;li&gt;Show SphereColliders 表示显示球体碰撞器的范围。&lt;/li&gt;
&lt;li&gt;Show CapsuleColliders 表示显示胶囊体碰撞器的范围。&lt;/li&gt;
&lt;li&gt;Show MeshColliders (convex) 表示显示网格碰撞器的范围。&lt;/li&gt;
&lt;li&gt;Show MeshColliders (concave) 表示显示网格碰撞器的范围。&lt;/li&gt;
&lt;li&gt;Show Terrain Colliders 表示显示地形碰撞器的范围。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Colors&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Static Colliders 表示显示静态的碰撞器的颜色。&lt;/li&gt;
&lt;li&gt;Triggers 表示显示勾选了 Is Trigger 属性的碰撞器的颜色。&lt;/li&gt;
&lt;li&gt;Rigidbodies 表示显示 Rigidbody 组件的颜色。&lt;/li&gt;
&lt;li&gt;Kinematic Bodies 表示显示勾选了 Is Kinematic 的 Rigidbody 组件的颜色。&lt;/li&gt;
&lt;li&gt;Articulation Bodies 表示显示 Articulation Body 组件的颜色。&lt;/li&gt;
&lt;li&gt;Sleeping Bodies 表示显示处于睡眠状态的 Rigidbody 组件的颜色。&lt;/li&gt;
&lt;li&gt;Variation 表示要显示的颜色与随机颜色混合的程度。调节这个变量，会影响所有显示的几何碰撞体的颜色。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rendering&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Transparency 控制绘制的碰撞几何体的透明度。&lt;/li&gt;
&lt;li&gt;Force Overdraw，勾选后，绘制的碰撞集合体会更加清晰。&lt;/li&gt;
&lt;li&gt;View Distance 控制能在 Scene 窗口中看到碰撞几何体的距离。&lt;/li&gt;
&lt;li&gt;Terrain Tiles Max 控制能在 Scene 窗口中看到 Unity 自带的地形系统 Terrain 的瓦片的最大数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;unity-import-activity-窗口&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unity-import-activity-窗口&#34;&gt;#&lt;/a&gt; Unity Import Activity 窗口&lt;/h2&gt;
&lt;p&gt;&lt;mark&gt;Import Activity 可以查看项目中的资源的信息。例如什么时候导入这个资源的、这个资源的文件大小等&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;打开方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Window——Analysis——Import Activity&lt;/li&gt;
&lt;li&gt;右击一个资源，点击 View in Import Activity Window。&lt;/li&gt;
&lt;li&gt;在 Inspector 窗口中右击 Inspector，点击 Open in Import Activity Window。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;官方文档：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9JbXBvcnRBY3Rpdml0eVdpbmRvdy5odG1s&#34;&gt;https://docs.unity3d.com/2021.2/Documentation/Manual/ImportActivityWindow.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;点击左上方的 Show Overview 可以看出项目中依赖最多的资源和导入时花费时间最长的资源。&lt;/p&gt;
&lt;p&gt;左上方 Options 的选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use relative timestamps：勾选后，资源的最后导入时间会以 “几小时前”、“几天前” 这样的格式显示。取消勾选，则资源的最后导入时间会以 “日 - 月 - 年小时：分钟：秒” 的格式显示。&lt;/li&gt;
&lt;li&gt;Show previous imports：勾选后，选中一个资源，则会显示这个资源以前导入时的信息，也能在 Library 文件夹中查看一个资源有多少个历史版本。但是要注意，当 Unity 的 AGC（Artifact Garbage Collection）运行时，或者重新启动 Unity 时，以前导入的资源的信息会被清空掉。如果要关闭 AGC 的执行，则可以取消勾选 “Edit——Project Settings——Editor——Remove unused Artifacts on Restart”，也可以在脚本中通过 EditorUserSettings.artifactGarbageCollection 来禁用它。&lt;/li&gt;
&lt;li&gt;Include PreviewImporter：勾选后，会包含由预览窗口生成的 Artifacts。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;右上方的搜索框可以搜索项目中的资源。&lt;/p&gt;
&lt;p&gt;左侧的 Asset 表示资源，Last Import 表示最后一次导入这个资源是在什么时候，Duration (ms) 表示最后一次导入这个资源时花费了多少毫秒才将它导入到项目中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选中一个资源后，可以在右侧看到它的信息。&lt;/li&gt;
&lt;li&gt;点击 Asset，Project 窗口会在项目中定位到该资源存放的位置。&lt;/li&gt;
&lt;li&gt;GUID 表示 Unity 分配给这个资源的全局唯一标识。&lt;/li&gt;
&lt;li&gt;Asset Size 表示这个资源的文件大小。&lt;/li&gt;
&lt;li&gt;Path 表示这个资源在项目中的路径。&lt;/li&gt;
&lt;li&gt;Editor 表示是 Unity 的哪个版本创建这个资源的 Artifact 的。&lt;/li&gt;
&lt;li&gt;Timestamp 表示这个资源的 Artifact 被创建时的时间，它对应 Library 文件夹中指定文件的 Timestamp 的值。&lt;/li&gt;
&lt;li&gt;Duration 表示导入这个资源所花费的时间。&lt;/li&gt;
&lt;li&gt;Reason for import 表示导入原因，即这个资源最近重新导入的描述，以及这个资源相关依赖类型的详细信息。当导入原因有多个是，可以用搜索栏进行查找。&lt;/li&gt;
&lt;li&gt;Produced Files/Artifacts 表示这个资源最后一次导入 Unity 时，在 Library 文件夹中呈现的 Artifact 的路径。通常每个资产只有一个 Artifact，有时也可能有多个。&lt;/li&gt;
&lt;li&gt;Dependencies 表示这个资源依赖的其它资源，如果修改它们，可能会导致这个资源被重新导入到 Unity。如果 Dependencies 的数量过多，可以使用搜索栏查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;unity-code-coverage-窗口&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unity-code-coverage-窗口&#34;&gt;#&lt;/a&gt; Unity Code Coverage 窗口&lt;/h2&gt;
&lt;p&gt;&lt;mark&gt;Code Coverage 用来评估我们编写的代码，在游戏测试运行的时候有多少被执行了&lt;/mark&gt;。如果有一部分代码没有被执行，我们就要考虑是不是我们代码的逻辑有问题，从而改进我们的代码。&lt;/p&gt;
&lt;p&gt;打开方法：Window——Analysic——Code Coverage&lt;/p&gt;
&lt;p&gt;官方文档：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL1BhY2thZ2VzL2NvbS51bml0eS50ZXN0dG9vbHMuY29kZWNvdmVyYWdlQDEuMS9tYW51YWwvaW5kZXguaHRtbA==&#34;&gt;https://docs.unity.cn/Packages/com.unity.testtools.codecoverage@1.1/manual/index.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用思路：&lt;/p&gt;
&lt;p&gt;先勾选 Enable Code Coverage，然后勾选 Auto Generate Report，再点击 Start Recording 按钮，接着点击播放按钮运行游戏。点击 Start Recording 按钮后，它会变成 Stop Recording，测试完毕后点击它，就会停止测试。然后我们就可以在 Result Location 的路径找到生成的报告，从中看出在测试的时候有多少代码被执行了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Results Location 表示生成的报告要存放到的路径。&lt;/li&gt;
&lt;li&gt;History Location 表示生成的报告的历史记录要存放到的路径。必须勾选了 Generate History 才会生成。&lt;/li&gt;
&lt;li&gt;Enable Code Coverage 表示启用代码覆盖，测试之前要勾选它。&lt;/li&gt;
&lt;li&gt;Included Assemblies 表示测试的时候要考虑哪些程序集的代码。&lt;/li&gt;
&lt;li&gt;Included Paths 表示测试的时候要考虑哪些文件夹或文件中的代码。&lt;/li&gt;
&lt;li&gt;Excluded Paths 表示测试的时候不考虑哪些文件夹或文件中的代码。&lt;/li&gt;
&lt;li&gt;Generate HTML Report，勾选后，生成报告时，会以 html 的格式来生成报告。如果取消勾选，则会以其它形式来生成报告，但是这样不方便我们观看。建议勾选。&lt;/li&gt;
&lt;li&gt;Generate Summary Badges，勾选后，生成的报告的文件夹中，会额外生成.svg 和.png 后缀的文件，概括这次测试中有百分之几的代码被使用了。&lt;/li&gt;
&lt;li&gt;Generate History，勾选后，生成报告时，会自动在 History Location 的路径生成历史记录。&lt;/li&gt;
&lt;li&gt;Generate Additional Metrics，勾选后，生成报告时，报告中会有额外的衡量指标。&lt;/li&gt;
&lt;li&gt;Auto Generate Report，勾选后，我们点击 Start Recording 开始测试，然后点击 Stop Recording 结束测试后，会自动在 Results Location 的路径生成报告。&lt;/li&gt;
&lt;li&gt;Clear Data 清空上一次测试的数据。&lt;/li&gt;
&lt;li&gt;Clear History，清空 History Location 路径中的所有历史记录。&lt;/li&gt;
&lt;li&gt;Generate from Last，根据上一次测试的数据，在 Results Location 的路径生成报告。&lt;/li&gt;
&lt;li&gt;Start Recording，开始测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;unity-profile-analyzer-窗口&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unity-profile-analyzer-窗口&#34;&gt;#&lt;/a&gt; Unity Profile Analyzer 窗口&lt;/h2&gt;
&lt;p&gt;Profile Analyzer 配合 Profiler 使用。当我们使用 Profiler 收集了数据之后，不要关闭 Profiler，并且打开 Profile Analyzer，把 Profiler 收集的数据导入到 Profile Analyzer，&lt;mark&gt;使用 Profile Analyzer 可以帮助我们选出一段数据中最具有代表性的一帧，方便我们进行性能分析。也能看出收集的数据整体的一些情况，例如中位数、平均值、最大值、最小值等&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;Profile Analyzer 也可以比较两段数据的性能开销。&lt;/p&gt;
&lt;p&gt;打开方法：Window——Analysis——Profile Analyzer&lt;/p&gt;
&lt;p&gt;官方文档：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5wZXJmb3JtYW5jZS5wcm9maWxlLWFuYWx5emVyQDEuMi9tYW51YWwvaW5kZXguaHRtbA==&#34;&gt;https://docs.unity3d.com/Packages/com.unity.performance.profile-analyzer@1.2/manual/index.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Profile Analyzer 要配合 Profiler 使用，点击 Open Profiler Window 可以打开 Profiler，此时 Open Profiler Window 会变成 Close Profiler Window，点击 Close Profiler Window 会关闭打开的 Profiler&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;左上方的 Mode 有两种模式，选择 Single 会分析一段数据，选择 Compare 会分析两段数据，可以对这两段数据作对比。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;左上方的 Export 可以把分析的结果导出到本地，以便我们查看。&lt;/p&gt;
&lt;p&gt;在 Profiler 收集了一段数据之后，可以点击 Profile Analyzer 中的 Pull Data，这样就会导入那段数据到 Profile Analyzer，方便我们分析。点击 Save，则会把数据保存到本地，点击 Load，则可以从本地载入数据。&lt;/p&gt;
&lt;p&gt;在上方的图表中，我们可以拖选其中的一段数据，然后在下方的 Top 10 markers on median frame 下看到最具有代表性的一帧，&lt;mark&gt;点击它，则 profiler 窗口中也会自动选中那一帧&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;Top 10 markers on median frame 下方右侧是 10 个最具有代表性的 Marker。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;Marker 表示代码的标记&lt;/mark&gt;。Unity 执行的一些关键的方法或者一段关键的代码会被标记，方便我们查看这些方法和代码的性能。&lt;/p&gt;
&lt;p&gt;此时在下方的 Marker Details for current selected range 下方可以看到选中的这段数据的信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Filters 的选项用于对数据进行筛选。&lt;/li&gt;
&lt;li&gt;Name Filter 表示筛选含有指定字符串的结果。&lt;/li&gt;
&lt;li&gt;Exclude Names 表示筛选不含有指定字符串的结果。&lt;/li&gt;
&lt;li&gt;Thread 表示筛选指定线程的结果&lt;/li&gt;
&lt;li&gt;Depth Slice 表示筛选指定调用栈的深度。&lt;/li&gt;
&lt;li&gt;点击 Analyze，则会根据 Filters 的选项的设置重新进行分析，可以在下方的 Marker Details for currently selected range 的下方看到结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;unity-imgui-debugger-窗口&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unity-imgui-debugger-窗口&#34;&gt;#&lt;/a&gt; Unity IMGUI Debugger 窗口&lt;/h2&gt;
&lt;p&gt;&lt;mark&gt;IMGUI Debugger 窗口用于查看 Unity 编辑器中的 IMGUI 控件的信息&lt;/mark&gt;。例如 Scene 窗口、Game 窗口实际上也是用 IMGUI 写的，我们可以查看其中 IMGUI 控件的信息。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;如果我们在 OnGUI 方法中写了代码来显示 IMGUI 控件，也可以在 IMGUI Debugger 窗口查看这个 IMGUI 控件的信息。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;打开方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Window——Analysis——IMGUI Debugger&lt;/li&gt;
&lt;li&gt;Alt+5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 &amp;lt;Please Select&amp;gt; 和它右边的下拉菜单中，可以选择要查看哪些 IMGUI 控件。&lt;/p&gt;
&lt;p&gt;Show Overlay。启用 Show Overlay，则选择 IMGUI 控件时，能在 Unity 的编辑器中看到选择了哪个控件。&lt;/p&gt;
&lt;p&gt;Force Inspect Optimized GUI Blocks。有时候 Unity 可能会对 IMGUI 进行优化，把多个 IMGUI 控件合并为一个。此时如果我们要查看每一个 IMGUI 控件的信息，则可以启用 Force Inspect Optimized GUI Blocks&lt;/p&gt;
&lt;p&gt;Pick Style。按住 Pick Style，然后在 Unity 的编辑器中选择一个 IMGUI 控件，可以看到它的信息。&lt;/p&gt;
</content>
        <category term="Unity3D" scheme="https://blog.aayu.today/categories/unity/" />
        <category term="Unity3D" scheme="https://blog.aayu.today/tags/Unity3D/" />
        <updated>2023-10-05T15:49:32.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.aayu.today/feature/unity/20231004/</id>
        <title>Unity3D优化笔记（3）性能分析器Profiler</title>
        <link rel="alternate" href="https://blog.aayu.today/feature/unity/20231004/"/>
        <content type="html">&lt;p&gt;Profiler 窗口就是性能分析器的窗口，用来详细分析游戏性能。&lt;/p&gt;
&lt;p&gt;打开 Profiler 窗口的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Window——Analysis——Profiler&lt;/li&gt;
&lt;li&gt;Ctrl+7&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用性能分析器进行分析时，其自身也是会消耗性能的。如果想获得更加准确的数据，可以使用独立性能分析器，即 Profiler (Standalone Process)。&lt;/p&gt;
&lt;p&gt;打开 Profiler (Standalone Process) 窗口的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Window——Analysis——Profiler(Standalone Process)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;独立性能分析器的运行不会影响收集的数据，因此可以获得更加准确的数据。它的用法和 Profiler 窗口相同，但是启动它的时间比打开 Profiler 窗口的时间长。&lt;/p&gt;
&lt;h2 id=&#34;基本使用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基本使用&#34;&gt;#&lt;/a&gt; 基本使用&lt;/h2&gt;
&lt;p&gt;打开 Profiler 窗口后，运行 Unity，再点击 Profiler 窗口上方的圆形按钮，就会开始收集当前开始的每一帧的性能，再点一下那个圆形按钮，则会停止收集，此时就可以双击右上部分的一个位置选中一帧，然后看这一帧的情况，一般我们可以选择波峰的一帧，这样容易看出性能开销大的原因。也可以推动时间轴，或者点击上方圆形按钮右侧的三个按钮，查看其它帧的情况。上方的 Frame 表示当前正在查看的帧数以及收集的总帧数，例如 Frame:738/963 表示一共收集了 963 帧，当前查看的是第 738 帧。&lt;/p&gt;
&lt;p&gt;每一项左侧的颜色方块表示该项是显示的，如果&lt;mark&gt;点击颜色方块，则右侧会隐藏该项的数据&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;如果不要显示某个模块的数据，可以点击左上角的 “Profiler Modules”，取消勾选它，这样在性能分析器收集数据的时候，也不会收集这些数据，可以减少性能分析器的开销。如果要重新显示某个模块的数据，则勾选它即可。点击 Restore Defaults 会恢复默认的设置。&lt;/p&gt;
&lt;p&gt;如果要清除当前收集的所有帧的数据，则可以点击上方的 “Clear”。再次点击 Profiler 窗口上方的圆形按钮，就会开始收集当前开始的每一帧的性能，再点一下那个圆形按钮，则会停止收集，此时就可以双击右上部分的一个位置选中一帧，然后看这一帧的情况。&lt;/p&gt;
&lt;p&gt;选中一帧后，除了可以在右侧看到这一帧的情况，还可以在下方看到这一帧更加具体的情况。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;要找出造成性能开销的因素，可以尝试禁用场景中的游戏对象。如果禁用后，看到性能提升了，则说明问题出在这个游戏对象身上，优化的时候就可以从它身上下手。&lt;/mark&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点击圆形按钮左侧的下拉菜单，可以选择分析什么的性能。如果选择 Play Mode，则会分析游戏在运行时的性能，如果选择 Edit Mode，则会分析编辑器模式下游戏的性能。&lt;/li&gt;
&lt;li&gt;如果用手机的数据线成功连接到电脑，&lt;mark&gt;在手机上运行 Unity 的游戏，Play Mode 这里会多出该手机设备供我们选择，我们就可以分析该手机设备上运行的 Unity 项目的性能&lt;/mark&gt;。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;也可以让手机和电脑都连接同一个 wifi&lt;/mark&gt;，这样一来，这里也会多出该手机设备供我们选择，我们就可以分析该手机设备上运行的 Unity 项目的性能。&lt;/li&gt;
&lt;li&gt;注意，无论是用 wifi 还是数据线，&lt;mark&gt;构建项目时必须在 Build Settings 窗口中勾选 Development Build 和 Autoconnect Profiler&lt;/mark&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选择上方的 Clear on Play，则在每次重新运行游戏的时候，都会清空收集的数据，以便我们重新开始收集这一次的数据。&lt;/p&gt;
&lt;p&gt;如果要保存收集到的数据到本地，方便之后查看，&lt;mark&gt;可以点击右上方的图标来保存。右上方也有一个图标可以读取之前保存的数据&lt;/mark&gt;。&lt;/p&gt;
&lt;h2 id=&#34;添加自定义模块&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#添加自定义模块&#34;&gt;#&lt;/a&gt; 添加自定义模块&lt;/h2&gt;
&lt;p&gt;点击小齿轮，再点击 Add，可以自定义一个新的模块，并自定义这个模块要分析的性能，且可以在上方的输入框处改名，然后点击 Save Changes 可以保存。如果要删除它，则点击 Delete Module 即可删除它，同样，点击 Save Changes 可以保存。&lt;/p&gt;
&lt;p&gt;​&lt;img data-src=&#34;assets/image-20231003185643-whabbez.png&#34; alt=&#34;image&#34; /&gt;​&lt;/p&gt;
&lt;h2 id=&#34;deep-profile&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#deep-profile&#34;&gt;#&lt;/a&gt; Deep Profile&lt;/h2&gt;
&lt;p&gt;选择上方的 Deep Profile，然后重新启动性能分析器，则性能分析器收集数据的时候，&lt;mark&gt;会把所有 C# 代码中的方法的信息也收集过来&lt;/mark&gt;。例如我们自己写的 C# 脚本，里面的方法只要被调用了，就会被收集过来，方便我们从性能分析器查看它们的性能。&lt;mark&gt;在 Profiler 窗口选择 CPU Usage 模块，选中一帧，然后在下面选择 Hierarchy，右侧选择 Main Thread，再在右侧的搜索栏处搜索该方法的名字，就可以找到它，并查看它的性能。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;​&lt;img data-src=&#34;assets/image-20231003203610-ho2ie4o.png&#34; alt=&#34;image&#34; /&gt;​&lt;/p&gt;
&lt;p&gt;当开启深度分析后，性能分析器就会捕捉每个函数所占用的资源，包括本身执行的时间和函数内部再调用其他函数消耗的时间等等&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;However，如果在一个大项目里开启深度分析，由于需要监测每个函数占用的资源，所以可能会造成性能分析器卡顿，甚至崩溃。Therefore，不建议在大型形目里开启 Deep Profile&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;更优的做法是使用  &lt;code&gt;Profiler.BeginSample&lt;/code&gt; ​ 和  &lt;code&gt;Profiler.EndSample&lt;/code&gt; ​ 方法括住需要性能分析的代码进行分析即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;void TestHaha()
&amp;#123;
	Profiler.BeginSample(&amp;quot;MyHaha&amp;quot;);

	// Your code

	Profiler.EndSample();
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;调用栈call-stack&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#调用栈call-stack&#34;&gt;#&lt;/a&gt; 调用栈（Call Stack）&lt;/h2&gt;
&lt;p&gt;调用栈（Call Stack）是计算机程序在执行过程中记录函数调用的一种数据结构。&lt;/p&gt;
&lt;p&gt;调用栈是一个栈结构，即先进后出。它用于记录程序执行过程中，每个函数被调用的情况。&lt;/p&gt;
&lt;p&gt;当一个函数被调用时，它的相关信息，如函数名、参数、返回地址等，会被添加进调用栈中。当该函数执行完成后，相应的信息会从调用栈中移除。通过不断添加和移除函数调用的信息，调用栈就记录了程序执行的顺序。&lt;/p&gt;
&lt;p&gt;调用栈对于程序调试和分析非常有用。当程序出现错误或异常时，可以通过查看调用栈来确定错误发生的位置和函数调用的顺序。调试器通常会显示当前调用栈的信息，以帮助开发人员查看函数的执行过程并找出发生异常的原因。&lt;/p&gt;
&lt;p&gt;选中 Deep Profile 右侧的 Call Stacks 按钮，这样在收集性能数据的时候，每一帧都会记录该方法的的调用栈信息。GC.Alloc、UnsafeUtility.Malloc、JobHandle.Complete 是 Unity 的方法，启用 Call Stacks 且勾选它们后，如果 Unity 有调用它们，则可以在 Hierarchy 或 Raw Hierarchy 右侧的搜索框中搜索到它们，这样就可以查看它们的性能了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GC.Alloc 表示 GC 的内存分配情况。&lt;/li&gt;
&lt;li&gt;UnsafeUtility.Malloc (Persistent) 用于在内存中分配指定大小的未初始化内存块。这个方法会直接在堆上分配内存，并可以绕过自动内存管理功能，需要手动管理内存的生命周期和释放。一般情况下，只有在处理非托管内存的特定场景下才会使用 UnsafeUtility.Malloc 方法。&lt;/li&gt;
&lt;li&gt;JobHandle.Complete 表示 Job 的完成情况。这里的 Job 是指 Unity 的 Job System 的一组特定的任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c-托管内存-非托管内存-托管堆&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#c-托管内存-非托管内存-托管堆&#34;&gt;#&lt;/a&gt; C# 托管内存、非托管内存、托管堆&lt;/h2&gt;
&lt;p&gt;&lt;mark&gt;托管内存是由垃圾回收器自动管理的内存&lt;/mark&gt;，当达到一定量时，会由垃圾回收器自动释放它们。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;托管内存存放在托管堆中。托管堆是一种用于存储和管理托管对象的内存区域&lt;/mark&gt;。每当创建一个新的托管对象时，托管堆就会分配内存空间给这个对象，并记录这个对象的信息。当托管对象不再被引用，垃圾回收器会自动将其标记为垃圾，并在适当的时候回收其占用的内存空间。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;非托管内存不会自动被回收，它们需要我们程序员写代码去管理和释放它们。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;非托管内存并不固定存储在一个地方，它们往往分散存储在不同的地方，例如操作系统的内存、临时缓冲区等。&lt;/p&gt;
&lt;h2 id=&#34;unity-dtos&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#unity-dtos&#34;&gt;#&lt;/a&gt; Unity DTOS&lt;/h2&gt;
&lt;p&gt;DOTS（Data-Oriented Technology Stack）是 Unity 引擎中的一个新的编程模型和工具集。它旨在提供更高性能、更可扩展和更并行化的游戏开发体验。&lt;/p&gt;
&lt;p&gt;DOTS 中包含了三个主要部分：&lt;/p&gt;
&lt;p&gt;1、ECS 框架：ECS 是一种用于组织和管理游戏对象的方式。它将游戏对象分解为实体（Entity）、组件（Component）和系统（System）。这种模式更加适合于并行处理和优化，可以提高游戏性能。&lt;/p&gt;
&lt;p&gt;2、Job System（作业系统）：Job System 允许开发者将任务并行化，利用多核处理器的能力。它通过将任务划分为小的作业（jobs）并在多个线程上并发执行来提高性能。Job System 还可以与 ECS 结合使用，使得开发者可以更好地控制游戏的行为。&lt;/p&gt;
&lt;p&gt;3、Burst Compiler（突发编译器）：Burst Compiler 是一种高性能的 C# 编译器，可以将 C# 代码转换为高效的本机代码，以进一步提高游戏的性能。&lt;/p&gt;
&lt;p&gt;DOTS 的目标是为游戏开发者提供更好的性能和可扩展性，并更好地利用现代硬件的并行能力。它适用于需要处理大量实体和需要高性能的游戏项目。&lt;/p&gt;
&lt;h2 id=&#34;其他&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#其他&#34;&gt;#&lt;/a&gt; 其他&lt;/h2&gt;
&lt;p&gt;点击右上角的三点，有一些选项可以选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Color Blind Mode 表示色盲模式，开启后会调整 Profile 窗口的颜色，照顾色盲用户。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Show Stats for &#39;current frame&#39; 开启后，当点击 Frame:XXX/XXX 左侧的按钮，从而选中最后一帧，则会显示最后一帧的统计信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Preferences，点击后会打开 Project Settings 窗口，用于设置性能分析器的一些属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Frame Count，开始收集性能的数据时，每次最多可以查看多少帧。例如数值是 300，则表示最多可以查看 300 帧。&lt;/li&gt;
&lt;li&gt;Show Stats for &#39;current frame&#39;，勾选后，则在右上角的三点会出现 Show Stats for &#39;current frame&#39; 供我们选择。&lt;/li&gt;
&lt;li&gt;Default recording state，选择 Enable，则重启 Unity 再打开 Profiler 窗口，如果此时的模式是 Edit Mode，则会自动开始点击圆形按钮，开始收集数据。选择 Disabled，则重启 Unity 再打开 Profiler 窗口，需要手动点击圆形按钮，才会开始收集数据。选择 Remember，则会按照当前圆形按钮是启用还是禁用来决定下一次重启 Unity 再打开 Profiler 窗口时，该圆形按钮是否启用。&lt;/li&gt;
&lt;li&gt;Default editor target mode on start，选择 Play Mode，则重启 Unity 再打开 Profiler 窗口，左上方会选择 Play Mode，即在播放模式下才会收集数据。如果选择 Edit Mode，则重启 Unity 再打开 Profiler 窗口，左上方会选择 Edit Mode，即在编辑器模式下收集数据。&lt;/li&gt;
&lt;li&gt;Custom connection ID，当有多个 Unity 项目的实例同时运行，它们都要使用性能分析器来分析性能，则可以通过这个 Custom connection ID 来区分它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU Usage 模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下方窗口可以选择 Timeline、Hierarchy、Raw Hierarchy。&lt;/li&gt;
&lt;li&gt;选择 Timeline，可以通过时间轴的方式查看这一帧中 CPU 依次干了什么。&lt;/li&gt;
&lt;li&gt;选择 Hierarchy，可以查看 CPU 在这一帧中做的事情所消耗的性能和所花费的时间。Total 表示一共占用了 CPU 使用情况的百分之几。Self 表示自身的代码占用了 CPU 使用情况的百分之几，调用其它方法的代码不算在内的。Calls 表示被调用了几次。GC Alloc 表示 GC 分配的内存，当一个对象被释放后，它 GC 分配的内存不会马上被回收，所有 GC 分配的内存的总量达到一定程度，会触发 GC，此时垃圾回收器才会把这些内存回收，不过同时也会造成游戏卡一下。Time ms 表示一共耗时多少毫秒。Self ms 表示表示自身的代码耗时多少毫秒，调用其它方法的代码不算在内的。&lt;/li&gt;
&lt;li&gt;选择 Raw Hierarchy 比起 Hierarchy 会单独列出更多信息，Hierarchy 实际上是把这些信息合并了。&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="Unity3D" scheme="https://blog.aayu.today/categories/unity/" />
        <category term="Unity3D" scheme="https://blog.aayu.today/tags/Unity3D/" />
        <updated>2023-10-04T15:08:07.000Z</updated>
    </entry>
</feed>
