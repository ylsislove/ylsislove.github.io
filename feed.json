{
    "version": "https://jsonfeed.org/version/1",
    "title": "学无止境",
    "subtitle": "世界上大部分事，都没太大意义。真理与热爱除外",
    "icon": "https://blog.aayu.today/images/favicon.ico",
    "description": "真理和热爱是吾永生的追求",
    "home_page_url": "https://blog.aayu.today",
    "items": [
        {
            "id": "https://blog.aayu.today/feature/rokid/20231125/",
            "url": "https://blog.aayu.today/feature/rokid/20231125/",
            "title": "Rokid 新项目构建过程中，可能遇到的问题及解决方案",
            "date_published": "2023-11-25T11:31:42.000Z",
            "content_html": "<p>按照开发者文档构建新项目时，可能会碰到如下报错</p>\n<p>从报错信息中可以看到一条关键信息  <code>Could not resolve com.rokid.uxrplugin:rkuxrplugin:2.3.10</code></p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/11/25/202311251932196.png\" alt=\"\" /></p>\n<p>在自己浏览器输入下面的网址，发现也能正常打开链接，那自己的网络应该就是没问题的，那为什么会报错呢</p>\n<p>原因可能有两个，一个是自己的 Maven 文件没有配置正确，另一个可能就是自己电脑上全局的 gradle.properties 配置文件曾经配置过代理，从而导致 Rokid Maven 仓库访问异常～</p>\n<p>关于第一个原因，正确的 Maven 如何配置，可以看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdXN0b20ucm9raWQuY29tL3Byb2Qvcm9raWRfd2ViL2M4OGJlNGJjZGU0YzQyYzBiOGI1MzQwOWUxZmExNzAxL3BjL2NuLzExZjg2Nzk4ZGM2YzQ3NTE4ZTMzMGRmNDliMWI1ZTY1Lmh0bWw/ZG9jdW1lbnRJZD1jZGVmNGIyYmVhODU0MmRlYWRiZTk5YWNhNDkyMWI1NyMzLSVFNSU4RiU5MSVFNSVCOCU4MyVFOSU4NSU4RCVFNyVCRCVBRQ==\">官方文档 2.3.10 版本</span></p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/11/25/202311251932770.png\" alt=\"\" /></p>\n<p>这里就有针对不同  Unity 版本的配置文件，直接下载下来，导入到自己的 Unity 项目即可～</p>\n<p>至于第二个原因，就是我误打误撞找到了解决办法哈哈，原先我曾经用 Android Studio 开发过 Android 项目，之前开发时为了解决网络环境，就配置了代理，代理设置就被配置在了全局的 gradle.properties 文件中</p>\n<p>对于 Windows，这个文件在  <code>C:\\Users\\用户名\\.gradle</code>  目录下，对于 Mac 用户的话，这个文件应该在  <code>~/.gradle/gradle.properties</code>  这里</p>\n<p>配置过代理后的 gradle.properties 应该会有这四行配置</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/11/25/202311251933514.png\" alt=\"\" /></p>\n<p>而恰巧不巧的是，这里代理用的 socks 版本和我电脑上 v2rayN 代理软件 的 socks 版本不匹配，所以在 unity 或 android studio 里构建安卓项目是就会构建不成功</p>\n<p>解决办法也很简单，就把第 15、16 行 https 配置注释掉就好，只用 http 代理</p>\n<p>修改完后，再次在 unity 里构建项目，构建成功，问题完美解决～</p>\n<h2 id=\"参考链接\"><a class=\"anchor\" href=\"#参考链接\">#</a> 参考链接</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6bTE0NzU1OTg4OTEvYXJ0aWNsZS9kZXRhaWxzLzg4NTMwMDAy\">解决 Android Studio 之 Cause: dl.google.com:443 failed to respond</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC84NTI5ZGM4MmY4MTI=\">解决：Android Studio 之 Cause: dl.google.com:443 failed to respond</span></li>\n</ul>\n",
            "tags": [
                "Unity3D",
                "Rokid",
                "Unity3D",
                "Rokid"
            ]
        },
        {
            "id": "https://blog.aayu.today/leisure/forever/20231123/",
            "url": "https://blog.aayu.today/leisure/forever/20231123/",
            "title": "AR 应用创意分享：The Seed",
            "date_published": "2023-11-23T13:33:01.000Z",
            "content_html": "<div class=\"note info\">\n<p>此帖正在参与 Rokid 活动，如果觉得不错的话，欢迎点赞支持～<br />\n 帖子链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mb3J1bS5yb2tpZC5jb20vcG9zdC9kZXRhaWwvOTE2\">https://forum.rokid.com/post/detail/916</span></p>\n<p>可以转载，但请注明出处，谢谢～</p>\n</div>\n<p>前两天分享过两个 idea 了，分别是</p>\n<ul>\n<li>The Assistant（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mb3J1bS5yb2tpZC5jb20vcG9zdC9kZXRhaWwvODQzJUVGJUJDJTg5\">https://forum.rokid.com/post/detail/843）</span></li>\n<li>魔刀千刃（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mb3J1bS5yb2tpZC5jb20vcG9zdC9kZXRhaWwvODg4JUVGJUJDJTg5\">https://forum.rokid.com/post/detail/888）</span></li>\n</ul>\n<p>今天发现有小坏蛋原封不动的 copy 了我的魔刀千刃 idea，如果喜欢我的创意，欢迎转载，但请不要直接 copy</p>\n<p>更何况 copy 都没把图片 copy 过去，有小伙伴看到的话不就看的莫名其妙嘛，这就更不能忍了 (* ￣︿￣)</p>\n<p>目前该帖子已经有 60 的浏览量了，希望 rokid 小助手最后评选时可以将该浏览量合并到原创帖子头上</p>\n<p>尊重原创，保护每一个来之不易的 idea ~</p>\n<p>~~</p>\n<p>吐槽结束，这次的想法实际上也在我脑子里琢磨了很久了，实际上，在我 7、8 年前第一次看《刀剑神域》小说的时候，我就一直梦想着 AR 世界的未来～</p>\n<p>应用名称：The Seed<br />\n 目标人群：喜欢《刀剑神域》的开发者～<br />\n 应用场景：</p>\n<p>如果有小伙伴也看过《刀剑神域》，不知道是不是也和我一样，被里面可以完全潜行的 VRMMO（虚拟现实大型多人在线）游戏所吸引呢</p>\n<p>只要戴上头盔，我们的大脑就可以畅游在计算机生成的虚拟世界里，直接用意识操控自己角色奔跑，跳跃，使用帅气的剑技，打怪升级等等，每次想到这个场景我都会很激动哈哈</p>\n<p>当然了，以目前的科技水平来说，想要实现小说里的场景，还有很长很长的路要走，人脑方面的研究也还有很多工作要做，希望此生可以活得长久一点，在有生之年可以见证这个场景的到来 😉</p>\n<p>The Seed 是小说里 VRMMO 系列游戏的种子，基于该种子所制作的一系列 VRMMO 游戏都有可能相互连接，用同一名角色就能在无数的 VRMMO 间漫游，以下内容取自百度百科</p>\n<blockquote>\n<p>The Seed 是能制作、管理小型 VRMMO 的免费软件。茅场晶彦托付给桐人的 “世界的种子”。从运作 VRMMO 必需的 Cardinal 到游戏的制作工具都包在里面，只要准备好 3D 物件和服务器就能建立出 VRMMO 环境。用 The Seed 开发出的 VRMMO 间，是能相连的，因为其潜藏着 “不同游戏间的角色可以相互转换”（能转换的只有角色本身，金钱、道具等都会被清空）的最高法则，因此，用同一名角色就能在无数的 VRMMO 间漫游。</p>\n</blockquote>\n<p>虽然人脑的研究还有很长的一段路要走，但刀剑神域里炫酷的游戏操作界面，我还是很希望能实现的呢，比如下图</p>\n<p><img data-src=\"assets/test-20231123204518-nywwbu1.gif\" alt=\"test\" /></p>\n<p>真的很炫酷啊！！！手势往下一滑，菜单就直接出现在眼前，动作是多么的顺其自然</p>\n<p>所以，后面等有时间了，我应该会好好捣鼓一下 Rokid 的手势识别功能。从我想实现的 The Seed 的这个应用名称来看，我所希望的，就是能设计出一套自己心目中理想的 AR 应用架构，在这个架构里，我会提供类似刀剑神域一样的手势识别功能和界面～</p>\n<p>The Seed 就像一个种子，希望有和我一样是刀剑迷的开发者都能基于 The Seed 开发出自己心目中的 AR 应用或游戏～</p>\n<p>此生无悔入刀剑，来世愿入 SAO！</p>\n",
            "tags": [
                "清风明月",
                "永恒",
                "AR"
            ]
        },
        {
            "id": "https://blog.aayu.today/leisure/forever/20231122/",
            "url": "https://blog.aayu.today/leisure/forever/20231122/",
            "title": "AR 应用创意分享：魔刀千刃！",
            "date_published": "2023-11-22T13:24:36.000Z",
            "content_html": "<div class=\"note info\">\n<p>此帖正在参与 Rokid 活动，如果觉得不错的话，欢迎点赞支持～<br />\n 帖子链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mb3J1bS5yb2tpZC5jb20vcG9zdC9kZXRhaWwvODg4\">https://forum.rokid.com/post/detail/888</span></p>\n<p>可以转载，但请注明出处，谢谢～</p>\n</div>\n<p>嘿嘿，昨天写了一个 idea（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mb3J1bS5yb2tpZC5jb20vcG9zdC9kZXRhaWwvODQz\">The Assistant</span>），是关于我畅想的未来 AR 眼镜在办公方面的应用～</p>\n<p>今天就再分享一个小 idea 吧，其实在我的脑海里也徘徊很久了哈哈，正好趁 Rokid 活动的机会分享出来～</p>\n<p>应用名称：魔刀千刃<br />\n目标人群：游戏用户，动漫迷<br />\n应用场景：</p>\n<p>从名称上就可以看出，这个 idea 来源于国漫刺客伍六七。之前看动漫的时候，我就被主角使用的武器所吸引，世人对魔刀千刃的评价是 “只攻不防，天下无双”，帅的一批</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/11/22/202311222053957.png\" alt=\"\" /></p>\n<p>那时候我就在想，像魔刀千刃这种帅气的武器只可能在游戏或动漫里出现了，真的没办法在现实生活中拥有吗？</p>\n<p>魔刀千刃的刀刃是由上千块碎片组成，可以变换成不同的形状，用不同的方式攻击敌人。而想要实现这样的效果的话，实际上在 Unity3D 里可以通过对模型做各种变换来实现，那么，万事俱备，只欠一副可以将模型在现实世界可视化出来的东西了，那就是 Rokid AR 眼镜了～</p>\n<p>有小伙伴可能会问，现在市面上 AR 眼镜也不少呀，为什么选择 Rokid 的呢</p>\n<p>实际上，如果想要实现我想要的效果的话，AR 眼镜上的手势识别功能就必不可少了，因为我需要跟踪手部来渲染魔刀千刃的挥舞动作，所以就要筛选出能进行手势识别的 AR 眼镜，比如微软的 HoloLens2，XREAL Light 和 Rokid Max Pro 等，刚列的这三个设备我都体验过～HoloLens2 的功能很强大，但可惜设备太重了，佩戴舒适度很差，戴十几分钟就不想戴了；XREAL Light 的外观要酷一点，但可惜手势追踪的延迟很高，并且眼镜的重量也有 100 多克，压鼻子的感觉很明显，也无法长时间佩戴～</p>\n<p>Rokid Max Pro 实际体验的时候，说实话，真的让我有点惊讶了。首先，戴上的第一感觉就是压鼻子的感觉很轻，也不滑，佩戴舒适度的感觉很好！这也是我最看重的点。在我看来，一副 AR 眼镜，佩戴舒适度是最重要的，其次才是功能啊，价格啊什么的。功能再强，但佩戴不舒服的设备，注定是要吃灰的～</p>\n<p>啊哈有点跑题了，哈哈回到正题，所以当我体验到 Rokid AR 眼镜的时候，我觉得或许我脑海里徘徊已久的这个 idea 有机会可以实现了，嘿嘿</p>\n",
            "tags": [
                "清风明月",
                "永恒",
                "AR"
            ]
        },
        {
            "id": "https://blog.aayu.today/leisure/forever/20231121/",
            "url": "https://blog.aayu.today/leisure/forever/20231121/",
            "title": "AR 应用创意分享：The Assistant",
            "date_published": "2023-11-21T13:24:36.000Z",
            "content_html": "<div class=\"note info\">\n<p>此帖正在参与 Rokid 活动，如果觉得不错的话，欢迎点赞支持～<br />\n 帖子链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mb3J1bS5yb2tpZC5jb20vcG9zdC9kZXRhaWwvODQz\">https://forum.rokid.com/post/detail/843</span></p>\n<p>可以转载，但请注明出处，谢谢～</p>\n</div>\n<p>应用名称：The Assistant<br />\n 目标人群：办公人群<br />\n应用场景：</p>\n<p>功能一：多屏协同办公小助手<br />\n当我外出时，比如在高铁上或飞机上，不需要再携带笔记本电脑或 ipad，只需要带一个 Rokid AR 眼镜，搭配用户自己的手机，或 Rokid Station，就可以随时随地拥有多个虚拟屏幕进行办公～</p>\n<p>有小伙伴可能会问，虽然不用带笔记本电脑啦，但要办公还是需要鼠标和键盘呀，所以实际上还是不方便嘛。哈哈这个问题我也想过了，一个不错的消息是目前学术界也有一些针对 AR 文本输入的研究。举个栗子，去年苏黎世联邦理工学院 SIPLAB 实验室提出了一个 TapType 技术，用户可以通过佩戴手环实现虚拟文本输入，示意图如下～感兴趣的小伙伴也可以看论文细节：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaXBsYWIub3JnL3Jlc2VhcmNoI3RhcHR5cGU=\">https://siplab.org/research#taptype</span></p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/11/21/202311212302143.png\" alt=\"\" /></p>\n<p>因此，笨重繁琐的键盘我相信在未来会被更先进的文本输入技术取代，AR 眼镜都能取代显示屏了，那新技术取代键盘不也是理所当然的事情嘛哈哈</p>\n<p>更进一步的话，手势识别，眼动追踪等技术的成熟，我相信也会渐渐取代鼠标的应用～</p>\n<p>对了，据说华为 Mate60 系列手机接上 AR 眼镜后，会直接激活电脑模式，有 mate60 系列手机的小伙伴也可以试一下，哈哈</p>\n<p>功能二：实时分析小助手</p>\n<p>AR 眼镜就是自己的另一双眼睛！当走在大街上的时候，通过摄像头捕获实时音视频流，传输到后端对视频流进行实时分析，实现七龙珠里的战五渣战斗力检测仪不是指日可待吗嘿嘿～</p>\n<p>功能三：专家助手</p>\n<p>如果有体验过微软 HoloLens2 设备的话，应该会知道 HoloLens2 会提供一个远程专家协助应用，可以和另一个人进行实时音视频通话，对方可以看到自己 AR 眼镜前的场景，并通过手势等标注工具对场景进行标注，实现远程指导等</p>\n<p>这个就是很实用的应用，我自己就曾经通过 WebRTC 技术实现了将 HoloLens2 的实时音视频流传输到了 Web 端进行展示，旁观者可以通过看 Web 界面看到我眼镜端的画面，实现了旁观者视角～</p>\n<p>所以我觉得未来嘛，想要让专家对自己正在操作的东西进行指导的话，双方直接戴上 AR 眼镜，好，自己操作的东西直接展示在专家眼前了，专家可以直接通过语音，手势等方式，对场景进行标注，标注可以直接实时反映在我面前，再复杂的操作也都能 so easy 啦～</p>\n",
            "tags": [
                "清风明月",
                "永恒",
                "AR"
            ]
        },
        {
            "id": "https://blog.aayu.today/skill/miscellaneous/20231022/",
            "url": "https://blog.aayu.today/skill/miscellaneous/20231022/",
            "title": "USB接口介绍",
            "date_published": "2023-10-22T15:30:38.000Z",
            "content_html": "<h1 id=\"usb接口介绍\"><a class=\"anchor\" href=\"#usb接口介绍\">#</a> USB 接口介绍</h1>\n<blockquote>\n<p>参考视频：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW5qNDExdjdMdS8=\">四层板 PCB 设计保姆级教程（1）：3.0HUB 设计概述</span></p>\n</blockquote>\n<h2 id=\"usb-接口定义\"><a class=\"anchor\" href=\"#usb-接口定义\">#</a> USB 接口定义</h2>\n<p>USB 是通用串行总线的英文缩写，也是一种输入输出接口的技术规范，被广泛的应用于个人电脑和移动设备等通信产品。</p>\n<p>USB 接口自 1994 年推出以来，经过不断的发展，从最初的 USB1.0/1.1，USB2.0，USB3.x，最终发展到如今的 USB4，传输速率也从最开始的 1.5Mbps 提升到了最新的 40Gbps。</p>\n<p>需要注意的是，USB 不是某一个接口，每一代 USB 协议都会衍生出一系列支持该通讯速率的接口设备。</p>\n<p>下面是一些常见的 USB 接口设备。</p>\n<p>​<img data-src=\"assets/image-20231020220413-onu3xwd.png\" alt=\"image\" />​</p>\n<h2 id=\"usb-版本区分\"><a class=\"anchor\" href=\"#usb-版本区分\">#</a> USB 版本区分</h2>\n<p>目前使用最广泛的是 USB2.0 以及 USB3.x</p>\n<p>习惯将 USB3.1Gen1 叫做 USB3.0</p>\n<p>将 USB3.1Gen2 叫做 USB3.1</p>\n<p>将 USBGen2*2 叫做 USB3.2</p>\n<p>​<img data-src=\"assets/image-20231020220759-nsljzuq.png\" alt=\"image\" />​</p>\n<h2 id=\"usb-接口选型\"><a class=\"anchor\" href=\"#usb-接口选型\">#</a> USB 接口选型</h2>\n<p>​<img data-src=\"assets/image-20231020221041-ce0pt9x.png\" alt=\"image\" />​</p>\n<p>​<img data-src=\"assets/image-20231020221136-nzitdyf.png\" alt=\"image\" />​</p>\n",
            "tags": [
                "不看会后悔的实用技巧分享",
                "杂七杂八",
                "USB"
            ]
        },
        {
            "id": "https://blog.aayu.today/feature/unity/20231021/",
            "url": "https://blog.aayu.today/feature/unity/20231021/",
            "title": "Unity3D优化笔记（10）其他优化",
            "date_published": "2023-10-21T14:52:00.000Z",
            "content_html": "<h2 id=\"代码优化\"><a class=\"anchor\" href=\"#代码优化\">#</a> 代码优化</h2>\n<p>== 使用 AssetBundle 作为资源加载方案。== 而且经常一起使用的资源可以打在同一个 AssetBundle 包中。尽量避免同一个资源被打包进多个 AB 包中。</p>\n<p>压缩方式尽量使用 LZ4，少用或不要用 LZMA 的压缩方式。如果确定后续开发不会升级 Unity 版本，则可以尝试启用打包选项 BuildAssetBundleOption.DisableWriteType，这样 TypeTree 信息不会被打到 AB 包中，可以极大减小包体大小以及运行加载时的内存开销。</p>\n<p>使用 AssetBundle 或者 Addressables 加载的资源，如果不使用，要记得卸载它们，否则会造成内存泄漏。</p>\n<p>不用的资源要释放掉，不用的引用类型的变量也要赋值为 null，不要让它们一直占着内存中。</p>\n<p><mark>加载资源时尽量使用异步加载。</mark></p>\n<p><mark>频繁创建和销毁对象，可以使用对象池。</mark></p>\n<p><mark>切换场景时，旧的场景要释放掉，不用的资源也可以考虑释放掉</mark>，也可以考虑用 System.GC.Collect 来进行一次垃圾回收。</p>\n<p><mark>锁定游戏的帧率</mark>。帧率为 30，游戏会明显卡顿，但是对于手游来说，消耗手机的电量比较少。帧率为 45，游戏有一点点卡，但还凑合，消耗电量中等。帧率为 60，游戏很流畅，但消耗手机的电量会比较多。可以用 Application.targetFrameRate 来锁定帧率，也可以用 UnityEngine.Rendering 命名空间中的 OnDemandRendering.renderFrameInterval 来锁定帧率。</p>\n<p>尽量少用 foreach 语句，可以改为 for 语句。因为每次使用 foreach 语句会造成微量的内存垃圾。</p>\n<p>要判断 GameObject 型对象.tag 是不是某个标签，使用 GameObject 型对象.CompareTag 方法会更高效。</p>\n<p><mark>尽量少用 GameObject.Find 方法和 Object.FindObjectOfType 方法来查找游戏对象，可以提前把要查找的游戏对象存储在变量、列表、字典等容器中，方便查找。也可以用 GameObject.FindGameObjectWithTag 方法来查找游戏对象。</mark></p>\n<p><mark>在 UI 显示字符串的时候，如果一些内容是固定的，我们可以把它拆分开来，这样可以减少使用 + 号来拼接的次数，减少内存垃圾的产生</mark>。例如 “杀敌数：999”，其中 “杀敌数：” 是固定的，冒号后面的数字才是会变的，那么我们可以用两个 Text 组件分别记录它们，改变的时候只改变冒号后面的数字。</p>\n<p><mark>频繁对字符串赋新的值，或者频繁拼接字符串的时候，可以使用 StringBuilder 代替 string</mark></p>\n<p>如果要频繁操作某脚本，不要每次都用 GetComponent 方法来获取这些脚本。可以用一个变量存储起获得的这个脚本，之后要访问它，就直接访问这个变量即可。也可以考虑在生命周期方法 Awake 或者 Start 中声明变量来存储，之后访问这个变量即可。</p>\n<p><mark>尽量少用正则表达式。虽然正则表达式的形式看上去比较简便，但是使用它会造成一定的性能消耗，且会产生内存垃圾。</mark></p>\n<p>尽量少用 LINQ 语法，因为每次使用 LINQ 都会产生一定量的内存垃圾。</p>\n<p><mark>尽量少用 Camera.main 来访问主摄像机</mark>，因为每次访问它，实际上 Unity 都是从场景中查找它的。可以声明一个变量存储它，在生命周期方法 Awake 或 Start 中获取主摄像机的应用。</p>\n<p><mark>在 Animator、Shader 中使用 Get 方法和 Set 方法时，不传入字符串作为参数，而是传入哈希值</mark>。例如 Animator 组件可以使用 Animator.StringToHash 方法获得指定字符串的哈希值，再把它作为参数传入 Animator 组件的 Get 方法或 Set 方法中进行使用。例如 Shader，则可以用 Shader.PropertyToID 方法来获取指定属性的 ID</p>\n<p>使用非分配物理 API。例如使用 Physics.RaycastNonAlloc 方法代替 Physics.RaycastAll 方法，使用 Physics.SphereCastNonAlloc 方法代替 Physics.SphereCastAll 方法，以此类推。Physics2D 类也有类似的方法。</p>\n<p>一般情况下，整数的数学运算比浮点数的数学运算效率高，浮点数的数学运算比矢量的数学运算效率高。可以灵活运用数学的加法交换律、加法结合律、乘法交换律、乘法结合律，在保证结果不变的前提下，调整运算顺序，减少浮点数的数学运算和矢量的数学运算。</p>\n<p>使用高效的算法进行计算</p>\n<p><mark>每次执行 Debug.Log 来打印信息会消耗极少量的性能，如果要在游戏正式发布之后不执行某些 Debug.Log 的语句，但又不想把这些代码删掉，则可以使用宏来禁止在游戏正式发布之后执行 Deubg.Log 的语句</mark>。例如使用 #if 语句或者 Conditional 特性。</p>\n<p>尽量减少在生命周期方法 Update、FixedUpdate、LateUpdate 中的逻辑。其中有些不需要频繁执行的逻辑，可以使用协程或者 Invoke 方法，每隔指定的秒数执行一次或每隔指定的帧数执行一次。</p>\n<p>尽量避免频繁的装箱拆箱操作。也可以使用泛型，这样就能避免装箱拆箱。但是要注意，Lua 热更新对泛型的支持不太好。</p>\n<p><mark>如果物体身上添加了刚体组件，则尽量用刚体组件的方法来移动它，而不是用 Transform 类的方法来移动它。</mark></p>\n<p>如果物体身上添加了 CharacterController 组件，则尽量用 CharacterController 组件的方法来移动它，而不是用 Transform 类的方法来移动它。同理，如果物体身上添加了刚体组件，则应尽量用刚体组件的方法来移动它，而不是用 Transform 类的方法来移动它。</p>\n<p><mark>应尽量避免 DontDestroyOnLoad 中加载的资源过多</mark>，因为它在切换场景的时候不会被释放，声明的变量以及加载的资源会一直占用着内存。我们可以考虑把一些资源不用的资源释放掉，需要的时候再加载它。</p>\n<p>不使用组件可以删掉，这样可以节省一些内存。常见的有 AudioSource 组件、Animator 组件、Animation 组件等，如果它们不需要使用，则可以删掉。</p>\n<p>写一个类继承 AssetPostProcessor，然后定义里面特定的方法，以此来自动设置资源导入 Unity 之后的属性。</p>\n<p>尽量避免闭包。因为闭包会产生额外的内存开销。</p>\n<h2 id=\"场景优化\"><a class=\"anchor\" href=\"#场景优化\">#</a> 场景优化</h2>\n<p>对始终静止不动的游戏对象使用静态合批技术。</p>\n<p>尽量使用同一个材质，以便使用动态合批技术。</p>\n<p>使用 GPU Instancing 技术。</p>\n<p>使用遮挡剔除。</p>\n<p>进入游戏后的第一个场景要尽量简单，这样可以减少游戏的启动时间。可以先进一个简单的场景，再进行异步加载，之后再进入游戏的主要的场景。</p>\n<p>尽量避免 Hierarchy 窗口的层级结构过深。例如一个物体有很多个子物体，这些子物体又有其它子物体，这些子物体又有其它子物体，继续这样下去就会导致层级结构过深，我们应尽量减少这种情况。</p>\n<p>Edit——Project Settings——Quality，可以对不同平台中游戏的品质进行设置。</p>\n<p>如果使用了后期处理技术，例如 Post Processing 等插件，调整屏幕效果的属性，不要使用太绚丽的特效，可以优化性能。</p>\n<p>要优化 Terrain 地形，可以使用 Unity 资源商店的插件，例如 Terrain To Mesh 插件可以把地形烘焙成网格。</p>\n<p>场景要尽可能简单，尽量多使用预制体，用代码动态创建它们出来，并管理它们。</p>\n<h2 id=\"shader-优化\"><a class=\"anchor\" href=\"#shader-优化\">#</a> Shader 优化</h2>\n<p>修改 Shader 的代码，或者自定义一个 Shader</p>\n<p>修改渲染管线的源码，改成符合自己项目的渲染管线，或者自定义渲染管线。</p>\n<h2 id=\"结尾\"><a class=\"anchor\" href=\"#结尾\">#</a> 结尾</h2>\n<p>可以使用 Unity UPR 对整个项目进行性能分析，找出问题后，再手动优化它们。</p>\n<p>Unity UPR 网址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly91cHIudW5pdHkuY24vaW5zdHJ1Y3Rpb25zL2Rlc2t0b3A=\">https://upr.unity.cn/instructions/desktop</span></p>\n<p>其中 Unity UPR 中的 Asset Checker 能对本地的整个 Unity 项目进行性能分析，帮助我们找出问题。</p>\n",
            "tags": [
                "Unity3D",
                "Unity3D"
            ]
        },
        {
            "id": "https://blog.aayu.today/feature/unity/20231020/",
            "url": "https://blog.aayu.today/feature/unity/20231020/",
            "title": "Unity3D优化笔记（9）合并网格、动画、音频、物理优化",
            "date_published": "2023-10-20T13:34:24.000Z",
            "content_html": "<h2 id=\"合并网格mesh-combine\"><a class=\"anchor\" href=\"#合并网格mesh-combine\">#</a> 合并网格（Mesh Combine）</h2>\n<p>对使用相同材质的模型可以使用第三方插件（例如：Easy Mesh Combine Tool）合并网格</p>\n<p>合并后，所有被合并的模型被整合成一个新的模型，DrawCall 和 Shader Caster 会下降，但顶点个数和三角面个数可能会增多，所以需要根据实际情况来使用</p>\n<h2 id=\"动画优化\"><a class=\"anchor\" href=\"#动画优化\">#</a> 动画优化</h2>\n<p>恰当地设置 Animator 组件的 Culling Mode。</p>\n<ul>\n<li>Always Animate 表示如果该动画不可见，也会播放它。</li>\n<li><mark>Cull Update Transformations 表示如果该动画不可见，则不会渲染该动画，但是依然会根据该动画的播放来改变游戏对象的位置、旋转、缩放</mark>，这样是常用的选项。</li>\n<li>Cull Completely 表示完全不会播放该动画，不但不会渲染该动画，而且也不会改变游戏对象的位置、旋转、缩放。</li>\n</ul>\n<p>禁用 SkinMesh Renderer 组件的 Update When Offscreen 可以让角色在不可见的时候动画不更新，这样可以减少计算量，提升性能。</p>\n<p><mark>对于 Animator 组件，可以使用 Animator.StringToHash 方法获得指定字符串的哈希值</mark>，再把它作为参数传入 Animator 型对象.GetXXX 方法和 Animator 型对象.SetXXX 方法中进行使用。</p>\n<p><mark>不用的 Animation 组件和 Animator 组件可以考虑删掉，因为只要它们存在，就会消耗性能来检测当前的状态和过渡条件。</mark></p>\n<p><mark>一些简单的动画可以使用 DoTween、iTween 等插件实现</mark>，而不需要每个动画都用 Animator 来实现。</p>\n<h2 id=\"音频优化\"><a class=\"anchor\" href=\"#音频优化\">#</a> 音频优化</h2>\n<p>Unity 支持后缀为.wav、.ogg、.mp3 的音频文件，但<mark>建议使用 .wav，因为 Unity 对它的支持特别好</mark>。注意：Unity 在构建项目时总是会自动重新压缩音频文件，因此无需刻意提前压缩一个音频文件再导入 Unity，因为这样只会降低该音频文件最终的质量。</p>\n<p>把音频文件导入 Unity 后，选中它，可以在 Inspector 窗口设置它的属性。</p>\n<ul>\n<li>建议勾选 Force To Mono，这样就会把这个音频文件设置为单声道。可以节省该资源所占据的空间。因为很少有移动设备实际配备立体声扬声器。在移动平台项目中，将导入的音频剪辑强制设置为单声道会使其内存消耗减半。此设置也适用于没有立体声效果的任何音频，例如大多数 UI 声音效果。</li>\n</ul>\n<p>对于 Load Type 选项</p>\n<ul>\n<li>小文件（小于 200kb）选择 Decompress on Load</li>\n<li>中等大小的文件（大于等于 200kb）选择 Compressed In Memory</li>\n<li>比较大的文件（如背景音乐）选择 Streaming</li>\n</ul>\n<p>对于 Compression Format 的选项</p>\n<ul>\n<li>PCM 表示不压缩</li>\n<li>Vorbis 表示压缩，但也会尽量保证音频的质量</li>\n<li>ADPCM 表示压缩，且压缩的程度比 Vobis 更高</li>\n</ul>\n<p><mark>由于 PCM 不会压缩音频，所以占用的空间大，应尽量少用，长时间的音频文件可以使用 Vorbis，短时间的音频文件可以使用 ADPCM</mark>。</p>\n<p>Sample Rate Setting 用于控制音频文件的采样率，对于移动平台，采样率不需要太高，建议选择 Override Sample Rate，然后在下方的 Sample Rate 选择 22050Hz，一般这样就够用了。</p>\n<h2 id=\"物理优化\"><a class=\"anchor\" href=\"#物理优化\">#</a> 物理优化</h2>\n<p><mark>使用简单的碰撞器进行碰撞检测</mark>，如球体碰撞器、盒子碰撞器、胶囊体碰撞器，<mark>少用网格碰撞器等复杂的碰撞器</mark>。即使用多个简单的碰撞器组合在一起，也往往比使用网格碰撞器的性能要好。</p>\n<p>如果要把多个碰撞器组合成一个碰撞器，可以用复合碰撞器。</p>\n<p><mark>如果同一个功能既可以用碰撞器来做，也可以用触发器来做，则往往使用触发器来做，性能更好。</mark></p>\n<p><mark>尽量减少刚体组件，因为刚体组件的物理计算较多。</mark></p>\n<p>如果勾选刚体组件的 Is Kinematic，则性能会有所提高。但这样一来，这个刚体只会给别的刚体施加力，自己不会受到别的刚体施加的力的作用。</p>\n<p>Edit——Project Settings——Player—— 勾选 Optimization 下方的 Prebake Collision Meshes，可以提高碰撞的效率，但是构建游戏的时间会增长。</p>\n<p>Edit——Project Settings——Physics 或者 Physics 2D—— 设置 Layer Collision Matrix。它规定了哪些 Layer 层的游戏对象可以彼此碰撞，哪些 Layer 层的游戏对象会忽略碰撞。如果有些 Layer 层的游戏对象之前不需要进行碰撞，则可以在这里设置，取消勾选则表示不会碰撞。</p>\n<p>Edit——Project Settings——Time—— 稍微调大 Fixed Timestep，这样可以稍微提升游戏性能，但是物体的运动可能会出现问题。</p>\n",
            "tags": [
                "Unity3D",
                "Unity3D"
            ]
        },
        {
            "id": "https://blog.aayu.today/feature/unity/20231019/",
            "url": "https://blog.aayu.today/feature/unity/20231019/",
            "title": "Unity3D优化笔记（8）UI优化、模型优化和LOD技术",
            "date_published": "2023-10-19T15:56:10.000Z",
            "content_html": "<h2 id=\"ui-优化\"><a class=\"anchor\" href=\"#ui-优化\">#</a> UI 优化</h2>\n<ul>\n<li>尽量避免使用 IMGUI 来做游戏时的 UI，因为 IMGUI 的开销比较大。</li>\n<li><mark>如果一个 UGUI 的控件不需要进行射线检测，则可以取消勾选 Raycast Target。</mark></li>\n<li>尽量<mark>避免使用完全透明的图片和 UI 控件</mark>。因为即使完全透明，我们看不见它，但它仍然会产生一定的性能开销。如果 UI 中一定要用到很多张完全透明的图片，则建议把这些完全透明的图片由单独的摄像机进行渲染，且这些 UI 不要叠加到场景摄像机的渲染范围内。</li>\n<li><mark>尽量避免 UI 控件的重叠</mark>。如果多个 UI 有重叠的部分，则会稍微增加一些额外的计算和渲染的开销。虽然这部分开销通常是非常小的，但我们最好也尽量避免这种情况。</li>\n<li><mark>UI 的文字使用 TextMeshPro 比使用 Text 的性能更好。但是 TextMeshPro 对中文的支持不太好。</mark></li>\n</ul>\n<h2 id=\"模型优化\"><a class=\"anchor\" href=\"#模型优化\">#</a> 模型优化</h2>\n<p>模型导入 Unity 后，可以选中这个模型，在 Inspector 窗口设置它的属性。</p>\n<ul>\n<li>\n<p>在 Model 选项卡</p>\n<ul>\n<li><mark>启用 Mesh Compression 可以压缩模型，压缩程度越高，模型精度越低，但是模型也会节省一些空间。</mark></li>\n<li>如果该模型不需要用代码来读写，则可以取消勾选 Read/Write Enabled。</li>\n<li>设置 Optimize Game Objects 可以优化模型，通常默认选择 Everything。</li>\n<li>如果该模型不需要使用法线，则可以把 Normals 设置为 None。</li>\n<li>如果该模型不需要用混合变形法线，则可以把 Blend Shape Normals 设置为 None。</li>\n<li>如果该模型不需要使用切线，则可以把 Tangents 设置为 None。</li>\n<li>如果该模型不需要用光照 UV 贴图，则可以取消勾选 Swap UVs 和 Generate Lightmap UVs。</li>\n</ul>\n</li>\n<li>\n<p>对于 Rig 选项卡</p>\n<ul>\n<li>Animation Type 如果选择 Generic Rig 会比 Humanoid Rig 性能更好，但无法使用动画重定向。一般使用 Humanoid Rig 是为了对人型的角色进行动画重定向，所以要根据自己的情况来选择。</li>\n<li><mark>如果模型不需要使用动画，例如一些完全不会动的石头等物体，则可以将 Animation Type 选择为 None。</mark></li>\n<li>Skin Weights 默认是 4，对于一些不重要的动画对象，本变量可以设置为 1，这样可以节省计算量。</li>\n<li>建议勾选 Optimize Bones，这样会自动剔除没有蒙皮顶点的骨骼。</li>\n<li>勾选 Optimize Game Object 可以提高角色动画的性能，但是在某些情况下可能会导致角色动画出现问题，是否勾选要看动画效果而定。</li>\n</ul>\n</li>\n<li>\n<p>对于 Animation 选项卡</p>\n<ul>\n<li>\n<p>如果模型不需要使用动画，则可以取消勾选 Import Animation。</p>\n</li>\n<li>\n<p><mark>设置 Anim.Compression 可以调整动画的压缩方式</mark></p>\n<ul>\n<li>Off 表示不压缩动画，这样动画文件可能会占用较大的空间，但是在运行时不会有任何信息损失，</li>\n<li>Keyframe Reduction 表示使用关键帧算法来压缩动画，这样会显著减小动画文件的大小，同时保持相对较高的动画质量，</li>\n<li>Optimal 表示会尽可能高地压缩网格，但是这样也会导致压缩时间增加。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>对于 Materials 选项卡</p>\n<ul>\n<li>如果使用 Untiy 的默认材质，则可以把 Material Creation Mode 设置为 None。</li>\n</ul>\n</li>\n</ul>\n<p>Edit——Project Settings——Player—— 勾选 Optimize Mesh Data，这样一来，Unity 会在构建的时候中对网格数据进行优化处理，以达到提高游戏性能的效果。但是这样往往会修改网格，我们勾选之后应该要进行测试，确保没有问题，再确定启用它。</p>\n<p>把多个模型的网格合并为一个网格。可以使用自己写代码，使用 Unity 自带的 CombineMeshes 方法，也可以使用资源商店的插件，在资源商店搜 Mesh Combine 可以搜索到相关的插件，例如 Easy Mesh Combine Tool 等插件。</p>\n<p>减少模型的顶点、面、材质、骨骼、蒙皮网格。这一般由美术人员来完成。</p>\n<h2 id=\"lodlevel-of-detail\"><a class=\"anchor\" href=\"#lodlevel-of-detail\">#</a> LOD（Level of Detail）</h2>\n<p>LOD 是 Level of Detail 的简称，意思是细节层次，它是一种优化技术。</p>\n<p>LOD 的原理，就是我们可以为一个游戏对象设定多个模型，这些模型消耗的游戏性能由高到低排列。会根据摄像机距离模型的远近自动显示对应的模型。近的时候显示最精细的模型，距离中等的时候显示没那么精细的模型，远的时候显示粗糙的模型，最远的时候可以隐藏该模型。</p>\n<p><mark>使用 LOD 技术能起到优化渲染性能的效果。但是使用 LOD 技术也会增加内存占用。</mark></p>\n<p>在 Unity 中可以使用 LODGroup 组件来实现 LOD 技术。</p>\n",
            "tags": [
                "Unity3D",
                "Unity3D"
            ]
        },
        {
            "id": "https://blog.aayu.today/feature/unity/20231018/",
            "url": "https://blog.aayu.today/feature/unity/20231018/",
            "title": "Unity3D优化笔记（7）光照优化、图片优化",
            "date_published": "2023-10-18T04:40:45.000Z",
            "content_html": "<h2 id=\"光照优化\"><a class=\"anchor\" href=\"#光照优化\">#</a> 光照优化</h2>\n<p><mark>减少不必要的光源的使用</mark>，调节好每个 Light 组件的属性，平衡视觉效果和游戏性能。</p>\n<p><mark>优先考虑使用烘焙光照或者混合光照，此时可以配合光照探针使用</mark>。Lighting 窗口可以设置烘焙光照的参数。减少启用的阴影投射。</p>\n<p>根据摄像机距离光源的距离，用脚本来决定是否启用光源和阴影。但是这样就会花费一些性能来计算摄像机到光源的距离。</p>\n<p>可以考虑设置光照的阴影。无阴影的性能最好，硬阴影的性能稍差，软阴影的视觉效果最好，但是性能是这三者中最差的。</p>\n<ul>\n<li>备注：<mark>光照和阴影最影响项目的性能，其次才是模型网格和贴图。把实时光照改成烘焙光照，可以使游戏性能大幅度增加。</mark></li>\n</ul>\n<p>注意 MeshRenderer 组件上的属性，默认情况下，Unity 会启用阴影投射和接收、光照探针采样、反射探针采样和运动矢量计算。如果项目不需要这些功能中的一个或多个，请确保关闭它们。2D 游戏尤其要注意，往往都不需要它们。</p>\n<p>远处的景物，如果确定玩家无法到达，则可以不用模型，而是把远处的景物做成一张贴图放到天空盒的材质中，给天空盒使用。也可以使用反射探针烘焙出一张贴图，然后放到天空盒的材质。</p>\n<h2 id=\"图片优化\"><a class=\"anchor\" href=\"#图片优化\">#</a> 图片优化</h2>\n<p>如果这张图片是应用在移动端的，则 == 导入 Unity 前，可以对这张图的每条边进行调整，确保每条边的长度都是 2 的正整数次方个像素。== 例如 2、4、8、16...256、512、1024、2048、4096...。<mark>这个做法只对移动端有效。</mark></p>\n<p>图片导入 Unity 后，可以选中这张图片，在 Inspector 窗口设置它的属性。</p>\n<ul>\n<li>设置这些属性，可以在<mark>发布不同的平台，分别对该图片进行相应的压缩。可以在合理的范围内减小 Max Size</mark>，对于许多移动端的游戏，2048x2048 或 1024x1024 足以满足纹理图集的要求，而 512x512 足以满足应用于 3D 模型的纹理的要求。</li>\n<li><mark>如果图片不需要读写，则可以取消勾选 Read/Write Enabled，如果勾选可能导致双倍的内存占用。</mark></li>\n<li><mark>Filter Mode 一般选择 Bilinear 即可平衡性能和视觉效果</mark>，如果选择 Point (no filter)，则视觉效果不太行，但性能开销也小，如果选择 Trilinera，则视觉效果最好，但性能开销最大。Aniso Level 一般选择 1，只有个别比较重要的图片才需要设置为大于等于 2 的值。</li>\n</ul>\n<p>图片导入 Unity 后，会默认生成 Mip Maps 格式。</p>\n<ul>\n<li>当摄像机到这幅贴图距离近，则显示最原始的图片，<mark>当摄像机距离这幅贴图的距离远，则这幅贴图会变模糊，以此降低渲染的性能消耗。</mark></li>\n<li>但由于之前显示的一幅图，现在变成了有多幅，所以这样会略微增加内存消耗。<mark>如果确定本游戏的摄像机到图片的距离几乎不怎么变化，则可以禁用这个功能。<mark>点击该贴图，在 Inspector 面板的 Advanced 中</mark>取消勾选 Generate Mip Maps，这样就不会生成 Mip Maps，增加游戏性能。</mark></li>\n<li><mark>如果是 2D 游戏则可以禁用这个功能。如果是 UI 贴图，也可以禁用这个功能。</mark></li>\n</ul>\n<p>图片导入 Unity 后，可以选中这张图片，在 Inspector 窗口设置它在各个平台的 Format 和 Compressor Quality。Format 可以参考官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9jbGFzcy1UZXh0dXJlSW1wb3J0ZXJPdmVycmlkZS5odG1s\">https://docs.unity3d.com/2021.3/Documentation/Manual/class-TextureImporterOverride.html</span></p>\n<p><mark>用 Sprite Atlas 把图片打包成图集。但是这样一来，要使用图集中的任意一张图片，都会先加载这整个图集，这样占用的内存会增加。</mark></p>\n<p>Sprite Atlas 的优点</p>\n<ul>\n<li>减小资源文件所占的大小</li>\n<li>打包到同一个 Sprite Atlas 图集中的图片会共享相同的纹理数据，减少了重复的存储，往往能起到优化内存的作用</li>\n<li><mark>可以减少 DrawCall，提高游戏的渲染性能</mark></li>\n</ul>\n<p>Sprite Atlas 的缺点</p>\n<ul>\n<li>需要手动将图片添加到 Sprite Atlas，增加了额外的工作量</li>\n<li>当加载图集中的任意一张图，都会先加载整个图集。如果把一些不常用的图打包到同一个图集中，则会浪费内存</li>\n</ul>\n<p>在代码中控制加载 Sprite Atlas</p>\n<figure class=\"highlight csharp\"><figcaption data-lang=\"C#\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Awake</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tspriteAtlas <span class=\"token operator\">=</span> Resources<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">Load</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span>SpriteAtlas<span class=\"token punctuation\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MySpriteAtlas\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Input<span class=\"token punctuation\">.</span><span class=\"token function\">GetKeyDown</span><span class=\"token punctuation\">(</span>KeyCode<span class=\"token punctuation\">.</span>Q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\timage1<span class=\"token punctuation\">.</span>sprite <span class=\"token operator\">=</span> spriteAtlas<span class=\"token punctuation\">.</span><span class=\"token function\">GetSprite</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"trees_0\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Input<span class=\"token punctuation\">.</span><span class=\"token function\">GetKeyDown</span><span class=\"token punctuation\">(</span>KeyCode<span class=\"token punctuation\">.</span>W<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\timage2<span class=\"token punctuation\">.</span>sprite <span class=\"token operator\">=</span> spriteAtlas<span class=\"token punctuation\">.</span><span class=\"token function\">GetSprite</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"trees_1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure>",
            "tags": [
                "Unity3D",
                "Unity3D"
            ]
        },
        {
            "id": "https://blog.aayu.today/feature/unity/20231017/",
            "url": "https://blog.aayu.today/feature/unity/20231017/",
            "title": "Unity3D优化笔记（6）遮挡剔除",
            "date_published": "2023-10-17T05:43:03.000Z",
            "content_html": "<p>正常情况下，如果一个障碍物 A 挡住了后面的物体 B，虽然我们看不见物体 B，但是 Unity 仍然会消耗性能来渲染这个物体 B。这样 CPU 和 GPU 就会有一部分性能白白浪费在渲染物体 B 身上。</p>\n<p><mark>如果想在一个障碍物挡住了后面的物体后，不渲染被挡住的物体，则可以使用遮挡剔除。</mark></p>\n<p>官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL2NuL2N1cnJlbnQvTWFudWFsL09jY2x1c2lvbkN1bGxpbmcuaHRtbA==\">https://docs.unity3d.com/cn/current/Manual/OcclusionCulling.html</span></p>\n<p>以一堵墙挡住几个小球为例，选中这堵墙，在 Inspector 窗口右上角的 Static 右侧的下拉菜单处选择 Occluder Static，则这堵墙就是遮挡物。分别选中这些小球，在 Inspector 窗口右上角的 Static 右侧的下拉菜单处选择 Occludee Static，则这些小球就是被遮挡物。</p>\n<p><mark>注意，无论是勾选了 Occluder Static 还是 Occludee Static，勾选后物体就无法运动了。</mark></p>\n<p>对于一个物体，两个标签都可以勾选，这样它既可以遮挡剔除别的物体，也可以被别的物体遮挡剔除。</p>\n<p><mark>有时候被遮挡物只勾 Occludee Static，烘焙之后可能看不出遮挡剔除的效果，建议把 Occluder Static 也勾上，再重新烘焙，或许就能看出效果了。</mark></p>\n<p><mark>选中摄像机，要确保它启用了 Occlusion Culling 属性。</mark></p>\n<p>设置完之后，要创建一个遮挡区域，当摄像机处于这个遮挡区域中，遮挡剔除才会生效。</p>\n<p>创建遮挡区域的方法：</p>\n<ul>\n<li>方法 1、打开 Occlusion Culling 窗口。打开方法：Window——Rendering——Occlusion Culling——Bake。打开之后，选择 Object 选项卡，点击 Occlusion Areas，点击 Create New 右侧的 Occlusion Area。</li>\n<li>方法 2、创建一个空物体，在它身上添加 Occlusion Area 组件。</li>\n</ul>\n<p>Occlusion Area 组件的 Size 决定了遮挡剔除区域的范围，它越大，烘焙之后生成的遮挡剔除区域就越大。Center 控制遮挡区域中心点的世界坐标。<mark>Is View Volume 表示是否定义视图体积，只有启用了这个选项，Occlusion Area 组件才可能生效。</mark></p>\n<p>之后，要让遮挡剔除生效，还要在 Occlusion Culling 窗口的 Bake 选项卡中点击右下方的 Bake 按钮，进行烘焙，遮挡剔除才可能生效。<mark>而且以后每次调整完场景的遮挡物、被遮挡物、Occlusion Area 组件的范围，都要这样烘焙一次</mark>。如果点击旁边的 Clear 按钮，则会清除之前烘焙的数据。</p>\n<p>烘焙完之后，当摄像机在 Occlusion Area 组件的范围内，则被遮挡的物体不会被渲染。遮挡物实际上遮挡了摄像机视锥体的范围，只要物体完全没有出现在摄像机视锥体的范围内，则都不会被渲染。<mark>但是一旦物体的任意一小部分暴露在了摄像机视锥体的范围内，则这个物体整个会被渲染出来</mark></p>\n<p>当摄像机移出了 Occlusion Area 组件的范围，则遮挡剔除会失效。</p>\n<p>Occlusion Culling 窗口：</p>\n<p>Object 选项卡。通过点击 All、Renderers、Occlusion Areas 按钮可以筛选 Hierarchy 窗口的内容。之后，在 Hierarchy 窗口或 Scene 窗口中选择一个筛选出来的游戏对象，就可以 Occlusion Culling 窗口中查看它的遮挡剔除设置。</p>\n<p>Bake 选项卡。用于烘焙。<mark>遮挡剔除必须烘焙之后才可能生效</mark>。Set default parameters 用于将参数重置为默认值。</p>\n<ul>\n<li>Smallest Occluder 表示用于遮挡其它游戏对象的最小游戏对象的大小，以米为单位，数值越小遮挡的效果越精确，但是性能开销也越大。Smallest Hole 表示摄像机可以看到的最小间隙的直径，以米为单位，需要注意的是，设置过小的</li>\n<li>Smallest Hole 值可能会导致一些细微的间隙被错误地认为是可见的，从而导致部分遮挡物不被正确地剔除。</li>\n<li>Backface Threshold 的数值越小，烘焙所产生的文件所占空间就越小，但也可能造成视觉上的失真。Bake 按钮用于烘焙。Clear 按钮用于清除上一次烘焙的数据。</li>\n</ul>\n<p>Visualization 选项卡。选择后，可以在 Scene 窗口看到遮挡剔除的效果。此时在 Scene 窗口可以看到三个选项。</p>\n<ul>\n<li>Camera Volumes。启用后，可以在 Scene 窗口看到黄色区域，当摄像机在这个黄色区域内，遮挡剔除才可能会生效，摄像机离开这个区域，则遮挡剔除就会失效。我们还可以看到灰线，这些灰线指示摄像机当前位置所对应的遮挡剔除数据中的单元格以及当前单元格中的细分。Bake 选项卡 Smallest Hole 参数设置定义了单元格内细分的最小大小，它的值越小，每个单元格产生的细分越多且越小，从而使精度提高并且文件增大。</li>\n<li>Visibility Lines。启用后，我们会看到绿色的区域，它表示摄像机可以看到的范围。</li>\n<li>Portals。启用后，我们可以看到一些线，它们代表遮挡数据中单元格之间的连接。</li>\n</ul>\n<p>进行遮挡剔除的烘焙时，不会烘焙动态的游戏对象的信息到遮挡剔除的数据中。动态的游戏对象只能作为被遮挡物，而不能充当遮挡物。要让动态的游戏对象成为遮挡剔除中的被遮挡物，可以选中它，启用它身上 Mesh Renderer 组件身上的 Dynamic Occlusion 属性。</p>\n<h2 id=\"在代码中控制遮挡剔除\"><a class=\"anchor\" href=\"#在代码中控制遮挡剔除\">#</a> 在代码中控制遮挡剔除</h2>\n<p>使用 Occlusion Portal 组件也可以实现遮挡剔除。</p>\n<p><mark>例如可以在一堵墙上添加 Occlusion Portal 组件。而且这堵墙不勾选 Inspector 窗口右上角下拉菜单的 Occluder Static 和 Occludee Static，但是被它遮挡的物体仍然要勾选 Occluder Static 和 Occludee Static。</mark></p>\n<p>设置好之后，打开 Occlusion Culling 窗口，在 Bake 选项卡进行烘焙。</p>\n<p>这样一来，Occlusion Portal 组件就会生效。当取消勾选它的 Open 属性后，被这堵墙就会使用遮挡剔除。当勾选它的 Open 属性后，被这堵墙就不会使用遮挡剔除。我们可以使用代码来控制 Open 属性，控制这堵墙在什么时候使用遮挡剔除，什么时候不使用遮挡剔除。</p>\n<p>Occlusion Portal 组件的 Center 属性控制了中心的位置，Size 属性控制了遮挡的范围。点击 Edit Bounds 左侧的按钮后，可以在 Scene 窗口手动调节 Occlusion Portal 组件的遮挡范围。每次调整完，或者修改过场景，都要重新烘焙。</p>\n",
            "tags": [
                "Unity3D",
                "Unity3D"
            ]
        },
        {
            "id": "https://blog.aayu.today/feature/unity/20231016/",
            "url": "https://blog.aayu.today/feature/unity/20231016/",
            "title": "Unity3D优化笔记（5）静态合批、动态合批和GPU Instancing",
            "date_published": "2023-10-16T05:38:40.000Z",
            "content_html": "<h2 id=\"静态合批\"><a class=\"anchor\" href=\"#静态合批\">#</a> 静态合批</h2>\n<p>静态合批也叫静态批处理，是 Unity 的一种优化技术。</p>\n<p><mark>对于始终静止不动的物体使用静态合批后，CPU 会把它们合并为一个批次发送给 GPU 处理，这样可以减少 Draw Call 带来的性能消耗，从而提升游戏性能。</mark></p>\n<p>官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL2NuL2N1cnJlbnQvTWFudWFsL3N0YXRpYy1iYXRjaGluZy5odG1s\">https://docs.unity3d.com/cn/current/Manual/static-batching.html</span></p>\n<p>要使用静态合批，必须确保 Edit——Project Settings——Player——Other Settings——Static Batching 是勾选的。</p>\n<p>把一个物体设置为静态的方法：</p>\n<ul>\n<li>选中该物体，点击在 Inspector 窗口右上角的 Static 右方的下拉菜单，选择 Batching Static。</li>\n</ul>\n<p><mark>使用静态合批虽然可以提升游戏性能，但是设置为静态的物体在整个游戏中就不能再运动了，强行使它们运动会出问题。</mark></p>\n<p>而且即使按照以上步骤进行了静态合批，也不一定保证会成功，必须满足以下全部条件，静态合批才会成功：</p>\n<ol>\n<li>游戏对象处于激活状态。</li>\n<li>游戏对象有一个 Mesh Filter 组件，并且该组件已启用。</li>\n<li>Mesh Filter 组件具有对网格的引用。</li>\n<li>网格已启用 Read/Write 功能。</li>\n<li>网格的顶点计数大于 0。</li>\n<li>该网格尚未与另一个网格组合。</li>\n<li>游戏对象有一个 Mesh Renderer 组件，并且该组件已启用。</li>\n<li>网格渲染器组件不将任何材质与 DisableBatching 标记设置为 true 的着色器一起使用。</li>\n<li>要批处理在一起的网格使用相同的顶点属性。例如，Unity 可以将使用顶点位置、顶点法线和一个 UV 的网格与另一个 UV 进行批处理，但不能将使用顶点定位、顶点法线、UV0、UV1 和顶点切线的网格进行批处理。</li>\n</ol>\n<p>即使静态合批成功，<mark>合出来的每个批次可以包含的网格顶点数是有限的，最多是 64000 个顶点。如果超过这个数，则会创建到另一个批次中。</mark></p>\n<p>如果要在游戏运行时进行静态合批，则可以使用 StaticBatchingUtility 类的 Combine 方法。</p>\n<p>StaticBatchingUtility.Combine (GameObject 根物体)</p>\n<ul>\n<li>对指定的根物体的所有子孙物体进行静态合批。</li>\n<li>只有当它们符合静态合批的所有条件，静态合批才会成功。</li>\n<li>成功之后，这些物体就不能再运动了，强行运动会出问题。但是该根物体仍然允许运动。</li>\n</ul>\n<p>StaticBatchingUtility.Combine (GameObject [] 要进行静态合批的游戏对象，GameObject 根物体)</p>\n<ul>\n<li>对指定的游戏对象进行静态合批，并指定它们静态合批的根物体。</li>\n<li>只有当它们符合静态合批的所有条件，静态合批才会成功。</li>\n<li>成功之后，这些物体就不能再运动了，强行运动会出问题。但是该根物体仍然允许运动。</li>\n</ul>\n<h2 id=\"动态合批\"><a class=\"anchor\" href=\"#动态合批\">#</a> 动态合批</h2>\n<p>动态合批也叫动态批处理，是 Unity 的一种优化技术。</p>\n<p><mark>对移动的物体使用动态合批后，则 Unity 不会一个个绘制它们，而是把它们合并为一个批次（Batch）</mark>，再由 CPU 把它们一次性提交给 GPU 进行处理，这样可以减少 Draw Call 带来的性能消耗，从而提高性能。</p>\n<p>官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL2NuL2N1cnJlbnQvTWFudWFsL2R5bmFtaWMtYmF0Y2hpbmcuaHRtbA==\">https://docs.unity3d.com/cn/current/Manual/dynamic-batching.html</span></p>\n<p><mark>动态合批默认是由 Unity 自动完成</mark>。可以在 Edit——Project Settings——Player——Other Settings——Dynamic Batching 查看。<mark>默认 Dynamic Batching 是勾选的</mark>，当条件满足时，<mark>Unity 会自动对使用了相同材质（Material）的物体进行动态合批</mark>。如果取消勾选，则不会进行动态合批。</p>\n<p>即使勾选了 Dynamic Batching，也必须同时满足以下条件，动态合批才会成功：</p>\n<ol>\n<li>Unity 不能对包含超过 900 个顶点属性和 225 个顶点的网格应用动态批处理。这是因为网格的动态批处理对每个顶点都有开销。例如，如果你的着色器使用顶点位置、顶点法线和单个 UV，那么 Unity 最多可以批处理 225 个顶点。然而，如果你的着色器使用顶点位置、顶点法线、UV0、UV1 和顶点切线，那么 Unity 只能批处理 180 个顶点。</li>\n<li>如果 GameObjects 使用不同的材质实例，Unity 就不能将它们批处理在一起，即使它们本质上是相同的。唯一的例外是阴影施法者的渲染。</li>\n<li>带有光贴图的游戏对象有额外的渲染参数。这意味着，如果你想批处理光照贴图的游戏对象，它们必须指向相同的光照贴图位置。</li>\n<li>Unity 不能完全将动态批处理应用于使用多通道着色器的 GameObjects。</li>\n</ol>\n<p>几乎所有的 Unity 着色器都支持正向渲染中的多个光源。为了实现这一点，他们为每个光处理一个额外的渲染通道。Unity 只批处理第一个渲染通道。它不能批处理额外的逐像素灯光的绘制调用。</p>\n<p>遗留延迟渲染路径不支持动态批处理，因为它在两个渲染通道中绘制 GameObjects。第一个通道是灯光预通道，第二个通道渲染 GameObjects。</p>\n<p><mark>其中我们要注意的是，物体必须使用相同的材质，才有可能成功进行动态合批。</mark></p>\n<p><mark>使用动态合批往往能减少 CPU 和 GPU 的开销，提升游戏性能，但同时也会占用一定的内存。</mark></p>\n<p>是否要开启动态合批，要根据自己的项目来定。可以尝试启用，在性能分析器中看看效果如果，如果效果好，再确定启用它。</p>\n<h2 id=\"gpu-instancing\"><a class=\"anchor\" href=\"#gpu-instancing\">#</a> GPU Instancing</h2>\n<p>GPU Instancing 是 Unity 的一种优化技术。</p>\n<p><mark>使用 GPU Instancing 可以在一个 Draw Call 中同时渲染多个相同或类似的物体</mark>，从而减少 CPU 和 GPU 的开销。</p>\n<p>官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9HUFVJbnN0YW5jaW5nLmh0bWw=\">https://docs.unity3d.com/Manual/GPUInstancing.html</span></p>\n<p>要启用 GPU Instancing，我们可以选中一个材质，然后在 Inspector 窗口勾选 Enable GPU Instancing，这样就可以了。</p>\n<p>但是即使勾选了 Enable GPU Instancing，也不一定会成功。</p>\n<p>要成功使用 GPU Instancing 进行优化，游戏对象必须同时满足以下条件：</p>\n<ol>\n<li><mark>使用相同的材质和网格。</mark></li>\n<li>材质的着色器必须支持 GPU Instancing。例如标准着色器和表面着色器就支持 GPU Instancing。</li>\n<li>网格的顶点布局和着色器必须相同。如果网格的顶点布局或着色器不同，那么它们就无法被合并成一个实例。</li>\n<li>每个实例需要有不同的变换信息（例如位置、旋转、缩放）。虽然多个实例可以使用相同的材质和网格，但是它们必须拥有不同的变换信息才能被正确地实例化并渲染出来。</li>\n</ol>\n<p>另外需要注意的是，GPU Instancing 与 SRP Batcher 不兼容。如果项目使用了 SRP Batcher，并且配置为优先使用 SRP Batcher 而不是 GPU 实例化，启用 GPU 实例化可能不会生效。SRP Batcher 是 Unity 提供的一种渲染优化技术，它可以将多个网格合并成单个批次进行渲染，从而提高性能。在这种情况下，GPU 实例化将被忽略。</p>\n<p><mark>使用 GPU Instancing 往往能减少 CPU 和 GPU 的开销，提升游戏性能，但同时也会占用一定的内存。</mark></p>\n<p>是否要启用 GPU Instancing，要根据自己的项目来定。可以尝试启用，在性能分析器中看看效果如果，如果效果好，再确定启用它。</p>\n<p>一般来说，当场景中有大量重复的网格实例时，可以尝试启用 GPU Instancing。例如场景中有大量树木、草地、石块等，这些实例具有相同的网格和材质，只是位置、颜色等属性稍有差异，那么启用 GPU Instancing 或许能够显著提高性能。</p>\n",
            "tags": [
                "Unity3D",
                "Unity3D"
            ]
        },
        {
            "id": "https://blog.aayu.today/feature/unity/20231006/",
            "url": "https://blog.aayu.today/feature/unity/20231006/",
            "title": "XREAL开发笔记（1）照片溶解特效",
            "date_published": "2023-10-06T15:12:33.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>最近学了一个照片溶解特效，感觉很炫酷，也可以作为后续项目花里胡哨的基础，便在此将学习过程记录一下吧～</p>\n<p>话不多说，先看看最终效果～</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071342614.gif\" alt=\"\" /></p>\n<h2 id=\"创建和配置项目\"><a class=\"anchor\" href=\"#创建和配置项目\">#</a> 创建和配置项目</h2>\n<p>选择 3D（URP）项目，然后点击 Create Project 即可创建项目。</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/06/202310062329303.png\" alt=\"\" /></p>\n<p>打开 Unity，File--&gt;Build Settings, 选择 Android，点击 Switch Platform</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071110378.png\" alt=\"\" /></p>\n<p>在 Build Settings 窗口中，选择 Player Settings, 然后按照下面对应的设置进行配置</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071112820.png\" alt=\"\" /></p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071115921.png\" alt=\"\" /></p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071115680.png\" alt=\"\" /></p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071118937.png\" alt=\"\" /></p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071118023.png\" alt=\"\" /></p>\n<h2 id=\"导入-nrsdk\"><a class=\"anchor\" href=\"#导入-nrsdk\">#</a> 导入 NRSDK</h2>\n<p>将 NRSDKForUnity_Release_1.10.2 拖入到 Assets 文件夹中，点击 Import 即可导入</p>\n<p>在 Scenes 文件夹下创建个新场景，删除默认的相机，将 NRCameraRig 和 NRInput 拖拽到场景中</p>\n<h2 id=\"创建-shader\"><a class=\"anchor\" href=\"#创建-shader\">#</a> 创建 Shader</h2>\n<p>在 Assets 下创建 Materials 文件夹，在 Materials 文件夹上右键，点击 Create -&gt; Shader Graph -&gt; URP -&gt; Lit Shader Graph，命名为 Dissolve，双击打开</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071135598.png\" alt=\"\" /></p>\n<p>小 Tip：双击选项卡可以最大化选项卡，再次双击可以恢复</p>\n<p>首先创建 4 个可以暴露的属性，注意创建属性的类型</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071138114.png\" alt=\"\" /></p>\n<p>然后将 MainTex 拖拽到画板里，从节点拉出一根线然后在空白书松开，选择 Sample Texture 2D，双击创建新节点，然后把 RGBA 连接到 Base Color</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071141655.png\" alt=\"\" /></p>\n<p>勾选 Graph Inspector 窗口里的 Alpha Clip，可以看到片元着色器就会多出两个属性，透明度和透明度裁剪阈值，我们的溶解特效就是根据这两个属性实现的。具体来讲就是随机一个高斯噪声，根据噪声透明度和阈值裁剪照片，将透明度小于该值的像素点裁剪掉，通过将阈值从小变到大，从而实现溶解特效。</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071145121.png\" alt=\"\" /></p>\n<p>在画板空白处右键，选择 Simple Noise 节点创建，将 X 值调为 30 左右，然后将 Out 连接到 Alpha 变量上</p>\n<p>为了溶解特效更加炫酷，可以将溶解边缘增加发光效果，具体节点和连接如下</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071202381.png\" alt=\"\" /></p>\n<p>小 Tip：可以框选住一些节点，然后右键选择 Group Selection，可以将这些节点合并成一个节点，方便一起拖拽</p>\n<p>可以在右侧 Graph Inspector 窗口的 Node Settings 里将 AlphaThreshold 模式变为滑动条模式，并给一个默认值 0.5，就可以看到 Step 节点下面的预览图像为二值化后的图像了</p>\n<p>RimColor 将模式变为 HDR，然后默认颜色可以设为红色，这样就可以将溶解边缘设为红色的发光了</p>\n<p>然后再将最后的 Out 连接到片元着色器的 Emission 上，这样溶解边缘发光的 Shader 就配置好啦</p>\n<p>边缘发光的宽度可以通过 RimWidth 属性控制，可以将 RimWidth 也设为滑动条模式，然后范围设为 0 到 5，默认值为 2</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071204576.png\" alt=\"\" /></p>\n<p>至此，溶解特效的 Shader 就配置好啦，点击左上角的 Save Asset 保存，然后双击选项卡退出最大化</p>\n<h2 id=\"创建材质\"><a class=\"anchor\" href=\"#创建材质\">#</a> 创建材质</h2>\n<p>在 Assets 里的 Dissolve Shader 上右键，点击 Create -&gt; Material，命名为 Mat_Dissolve</p>\n<p>然后在场景中创建一个 Quad，双击可以聚焦到这个物体，然后将 Mat_Dissolve 拖拽到这个物体上，就可以看到这个物体的材质变成了 Mat_Dissolve</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071211267.png\" alt=\"\" /></p>\n<p>现在溶解特效就已经可以看出来了</p>\n<p>可以将 Quad 的 Z 值设为 3，即物体在镜头外 3 米的地方，这样就可以在 Game 窗口里看到物体了</p>\n<p>将 NRSDK 里自带的 Image 拖拽到我们在 Shader 里设置的 MainTex 属性上</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071215794.png\" alt=\"\" /></p>\n<p>然后拖拽 AlphaThreshold 就可以看到效果了</p>\n<p>想要看到炫光还需要一点配置</p>\n<p>首先在场景处右键，选择 Volume -&gt; Global Volume，然后配置文件选择默认已有的 SampleSceneProfile 即可</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071221375.png\" alt=\"\" /></p>\n<p>然后将 LeftCamera，CenterCamera，RightCamera 的 Post Processing 都打上勾，即启用后处理配置</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071224514.png\" alt=\"\" /></p>\n<p>然后再回到 Quad，可以在 RimColor 里调整炫光强度</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071225331.png\" alt=\"\" /></p>\n<p>至此，照片溶解特效就配置好啦</p>\n<h2 id=\"编写脚本\"><a class=\"anchor\" href=\"#编写脚本\">#</a> 编写脚本</h2>\n<p>在 Assets 下创建 Scripts 文件夹，然后在 Scripts 文件夹上右键，点击 Create -&gt; C# Script，命名为 Dissolve，双击打开代码编辑器，代码内容如下</p>\n<figure class=\"highlight csharp\"><figcaption data-lang=\"C#\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token namespace\">System<span class=\"token punctuation\">.</span>Collections</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">using</span> <span class=\"token namespace\">UnityEngine</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Dissolve</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">MonoBehaviour</span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">readonly</span> <span class=\"token class-name\"><span class=\"token keyword\">int</span></span> mAlphaThreshold <span class=\"token operator\">=</span> Shader<span class=\"token punctuation\">.</span><span class=\"token function\">PropertyToID</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"_AlphaThreshold\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">StartDissolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token function\">StartCoroutine</span><span class=\"token punctuation\">(</span><span class=\"token function\">DissolveEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">private</span> <span class=\"token return-type class-name\">IEnumerator</span> <span class=\"token function\">DissolveEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token comment\">// 获取当前物体的 MeshRenderer 组件</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token class-name\">MeshRenderer</span> meshRenderer <span class=\"token operator\">=</span> gameObject<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">GetComponent</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span>MeshRenderer<span class=\"token punctuation\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token comment\">// 获取当前物体的材质</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token class-name\">Material</span> material <span class=\"token operator\">=</span> meshRenderer<span class=\"token punctuation\">.</span>material<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token comment\">// 将材质的溶解值缓慢从 0 变为 1，持续 2s</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">float</span></span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">+=</span> Time<span class=\"token punctuation\">.</span>deltaTime<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            material<span class=\"token punctuation\">.</span><span class=\"token function\">SetFloat</span><span class=\"token punctuation\">(</span>mAlphaThreshold<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            <span class=\"token keyword\">yield</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token comment\">// 重新设置溶解值为 0</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        material<span class=\"token punctuation\">.</span><span class=\"token function\">SetFloat</span><span class=\"token punctuation\">(</span>mAlphaThreshold<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在 Quad 上添加一个 Button 组件，并将 Dissolve 脚本先拖拽到 Quad 物体上，然后把 Quad 拖拽到 On Click 事件里，然后选择 Dissolve -&gt; StartDissolve</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071252207.png\" alt=\"\" /></p>\n<p>这样，当控制器的射线点击到 Quad 上时，就会触发溶解特效了</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/10/07/202310071256539.gif\" alt=\"\" /></p>\n<p>最后就是构建成手机 App，然后将 Air2 眼镜切换为 3D 模式，运行应用就可以看到效果啦</p>\n<p>完结撒花～</p>\n",
            "tags": [
                "Unity3D",
                "XREAL",
                "Unity3D",
                "XREAL"
            ]
        },
        {
            "id": "https://blog.aayu.today/feature/unity/20231005/",
            "url": "https://blog.aayu.today/feature/unity/20231005/",
            "title": "Unity3D优化笔记（4）其他分析工具",
            "date_published": "2023-10-05T15:49:32.000Z",
            "content_html": "<h2 id=\"unity-frame-debugger-窗口帧调试器窗口\"><a class=\"anchor\" href=\"#unity-frame-debugger-窗口帧调试器窗口\">#</a> Unity Frame Debugger 窗口（帧调试器窗口）</h2>\n<p>Frame Debugger 窗口也叫帧调试器窗口，用于查看每一帧的画面是如何渲染出来的，可以详细查看这一帧的绘制过程。</p>\n<p>打开 Frame Debugger 面板的方式：</p>\n<ul>\n<li>Window——Analysis——Frame Debugger</li>\n</ul>\n<p>按下 “Enable”，则会启动帧调试，此时如果运行了游戏，则会自动暂停，然后当前这帧的渲染情况可以在这个窗口中查看。</p>\n<p>上方的 X of X 表示绘制过程中有多少步，可以查看下一步或上一步。</p>\n<p>如果要禁用帧调试，可以按下 “Disable”。</p>\n<p><mark>用 Frame Debugger 窗口查看当前一帧的每一步时，可以配合 Stats 窗口使用，以此来确定哪一个物体造成的性能开销较大</mark>。</p>\n<p>绘制的步骤越少，性能越好。</p>\n<p>Frame Debugger 窗口也能看到每一帧的 Shader 信息，但是需要有一定 Shader 基础才能看懂。</p>\n<ul>\n<li>大多数平台都支持帧调试器的使用，可以用手机的数据线成功连接到电脑，在手机上运行 Unity 的游戏，Frame Debugger 窗口中会多出该手机设备供我们选择，我们就可以分析该手机设备上运行的 Unity 项目的性能。</li>\n<li>也可以让手机和电脑都连接同一个 wifi，这样一来，Frame Debugger 窗口中也会多出该手机设备供我们选择，我们就可以分析该手机设备上运行的 Unity 项目的性能。</li>\n<li>但是要注意，构建时必须在 Project Settings 窗口中勾选 “Development Build”。而且有些平台可能不支持 Frame Debugger 的使用，例如 WebGL 平台。</li>\n</ul>\n<h2 id=\"memory-profiler\"><a class=\"anchor\" href=\"#memory-profiler\">#</a> Memory Profiler</h2>\n<p><mark>Memory Profiler 可以查看游戏当前一帧具体的内存使用情况</mark>，我们可以详细地看到各种东西占用了多少内存。</p>\n<p>如果发现某样东西占用了过高的内存，则可以考虑问题是不是出在它身上，从它身上入手来进行优化。也可以分析是不是存在内存泄漏问题，即可以分析是不是某些资源一直占着内存得不到释放，才导致内存占用过高。</p>\n<p>旧版 Unity 安装它的方法：<br />\nWindows——Package Manager——All packages——Memory Profiler——Install<br />\n 如果找不到，说明它可能在当前 Unity 版本下是预览版，可以在 Advanced 下拉菜单选择 Show preview packages，再查找它出来安装</p>\n<p>安装方法：<br />\nEdit——Project Settings——Package Manager—— 勾选 Enable Pre-release Packages—— 关闭窗口 ——Window——Package Manager—— 点击左上方的 + 号 ——Add package by name—— 输入 com.unity.memoryprofiler—— 点击 Add<br />\n 注意：下载的时候可能需要科学上网。</p>\n<p>安装完后打开方式：<br />\nWindow——Analysis——Memory Profiler</p>\n<p>点击 Capture New Snapshot 会创建当前这一时刻的内存快照，可以看到这一帧的内存情况。== 它默认会存储在与 Assets 文件夹同级的目录的一个叫做 MemoryCaptures 的文件夹中。== 如果要修改这个路径，也可以点击右上角的三点，点击 Open Preferences，修改 Memory Snapshot Storage Path 的值。</p>\n<p>Single Snapshot 表示用来分析单张内存快照，Compare Snapshots 可以通过对比来分析两张内存快照。</p>\n<p>选中一张内存快照后，点击 Tree Map 可以看出各种资源和脚本所占用的内存，选中其中一块，可以具体地看出到底它们分别占用多少内存。如果某个名字的资源占用的内存高，那么可以考虑问题是不是出在它身上，这样我们就可以从它身上入手来进行优化。但是要注意，有一些名字的资源可能在项目中不找到，因为它们是 Unity 自带的资源。</p>\n<p><mark>在 Unity 编辑器中运行游戏，Memory Profiler 记录的内存情况可能会不准确</mark>，它会把 Unity 编辑器的一些内存占用情况也记录进去。<mark>我们应该把游戏构建到电脑或者手机，然后在电脑或者手机上运行游戏，再用 Memory Profiler 拍内存快照来分析，此时这些内存快照记录的数据才是准确的。</mark></p>\n<p>构建项目到电脑时，应勾选 Build Settings 窗口的 Development Build、Autoconnect Profiler，这样当发布的游戏运行时，就可以在 Unity 引擎的 Memory Profiler 左上角的下拉菜单选择关联刚才发布的程序，拍下快照查看它的内存占用情况。</p>\n<p>用手机数据线连接到电脑，在手机上运行游戏，并在电脑分析，也必须勾选 Build Settings 窗口的 Development Build、Autoconnect Profiler，而且手机上应勾选 “开启开发者选项”、“USB 调试”、“USB 安装”。当用手机数据线连接到电脑，Memory Profiler 左上的下拉菜单可以选择连接到电脑的手机设备。</p>\n<h2 id=\"unity-physics-debugger-窗口物理调试窗口\"><a class=\"anchor\" href=\"#unity-physics-debugger-窗口物理调试窗口\">#</a> Unity Physics Debugger 窗口（物理调试窗口）</h2>\n<p>Physics Debugger 窗口也叫物理调试窗口，使用它可以在 Scene 窗口中查看当前场景中游戏对象的碰撞器、触发器、刚体、关节等与物理模拟相关的东西的范围。尤其是在游戏对象较多的场景中，<mark>使用物理调试窗口可以方便我们观看它们的范围</mark>。</p>\n<p>打开方法：Window——Analysis——Physics Debugger</p>\n<p>官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL2NuL2N1cnJlbnQvTWFudWFsL1BoeXNpY3NEZWJ1Z1Zpc3VhbGl6YXRpb24uaHRtbA==\">https://docs.unity3d.com/cn/current/Manual/PhysicsDebugVisualization.html</span></p>\n<p>在 Scene 窗口中勾选 Collision Geometry，则会在 Scene 窗口中显示游戏对象的碰撞几何体，具体的情况可以在 Physics Debugger 窗口中查看到和修改。如果勾选 Mouse Select，则会开启鼠标悬停和鼠标选择功能，方便查看碰撞几何体。</p>\n<p>点击右上方的 Reset 可以重置 Physics Debugger 窗口中的设置。</p>\n<ul>\n<li>Selected Object Info 表示当前选中的游戏对象的信息。</li>\n<li>Show Physics Scene 表示要在哪些场景中显示碰撞几何体。</li>\n<li>Show Layers 表示哪些 Layer 层的游戏对象要显示碰撞几何体。</li>\n<li>Show Static Colliders 表示显示静态的碰撞器组件的范围。</li>\n<li>Show Triggers 表示显示勾选了 Is Trigger 属性的碰撞器的范围。</li>\n<li>Show Rigidbodies 表示显示 Rigidbody 组件的范围。</li>\n<li>Show Kinematic Bodies 表示显示勾选了 Is Kinematic 的 Rigidbody 组件的范围。</li>\n<li>Show Articulation Bodies 表示显示 Articulation Body 组件的范围。Articulation Body 组件用于模拟机器人、车辆等物体的关节行为。例如可以实现机器人的动作、车辆的悬挂等物理效果。</li>\n<li>Show Sleeping Bodies 表示显示处于睡眠状态的 Rigidbody 组件的范围。当一个刚体在一段时间内没有受到外力作用，则会自动进入睡眠状态，进入睡眠状态的刚体不会参与物理模拟。当它再次受到外力的作用时，它就会从睡眠状态中唤醒，此时就又会重新参与物理模拟了。</li>\n</ul>\n<p>Collider Types</p>\n<ul>\n<li>Show BoxColliders 表示显示盒子碰撞器的范围。</li>\n<li>Show SphereColliders 表示显示球体碰撞器的范围。</li>\n<li>Show CapsuleColliders 表示显示胶囊体碰撞器的范围。</li>\n<li>Show MeshColliders (convex) 表示显示网格碰撞器的范围。</li>\n<li>Show MeshColliders (concave) 表示显示网格碰撞器的范围。</li>\n<li>Show Terrain Colliders 表示显示地形碰撞器的范围。</li>\n</ul>\n<p>Colors</p>\n<ul>\n<li>Static Colliders 表示显示静态的碰撞器的颜色。</li>\n<li>Triggers 表示显示勾选了 Is Trigger 属性的碰撞器的颜色。</li>\n<li>Rigidbodies 表示显示 Rigidbody 组件的颜色。</li>\n<li>Kinematic Bodies 表示显示勾选了 Is Kinematic 的 Rigidbody 组件的颜色。</li>\n<li>Articulation Bodies 表示显示 Articulation Body 组件的颜色。</li>\n<li>Sleeping Bodies 表示显示处于睡眠状态的 Rigidbody 组件的颜色。</li>\n<li>Variation 表示要显示的颜色与随机颜色混合的程度。调节这个变量，会影响所有显示的几何碰撞体的颜色。</li>\n</ul>\n<p>Rendering</p>\n<ul>\n<li>Transparency 控制绘制的碰撞几何体的透明度。</li>\n<li>Force Overdraw，勾选后，绘制的碰撞集合体会更加清晰。</li>\n<li>View Distance 控制能在 Scene 窗口中看到碰撞几何体的距离。</li>\n<li>Terrain Tiles Max 控制能在 Scene 窗口中看到 Unity 自带的地形系统 Terrain 的瓦片的最大数量。</li>\n</ul>\n<h2 id=\"unity-import-activity-窗口\"><a class=\"anchor\" href=\"#unity-import-activity-窗口\">#</a> Unity Import Activity 窗口</h2>\n<p><mark>Import Activity 可以查看项目中的资源的信息。例如什么时候导入这个资源的、这个资源的文件大小等</mark>。</p>\n<p>打开方法：</p>\n<ul>\n<li>Window——Analysis——Import Activity</li>\n<li>右击一个资源，点击 View in Import Activity Window。</li>\n<li>在 Inspector 窗口中右击 Inspector，点击 Open in Import Activity Window。</li>\n</ul>\n<p>官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9JbXBvcnRBY3Rpdml0eVdpbmRvdy5odG1s\">https://docs.unity3d.com/2021.2/Documentation/Manual/ImportActivityWindow.html</span></p>\n<p>点击左上方的 Show Overview 可以看出项目中依赖最多的资源和导入时花费时间最长的资源。</p>\n<p>左上方 Options 的选项</p>\n<ul>\n<li>Use relative timestamps：勾选后，资源的最后导入时间会以 “几小时前”、“几天前” 这样的格式显示。取消勾选，则资源的最后导入时间会以 “日 - 月 - 年小时：分钟：秒” 的格式显示。</li>\n<li>Show previous imports：勾选后，选中一个资源，则会显示这个资源以前导入时的信息，也能在 Library 文件夹中查看一个资源有多少个历史版本。但是要注意，当 Unity 的 AGC（Artifact Garbage Collection）运行时，或者重新启动 Unity 时，以前导入的资源的信息会被清空掉。如果要关闭 AGC 的执行，则可以取消勾选 “Edit——Project Settings——Editor——Remove unused Artifacts on Restart”，也可以在脚本中通过 EditorUserSettings.artifactGarbageCollection 来禁用它。</li>\n<li>Include PreviewImporter：勾选后，会包含由预览窗口生成的 Artifacts。</li>\n</ul>\n<p>右上方的搜索框可以搜索项目中的资源。</p>\n<p>左侧的 Asset 表示资源，Last Import 表示最后一次导入这个资源是在什么时候，Duration (ms) 表示最后一次导入这个资源时花费了多少毫秒才将它导入到项目中。</p>\n<ul>\n<li>选中一个资源后，可以在右侧看到它的信息。</li>\n<li>点击 Asset，Project 窗口会在项目中定位到该资源存放的位置。</li>\n<li>GUID 表示 Unity 分配给这个资源的全局唯一标识。</li>\n<li>Asset Size 表示这个资源的文件大小。</li>\n<li>Path 表示这个资源在项目中的路径。</li>\n<li>Editor 表示是 Unity 的哪个版本创建这个资源的 Artifact 的。</li>\n<li>Timestamp 表示这个资源的 Artifact 被创建时的时间，它对应 Library 文件夹中指定文件的 Timestamp 的值。</li>\n<li>Duration 表示导入这个资源所花费的时间。</li>\n<li>Reason for import 表示导入原因，即这个资源最近重新导入的描述，以及这个资源相关依赖类型的详细信息。当导入原因有多个是，可以用搜索栏进行查找。</li>\n<li>Produced Files/Artifacts 表示这个资源最后一次导入 Unity 时，在 Library 文件夹中呈现的 Artifact 的路径。通常每个资产只有一个 Artifact，有时也可能有多个。</li>\n<li>Dependencies 表示这个资源依赖的其它资源，如果修改它们，可能会导致这个资源被重新导入到 Unity。如果 Dependencies 的数量过多，可以使用搜索栏查找。</li>\n</ul>\n<h2 id=\"unity-code-coverage-窗口\"><a class=\"anchor\" href=\"#unity-code-coverage-窗口\">#</a> Unity Code Coverage 窗口</h2>\n<p><mark>Code Coverage 用来评估我们编写的代码，在游戏测试运行的时候有多少被执行了</mark>。如果有一部分代码没有被执行，我们就要考虑是不是我们代码的逻辑有问题，从而改进我们的代码。</p>\n<p>打开方法：Window——Analysic——Code Coverage</p>\n<p>官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL1BhY2thZ2VzL2NvbS51bml0eS50ZXN0dG9vbHMuY29kZWNvdmVyYWdlQDEuMS9tYW51YWwvaW5kZXguaHRtbA==\">https://docs.unity.cn/Packages/com.unity.testtools.codecoverage@1.1/manual/index.html</span></p>\n<p>使用思路：</p>\n<p>先勾选 Enable Code Coverage，然后勾选 Auto Generate Report，再点击 Start Recording 按钮，接着点击播放按钮运行游戏。点击 Start Recording 按钮后，它会变成 Stop Recording，测试完毕后点击它，就会停止测试。然后我们就可以在 Result Location 的路径找到生成的报告，从中看出在测试的时候有多少代码被执行了。</p>\n<ul>\n<li>Results Location 表示生成的报告要存放到的路径。</li>\n<li>History Location 表示生成的报告的历史记录要存放到的路径。必须勾选了 Generate History 才会生成。</li>\n<li>Enable Code Coverage 表示启用代码覆盖，测试之前要勾选它。</li>\n<li>Included Assemblies 表示测试的时候要考虑哪些程序集的代码。</li>\n<li>Included Paths 表示测试的时候要考虑哪些文件夹或文件中的代码。</li>\n<li>Excluded Paths 表示测试的时候不考虑哪些文件夹或文件中的代码。</li>\n<li>Generate HTML Report，勾选后，生成报告时，会以 html 的格式来生成报告。如果取消勾选，则会以其它形式来生成报告，但是这样不方便我们观看。建议勾选。</li>\n<li>Generate Summary Badges，勾选后，生成的报告的文件夹中，会额外生成.svg 和.png 后缀的文件，概括这次测试中有百分之几的代码被使用了。</li>\n<li>Generate History，勾选后，生成报告时，会自动在 History Location 的路径生成历史记录。</li>\n<li>Generate Additional Metrics，勾选后，生成报告时，报告中会有额外的衡量指标。</li>\n<li>Auto Generate Report，勾选后，我们点击 Start Recording 开始测试，然后点击 Stop Recording 结束测试后，会自动在 Results Location 的路径生成报告。</li>\n<li>Clear Data 清空上一次测试的数据。</li>\n<li>Clear History，清空 History Location 路径中的所有历史记录。</li>\n<li>Generate from Last，根据上一次测试的数据，在 Results Location 的路径生成报告。</li>\n<li>Start Recording，开始测试。</li>\n</ul>\n<h2 id=\"unity-profile-analyzer-窗口\"><a class=\"anchor\" href=\"#unity-profile-analyzer-窗口\">#</a> Unity Profile Analyzer 窗口</h2>\n<p>Profile Analyzer 配合 Profiler 使用。当我们使用 Profiler 收集了数据之后，不要关闭 Profiler，并且打开 Profile Analyzer，把 Profiler 收集的数据导入到 Profile Analyzer，<mark>使用 Profile Analyzer 可以帮助我们选出一段数据中最具有代表性的一帧，方便我们进行性能分析。也能看出收集的数据整体的一些情况，例如中位数、平均值、最大值、最小值等</mark>。</p>\n<p>Profile Analyzer 也可以比较两段数据的性能开销。</p>\n<p>打开方法：Window——Analysis——Profile Analyzer</p>\n<p>官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5wZXJmb3JtYW5jZS5wcm9maWxlLWFuYWx5emVyQDEuMi9tYW51YWwvaW5kZXguaHRtbA==\">https://docs.unity3d.com/Packages/com.unity.performance.profile-analyzer@1.2/manual/index.html</span></p>\n<p>Profile Analyzer 要配合 Profiler 使用，点击 Open Profiler Window 可以打开 Profiler，此时 Open Profiler Window 会变成 Close Profiler Window，点击 Close Profiler Window 会关闭打开的 Profiler</p>\n<p><mark>左上方的 Mode 有两种模式，选择 Single 会分析一段数据，选择 Compare 会分析两段数据，可以对这两段数据作对比。</mark></p>\n<p>左上方的 Export 可以把分析的结果导出到本地，以便我们查看。</p>\n<p>在 Profiler 收集了一段数据之后，可以点击 Profile Analyzer 中的 Pull Data，这样就会导入那段数据到 Profile Analyzer，方便我们分析。点击 Save，则会把数据保存到本地，点击 Load，则可以从本地载入数据。</p>\n<p>在上方的图表中，我们可以拖选其中的一段数据，然后在下方的 Top 10 markers on median frame 下看到最具有代表性的一帧，<mark>点击它，则 profiler 窗口中也会自动选中那一帧</mark>。</p>\n<p>Top 10 markers on median frame 下方右侧是 10 个最具有代表性的 Marker。</p>\n<p><mark>Marker 表示代码的标记</mark>。Unity 执行的一些关键的方法或者一段关键的代码会被标记，方便我们查看这些方法和代码的性能。</p>\n<p>此时在下方的 Marker Details for current selected range 下方可以看到选中的这段数据的信息。</p>\n<ul>\n<li>Filters 的选项用于对数据进行筛选。</li>\n<li>Name Filter 表示筛选含有指定字符串的结果。</li>\n<li>Exclude Names 表示筛选不含有指定字符串的结果。</li>\n<li>Thread 表示筛选指定线程的结果</li>\n<li>Depth Slice 表示筛选指定调用栈的深度。</li>\n<li>点击 Analyze，则会根据 Filters 的选项的设置重新进行分析，可以在下方的 Marker Details for currently selected range 的下方看到结果。</li>\n</ul>\n<h2 id=\"unity-imgui-debugger-窗口\"><a class=\"anchor\" href=\"#unity-imgui-debugger-窗口\">#</a> Unity IMGUI Debugger 窗口</h2>\n<p><mark>IMGUI Debugger 窗口用于查看 Unity 编辑器中的 IMGUI 控件的信息</mark>。例如 Scene 窗口、Game 窗口实际上也是用 IMGUI 写的，我们可以查看其中 IMGUI 控件的信息。</p>\n<p><mark>如果我们在 OnGUI 方法中写了代码来显示 IMGUI 控件，也可以在 IMGUI Debugger 窗口查看这个 IMGUI 控件的信息。</mark></p>\n<p>打开方法：</p>\n<ul>\n<li>Window——Analysis——IMGUI Debugger</li>\n<li>Alt+5</li>\n</ul>\n<p>在 &lt;Please Select&gt; 和它右边的下拉菜单中，可以选择要查看哪些 IMGUI 控件。</p>\n<p>Show Overlay。启用 Show Overlay，则选择 IMGUI 控件时，能在 Unity 的编辑器中看到选择了哪个控件。</p>\n<p>Force Inspect Optimized GUI Blocks。有时候 Unity 可能会对 IMGUI 进行优化，把多个 IMGUI 控件合并为一个。此时如果我们要查看每一个 IMGUI 控件的信息，则可以启用 Force Inspect Optimized GUI Blocks</p>\n<p>Pick Style。按住 Pick Style，然后在 Unity 的编辑器中选择一个 IMGUI 控件，可以看到它的信息。</p>\n",
            "tags": [
                "Unity3D",
                "Unity3D"
            ]
        },
        {
            "id": "https://blog.aayu.today/feature/unity/20231004/",
            "url": "https://blog.aayu.today/feature/unity/20231004/",
            "title": "Unity3D优化笔记（3）性能分析器Profiler",
            "date_published": "2023-10-04T15:08:07.000Z",
            "content_html": "<p>Profiler 窗口就是性能分析器的窗口，用来详细分析游戏性能。</p>\n<p>打开 Profiler 窗口的方法：</p>\n<ul>\n<li>Window——Analysis——Profiler</li>\n<li>Ctrl+7</li>\n</ul>\n<p>使用性能分析器进行分析时，其自身也是会消耗性能的。如果想获得更加准确的数据，可以使用独立性能分析器，即 Profiler (Standalone Process)。</p>\n<p>打开 Profiler (Standalone Process) 窗口的方法：</p>\n<ul>\n<li>Window——Analysis——Profiler(Standalone Process)</li>\n</ul>\n<p>独立性能分析器的运行不会影响收集的数据，因此可以获得更加准确的数据。它的用法和 Profiler 窗口相同，但是启动它的时间比打开 Profiler 窗口的时间长。</p>\n<h2 id=\"基本使用\"><a class=\"anchor\" href=\"#基本使用\">#</a> 基本使用</h2>\n<p>打开 Profiler 窗口后，运行 Unity，再点击 Profiler 窗口上方的圆形按钮，就会开始收集当前开始的每一帧的性能，再点一下那个圆形按钮，则会停止收集，此时就可以双击右上部分的一个位置选中一帧，然后看这一帧的情况，一般我们可以选择波峰的一帧，这样容易看出性能开销大的原因。也可以推动时间轴，或者点击上方圆形按钮右侧的三个按钮，查看其它帧的情况。上方的 Frame 表示当前正在查看的帧数以及收集的总帧数，例如 Frame:738/963 表示一共收集了 963 帧，当前查看的是第 738 帧。</p>\n<p>每一项左侧的颜色方块表示该项是显示的，如果<mark>点击颜色方块，则右侧会隐藏该项的数据</mark>。</p>\n<p>如果不要显示某个模块的数据，可以点击左上角的 “Profiler Modules”，取消勾选它，这样在性能分析器收集数据的时候，也不会收集这些数据，可以减少性能分析器的开销。如果要重新显示某个模块的数据，则勾选它即可。点击 Restore Defaults 会恢复默认的设置。</p>\n<p>如果要清除当前收集的所有帧的数据，则可以点击上方的 “Clear”。再次点击 Profiler 窗口上方的圆形按钮，就会开始收集当前开始的每一帧的性能，再点一下那个圆形按钮，则会停止收集，此时就可以双击右上部分的一个位置选中一帧，然后看这一帧的情况。</p>\n<p>选中一帧后，除了可以在右侧看到这一帧的情况，还可以在下方看到这一帧更加具体的情况。</p>\n<p><mark>要找出造成性能开销的因素，可以尝试禁用场景中的游戏对象。如果禁用后，看到性能提升了，则说明问题出在这个游戏对象身上，优化的时候就可以从它身上下手。</mark></p>\n<ul>\n<li>点击圆形按钮左侧的下拉菜单，可以选择分析什么的性能。如果选择 Play Mode，则会分析游戏在运行时的性能，如果选择 Edit Mode，则会分析编辑器模式下游戏的性能。</li>\n<li>如果用手机的数据线成功连接到电脑，<mark>在手机上运行 Unity 的游戏，Play Mode 这里会多出该手机设备供我们选择，我们就可以分析该手机设备上运行的 Unity 项目的性能</mark>。</li>\n<li><mark>也可以让手机和电脑都连接同一个 wifi</mark>，这样一来，这里也会多出该手机设备供我们选择，我们就可以分析该手机设备上运行的 Unity 项目的性能。</li>\n<li>注意，无论是用 wifi 还是数据线，<mark>构建项目时必须在 Build Settings 窗口中勾选 Development Build 和 Autoconnect Profiler</mark>。</li>\n</ul>\n<p>选择上方的 Clear on Play，则在每次重新运行游戏的时候，都会清空收集的数据，以便我们重新开始收集这一次的数据。</p>\n<p>如果要保存收集到的数据到本地，方便之后查看，<mark>可以点击右上方的图标来保存。右上方也有一个图标可以读取之前保存的数据</mark>。</p>\n<h2 id=\"添加自定义模块\"><a class=\"anchor\" href=\"#添加自定义模块\">#</a> 添加自定义模块</h2>\n<p>点击小齿轮，再点击 Add，可以自定义一个新的模块，并自定义这个模块要分析的性能，且可以在上方的输入框处改名，然后点击 Save Changes 可以保存。如果要删除它，则点击 Delete Module 即可删除它，同样，点击 Save Changes 可以保存。</p>\n<p>​<img data-src=\"assets/image-20231003185643-whabbez.png\" alt=\"image\" />​</p>\n<h2 id=\"deep-profile\"><a class=\"anchor\" href=\"#deep-profile\">#</a> Deep Profile</h2>\n<p>选择上方的 Deep Profile，然后重新启动性能分析器，则性能分析器收集数据的时候，<mark>会把所有 C# 代码中的方法的信息也收集过来</mark>。例如我们自己写的 C# 脚本，里面的方法只要被调用了，就会被收集过来，方便我们从性能分析器查看它们的性能。<mark>在 Profiler 窗口选择 CPU Usage 模块，选中一帧，然后在下面选择 Hierarchy，右侧选择 Main Thread，再在右侧的搜索栏处搜索该方法的名字，就可以找到它，并查看它的性能。</mark></p>\n<p>​<img data-src=\"assets/image-20231003203610-ho2ie4o.png\" alt=\"image\" />​</p>\n<p>当开启深度分析后，性能分析器就会捕捉每个函数所占用的资源，包括本身执行的时间和函数内部再调用其他函数消耗的时间等等</p>\n<p><mark>However，如果在一个大项目里开启深度分析，由于需要监测每个函数占用的资源，所以可能会造成性能分析器卡顿，甚至崩溃。Therefore，不建议在大型形目里开启 Deep Profile</mark></p>\n<p>更优的做法是使用  <code>Profiler.BeginSample</code> ​ 和  <code>Profiler.EndSample</code> ​ 方法括住需要性能分析的代码进行分析即可</p>\n<pre><code class=\"language-c#\">void TestHaha()\n&#123;\n\tProfiler.BeginSample(&quot;MyHaha&quot;);\n\n\t// Your code\n\n\tProfiler.EndSample();\n&#125;\n</code></pre>\n<h2 id=\"调用栈call-stack\"><a class=\"anchor\" href=\"#调用栈call-stack\">#</a> 调用栈（Call Stack）</h2>\n<p>调用栈（Call Stack）是计算机程序在执行过程中记录函数调用的一种数据结构。</p>\n<p>调用栈是一个栈结构，即先进后出。它用于记录程序执行过程中，每个函数被调用的情况。</p>\n<p>当一个函数被调用时，它的相关信息，如函数名、参数、返回地址等，会被添加进调用栈中。当该函数执行完成后，相应的信息会从调用栈中移除。通过不断添加和移除函数调用的信息，调用栈就记录了程序执行的顺序。</p>\n<p>调用栈对于程序调试和分析非常有用。当程序出现错误或异常时，可以通过查看调用栈来确定错误发生的位置和函数调用的顺序。调试器通常会显示当前调用栈的信息，以帮助开发人员查看函数的执行过程并找出发生异常的原因。</p>\n<p>选中 Deep Profile 右侧的 Call Stacks 按钮，这样在收集性能数据的时候，每一帧都会记录该方法的的调用栈信息。GC.Alloc、UnsafeUtility.Malloc、JobHandle.Complete 是 Unity 的方法，启用 Call Stacks 且勾选它们后，如果 Unity 有调用它们，则可以在 Hierarchy 或 Raw Hierarchy 右侧的搜索框中搜索到它们，这样就可以查看它们的性能了。</p>\n<ul>\n<li>GC.Alloc 表示 GC 的内存分配情况。</li>\n<li>UnsafeUtility.Malloc (Persistent) 用于在内存中分配指定大小的未初始化内存块。这个方法会直接在堆上分配内存，并可以绕过自动内存管理功能，需要手动管理内存的生命周期和释放。一般情况下，只有在处理非托管内存的特定场景下才会使用 UnsafeUtility.Malloc 方法。</li>\n<li>JobHandle.Complete 表示 Job 的完成情况。这里的 Job 是指 Unity 的 Job System 的一组特定的任务。</li>\n</ul>\n<h2 id=\"c-托管内存-非托管内存-托管堆\"><a class=\"anchor\" href=\"#c-托管内存-非托管内存-托管堆\">#</a> C# 托管内存、非托管内存、托管堆</h2>\n<p><mark>托管内存是由垃圾回收器自动管理的内存</mark>，当达到一定量时，会由垃圾回收器自动释放它们。</p>\n<p><mark>托管内存存放在托管堆中。托管堆是一种用于存储和管理托管对象的内存区域</mark>。每当创建一个新的托管对象时，托管堆就会分配内存空间给这个对象，并记录这个对象的信息。当托管对象不再被引用，垃圾回收器会自动将其标记为垃圾，并在适当的时候回收其占用的内存空间。</p>\n<p><mark>非托管内存不会自动被回收，它们需要我们程序员写代码去管理和释放它们。</mark></p>\n<p>非托管内存并不固定存储在一个地方，它们往往分散存储在不同的地方，例如操作系统的内存、临时缓冲区等。</p>\n<h2 id=\"unity-dtos\"><a class=\"anchor\" href=\"#unity-dtos\">#</a> Unity DTOS</h2>\n<p>DOTS（Data-Oriented Technology Stack）是 Unity 引擎中的一个新的编程模型和工具集。它旨在提供更高性能、更可扩展和更并行化的游戏开发体验。</p>\n<p>DOTS 中包含了三个主要部分：</p>\n<p>1、ECS 框架：ECS 是一种用于组织和管理游戏对象的方式。它将游戏对象分解为实体（Entity）、组件（Component）和系统（System）。这种模式更加适合于并行处理和优化，可以提高游戏性能。</p>\n<p>2、Job System（作业系统）：Job System 允许开发者将任务并行化，利用多核处理器的能力。它通过将任务划分为小的作业（jobs）并在多个线程上并发执行来提高性能。Job System 还可以与 ECS 结合使用，使得开发者可以更好地控制游戏的行为。</p>\n<p>3、Burst Compiler（突发编译器）：Burst Compiler 是一种高性能的 C# 编译器，可以将 C# 代码转换为高效的本机代码，以进一步提高游戏的性能。</p>\n<p>DOTS 的目标是为游戏开发者提供更好的性能和可扩展性，并更好地利用现代硬件的并行能力。它适用于需要处理大量实体和需要高性能的游戏项目。</p>\n<h2 id=\"其他\"><a class=\"anchor\" href=\"#其他\">#</a> 其他</h2>\n<p>点击右上角的三点，有一些选项可以选择。</p>\n<ul>\n<li>\n<p>Color Blind Mode 表示色盲模式，开启后会调整 Profile 窗口的颜色，照顾色盲用户。</p>\n</li>\n<li>\n<p>Show Stats for 'current frame' 开启后，当点击 Frame:XXX/XXX 左侧的按钮，从而选中最后一帧，则会显示最后一帧的统计信息。</p>\n</li>\n<li>\n<p>Preferences，点击后会打开 Project Settings 窗口，用于设置性能分析器的一些属性。</p>\n<ul>\n<li>Frame Count，开始收集性能的数据时，每次最多可以查看多少帧。例如数值是 300，则表示最多可以查看 300 帧。</li>\n<li>Show Stats for 'current frame'，勾选后，则在右上角的三点会出现 Show Stats for 'current frame' 供我们选择。</li>\n<li>Default recording state，选择 Enable，则重启 Unity 再打开 Profiler 窗口，如果此时的模式是 Edit Mode，则会自动开始点击圆形按钮，开始收集数据。选择 Disabled，则重启 Unity 再打开 Profiler 窗口，需要手动点击圆形按钮，才会开始收集数据。选择 Remember，则会按照当前圆形按钮是启用还是禁用来决定下一次重启 Unity 再打开 Profiler 窗口时，该圆形按钮是否启用。</li>\n<li>Default editor target mode on start，选择 Play Mode，则重启 Unity 再打开 Profiler 窗口，左上方会选择 Play Mode，即在播放模式下才会收集数据。如果选择 Edit Mode，则重启 Unity 再打开 Profiler 窗口，左上方会选择 Edit Mode，即在编辑器模式下收集数据。</li>\n<li>Custom connection ID，当有多个 Unity 项目的实例同时运行，它们都要使用性能分析器来分析性能，则可以通过这个 Custom connection ID 来区分它们。</li>\n</ul>\n</li>\n</ul>\n<p>CPU Usage 模块：</p>\n<ul>\n<li>下方窗口可以选择 Timeline、Hierarchy、Raw Hierarchy。</li>\n<li>选择 Timeline，可以通过时间轴的方式查看这一帧中 CPU 依次干了什么。</li>\n<li>选择 Hierarchy，可以查看 CPU 在这一帧中做的事情所消耗的性能和所花费的时间。Total 表示一共占用了 CPU 使用情况的百分之几。Self 表示自身的代码占用了 CPU 使用情况的百分之几，调用其它方法的代码不算在内的。Calls 表示被调用了几次。GC Alloc 表示 GC 分配的内存，当一个对象被释放后，它 GC 分配的内存不会马上被回收，所有 GC 分配的内存的总量达到一定程度，会触发 GC，此时垃圾回收器才会把这些内存回收，不过同时也会造成游戏卡一下。Time ms 表示一共耗时多少毫秒。Self ms 表示表示自身的代码耗时多少毫秒，调用其它方法的代码不算在内的。</li>\n<li>选择 Raw Hierarchy 比起 Hierarchy 会单独列出更多信息，Hierarchy 实际上是把这些信息合并了。</li>\n</ul>\n",
            "tags": [
                "Unity3D",
                "Unity3D"
            ]
        },
        {
            "id": "https://blog.aayu.today/feature/unity/20231002/",
            "url": "https://blog.aayu.today/feature/unity/20231002/",
            "title": "Unity3D优化笔记（2）垂直同步，屏幕分辨率，网格",
            "date_published": "2023-10-02T15:34:17.000Z",
            "content_html": "<h2 id=\"垂直同步\"><a class=\"anchor\" href=\"#垂直同步\">#</a> 垂直同步</h2>\n<p>垂直同步用于将游戏的帧率限制为显示器的刷新率，可以防止游戏画面在高速移动时的画面撕裂现象，使游戏画面更加平滑和连贯。</p>\n<p>如果不启用垂直同步，当游戏的帧率高于显示器的刷新率时，<mark>图像的一部分可能会在显示器刷新之前更新</mark>，导致画面上出现明显的断裂线。而启用垂直同步后，图形处理器会等待显示器完成一次完整的刷新，然后再发送下一帧图像，确保每个图像帧都在刷新之前完全绘制，从而消除了撕裂现象。</p>\n<p>简单理解的话，<mark>当显示器比如说要渲染 A 帧画面时，渲染到一半，由于游戏的帧率高于显示器的刷新率，所以 A 帧数据被更新，然后显示器就渲染更新后的数据了</mark>，可能会导致画面上出现断裂线和不连续。</p>\n<p>但是启用垂直同步会消耗一些性能，也可能会出现卡顿的现象，要根据自己的实际情况来决定是否启用。</p>\n<h2 id=\"屏幕分辨率\"><a class=\"anchor\" href=\"#屏幕分辨率\">#</a> 屏幕分辨率</h2>\n<ul>\n<li>\n<p>设置屏幕分辨率的方法 1：</p>\n<ul>\n<li>Game 窗口上方可以找到对应的下拉菜单，点开它，即可以选择屏幕分辨率。</li>\n<li>VSync（Game view only）表示垂直同步，勾选后，也只能在播放模式下的 Game 窗口才可能看出效果。</li>\n<li>点击下面的 + 号可以添加自定义的屏幕分辨率。Label 表示自定义的名字。Type 选择 Fixed Resolution，则该分辨率是固定的，即使缩放游戏窗口，该分辨率也是固定的。</li>\n<li><mark>Type 选择 Aspect Ratio，缩放游戏窗口时，该分辨率会随着窗口的缩放而变化，但是仍会维持指定的纵横比</mark>。</li>\n<li>右击一个屏幕分辨率，可以编辑和删除它。</li>\n</ul>\n</li>\n<li>\n<p>设置屏幕分辨率的方法 2：</p>\n<ul>\n<li>通过代码 <mark>Screen.SetResolution</mark> 方法可以设置屏幕分辨率</li>\n</ul>\n</li>\n<li>\n<p>设置游戏启动时的默认屏幕分辨率：</p>\n<ul>\n<li>Edit——Project Settings——Player—— 展开 Resolution and Presentation 下拉菜单 —— 取消勾选 Default Is Native Resolution—— 写上所需的屏幕宽度和屏幕高度</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"网格mesh\"><a class=\"anchor\" href=\"#网格mesh\">#</a> 网格（Mesh）</h2>\n<p>网格用来定义一个模型的形状、大小和表面细节等信息。</p>\n<p><mark>模型的所有顶点、线、面共同构成了这个模型的网格</mark>。</p>\n<h2 id=\"蒙皮网格skinned-mesh\"><a class=\"anchor\" href=\"#蒙皮网格skinned-mesh\">#</a> 蒙皮网格（Skinned Mesh）</h2>\n<p>蒙皮网格是一个与骨骼绑定的网格，这个网格可以发生形变和做出各种动作。</p>\n<p><mark>一个网格在没有蒙皮之前是不能发生形变的，也不能做出各种动作的</mark>。但是在成功蒙皮之后，这个网格就可以发生形变和做出各种动作。</p>\n",
            "tags": [
                "Unity3D",
                "Unity3D"
            ]
        },
        {
            "id": "https://blog.aayu.today/feature/unity/20231001/",
            "url": "https://blog.aayu.today/feature/unity/20231001/",
            "title": "Unity3D优化笔记（1）Stats窗口的作用",
            "date_published": "2023-10-01T15:54:24.000Z",
            "content_html": "<p><img data-src=\"https://image.aayu.today/uploads/2023/10/01/202310012355561.png\" alt=\"\" /></p>\n<p>通过 Stats 窗口可以初步查看游戏运行时，当前一帧的各项性能。</p>\n<p>Stats 是英文单词 Statistics 的缩写，意思是 “统计数据”。</p>\n<p>打开方法：Game 窗口右上角，找到 Stats，点击它。</p>\n<h2 id=\"unity-绘制调用draw-call-批次batch\"><a class=\"anchor\" href=\"#unity-绘制调用draw-call-批次batch\">#</a> Unity 绘制调用（Draw Call）、批次（Batch）</h2>\n<p>要将游戏中的物体显示到屏幕上，就需要绘制它们。绘制之前，会先由 CPU 计算出它们的位置、颜色等信息，然后发送绘制指令给 GPU。GPU 接受到 CPU 发过来的绘制指令，就会按照要求绘制东西在屏幕上。</p>\n<p>Draw Call 是指 CPU 向 GPU 发送绘制指令的过程，<mark>一个 Draw Call 就是 CPU 向 GPU 发送的一组绘制指令</mark>，可以绘制出一个或多个物体。</p>\n<p>Draw Call 有时也被简称为 DC</p>\n<p>Draw Call 太多会使游戏变卡，优化的时候可以想办法降低 Draw Call。</p>\n<p>要降低 Draw Call，可以使用合批技术，例如动态合批和静态合批。将多个 Draw Call 合批成一个批次（Batch），再由 CPU 发送给 GPU，这样可以提升游戏性能。</p>\n<h2 id=\"audio-表示音频的数据\"><a class=\"anchor\" href=\"#audio-表示音频的数据\">#</a> Audio 表示音频的数据</h2>\n<ul>\n<li>\n<p>Level 表示<mark>声音强度</mark>，单位是分贝，也就是 dB。声音太大或太小都会影响玩家体验。</p>\n<ul>\n<li>应将这项数据控制在一个合适的范围内。</li>\n</ul>\n</li>\n<li>\n<p>DSP load 表示<mark>数字信号处理器的负载</mark>。播放的声音越多、声音的采样率越高、声音效果越复杂，本变量的数值都会越大。</p>\n<ul>\n<li>应尽量避免这项数据过大。</li>\n</ul>\n</li>\n<li>\n<p>Clipping 表示<mark>音频的裁剪情况</mark>。当音频信号超过设备支持的最大范围时，该音频信号会被裁剪。裁剪之后，该音频会出现一定程度失真的现象。</p>\n<ul>\n<li>应尽量避免这项数据过大。</li>\n</ul>\n</li>\n<li>\n<p>Stream load 表示<mark>音频流的负载情况</mark>。音频的流式加载是指以持续的方式从音频源获取音频数据，而不是一次性加载全部数据。流式加载的主要优势是可以实时地处理和播放音频，无需等待全部数据加载完成。</p>\n<ul>\n<li>应尽量避免这项数据过大。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"graphics-表示图像的数据\"><a class=\"anchor\" href=\"#graphics-表示图像的数据\">#</a> Graphics 表示图像的数据</h2>\n<ul>\n<li>\n<p>FPS 表示<mark>帧率</mark>，也就是 1 秒内播放多少帧。可以用来判断游戏运行得是否流畅。</p>\n<ul>\n<li>例如 209.5FPS（4.8ms）表示平均每秒播放 209.5 张画面，平均每 4.8 毫秒播放一张画面。</li>\n<li>游戏画面、视频画面都是由一张张静态的画面连续播放而成的，1 帧就是一张静态的画面。60FPS 是很流畅的，45FPS 比较流畅，30FPS 会明显感到卡顿。</li>\n<li>应将这项数据控制在一个合适的范围内。</li>\n</ul>\n</li>\n<li>\n<p>CPU 的指标表示 <mark>CPU 处理一帧的时间</mark>。</p>\n<ul>\n<li>例如 CPU:main 4.6ms render thread 0.5ms 表示 Unity 的主线程处理这一帧所花费的时间是 4.6 毫秒，主线程主要负责游戏逻辑的更新，例如检测用户的输入、更新游戏对象的位置、碰撞检测等。在渲染线程处理这一帧所花费的时间是 0.5 毫秒，渲染线程负责显示游戏画面。</li>\n<li>应尽量避免这项数据过大。</li>\n</ul>\n</li>\n<li>\n<p>Batches 表示<mark>处理的绘制调用（Draw Call）批次的总数</mark>。</p>\n<ul>\n<li>应尽量避免这项数据过大。</li>\n</ul>\n</li>\n<li>\n<p>Saved by batching 表示<mark>有多少个绘制调用（Draw Call）被合并到了批次</mark>。</p>\n<ul>\n<li>应尽量让这项数据大。</li>\n</ul>\n</li>\n<li>\n<p>Tris 表示<mark>当前摄像机视锥体的范围内三角面的个数</mark>。</p>\n<ul>\n<li>应尽量避免这项数据过大。</li>\n</ul>\n</li>\n<li>\n<p>Verts 表示<mark>当前摄像机视锥体的范围内网格顶点的个数</mark>。</p>\n<ul>\n<li>应尽量避免这项数据过大。</li>\n<li>在 3D 建模软件中创建的模型导入到 Unity 后，该模型在 Unity 中显示的三角面和网格顶点的数量和在 3D 建模软件中的可能不同。因为 3D 建模软件和 Unity 对模型的三角面和网格顶点的计算方式可能是不一样的。</li>\n</ul>\n</li>\n<li>\n<p>Screen 表示<mark>当前的屏幕分辨率</mark>，以及<mark>屏幕的内存占用量</mark>。例如 Screen：1920×1080 - 23.7MB 表示当前屏幕分辨率是 1920×1080，屏幕占用了 23.7MB 的内存。</p>\n<ul>\n<li>应尽量避免这项数据过大。</li>\n</ul>\n</li>\n<li>\n<p>SetPass calls 表示<mark>在当前摄像机的渲染过程中，Unity 切换着色器通道（Shader Pass）来渲染游戏对象的次数</mark>。一个着色器（Shader）可以包含多个着色器通道，每个着色器通道可以通过不同的方式来渲染游戏对象。<strong>但每次切换着色器通道都会消耗一定的性能</strong>。</p>\n<ul>\n<li>应尽量避免这项数据过大。</li>\n</ul>\n</li>\n<li>\n<p>Shadow casters 表示<mark>摄像机画面中有多少个游戏对象产生了阴影</mark>。同一个游戏对象产生较多的阴影，可能会被算作多个 Shadow casters</p>\n<ul>\n<li>应尽量避免这项数据过大。</li>\n</ul>\n</li>\n<li>\n<p>Visible skinned meshes 表示<mark>当前摄像机中有多少个可见的蒙皮网格</mark>。网格用来定义一个模型的形状、大小和表面细节等信息，模型的所有顶点、线、面共同构成了这个模型的网格。蒙皮网格是一个与骨骼绑定的网格，这个网格可以发生形变和做出各种动作。一个网格在没有蒙皮之前是不能发生形变的，也不能做出各种动作的。但是在成功蒙皮之后，这个网格就可以发生形变和做出各种动作。</p>\n<ul>\n<li>应尽量避免这项数据过大。</li>\n</ul>\n</li>\n<li>\n<p>Animator components playing 表示<mark>当前场景中有多少个 Animator 组件正在播放动画</mark>。播放动画会消耗性能。</p>\n<ul>\n<li>应尽量避免这项数据过大。</li>\n</ul>\n</li>\n<li>\n<p>Animation components playing 表示<mark>当前场景中有多少个 Animation 组件正在播放动画</mark>。播放动画会消耗性能。</p>\n<ul>\n<li>应尽量避免这项数据过大。</li>\n<li><strong>没用的 Animator 组件和 Animation 组件可以考虑删掉。因为即使只有空的动画，Animator 组件和 Animation 组件也会根据自己的工作流程进行每帧的计算和更新，以检查当前动画状态和过渡条件，这样就会消耗不必要的性能。</strong></li>\n</ul>\n</li>\n</ul>\n<p>‍</p>\n",
            "tags": [
                "Unity3D",
                "Unity3D"
            ]
        },
        {
            "id": "https://blog.aayu.today/hardware/stm32/20230829-2/",
            "url": "https://blog.aayu.today/hardware/stm32/20230829-2/",
            "title": "STM32学习笔记（2）标准库工程结构",
            "date_published": "2023-08-29T09:47:17.000Z",
            "content_html": "<blockquote>\n<p>STM32F1 系列标准库压缩包文件：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYW4uYWF5dS50b2RheS8/ZGlyPS8lRTUlQjglQjglRTclOTQlQTglRTglQkQlQUYlRTQlQkIlQjYlRTUlOTIlOEMlRTUlQjclQTUlRTUlODUlQjcvU1RNMzI=\">STM32F10x_StdPeriph_Lib_V3.5.0</span></p>\n</blockquote>\n<h2 id=\"新建工程步骤总结\"><a class=\"anchor\" href=\"#新建工程步骤总结\">#</a> 新建工程步骤总结</h2>\n<ul>\n<li>建立工程文件夹，Keil 中新建工程，选择型号</li>\n<li>工程文件夹里建立 Start、Library、User 等文件夹，复制固件库里面的文件到工程文件夹</li>\n<li>工程里对应建立 Start、Library、User 等同名称的分组，然后将文件夹内的文件添加到工程分组里</li>\n<li>工程选项，C/C++，Include Paths 内声明所有包含头文件的文件夹</li>\n<li>工程选项，C/C++，Define 内定义 USE_STDPERIPH_DRIVER</li>\n<li>工程选项，Debug，下拉列表选择对应调试器，Settings，Flash Download 里勾选 Reset and Run</li>\n</ul>\n<h2 id=\"启动文件\"><a class=\"anchor\" href=\"#启动文件\">#</a> 启动文件</h2>\n<p>位置： <code>STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\DeviceSupport\\ST\\STM32F10x\\startup\\arm</code> ​</p>\n<p>将 8 个启动文件全部放到自己工程的 Start 文件夹下（新建）</p>\n<p>​<img data-src=\"assets/image-20230829212143-5d0x0tp.png\" alt=\"image\" />​</p>\n<h2 id=\"外设描述文件和时钟配置文件\"><a class=\"anchor\" href=\"#外设描述文件和时钟配置文件\">#</a> 外设描述文件和时钟配置文件</h2>\n<p>位置： <code>STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\DeviceSupport\\ST\\STM32F10x</code> ​</p>\n<p>​<img data-src=\"assets/image-20230829212411-pm78zc6.png\" alt=\"image\" />​</p>\n<p>同样也是将这三个文件复制到自己工程的 Start 文件夹下</p>\n<h2 id=\"内核寄存器描述文件\"><a class=\"anchor\" href=\"#内核寄存器描述文件\">#</a> 内核寄存器描述文件</h2>\n<p>位置： <code>STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\CoreSupport</code> ​</p>\n<p>​<img data-src=\"assets/image-20230829212838-hqf1g5v.png\" alt=\"image\" />​</p>\n<p>同样也是将这两个文件复制到自己工程的 Start 文件夹下</p>\n<h2 id=\"配置-keil\"><a class=\"anchor\" href=\"#配置-keil\">#</a> 配置 Keil</h2>\n<h3 id=\"添加-start\"><a class=\"anchor\" href=\"#添加-start\">#</a> 添加 Start</h3>\n<p>修改组名，将特定启动文件、外设描述文件和时钟配置文件、内核寄存器描述文件添加进组里</p>\n<p>​<img data-src=\"assets/image-20230829213121-1vq46xa.png\" alt=\"image\" />​</p>\n<p>图标上带有小钥匙表明是个只读文件</p>\n<h3 id=\"配置头文件路径\"><a class=\"anchor\" href=\"#配置头文件路径\">#</a> 配置头文件路径</h3>\n<p>​<img data-src=\"assets/image-20230829213447-f4e3gcu.png\" alt=\"image\" />​</p>\n<h3 id=\"配置编码格式\"><a class=\"anchor\" href=\"#配置编码格式\">#</a> 配置编码格式</h3>\n<p>​<img data-src=\"assets/image-20230829215044-gs0iluz.png\" alt=\"image\" />​</p>\n<h3 id=\"自动代码补全\"><a class=\"anchor\" href=\"#自动代码补全\">#</a> 自动代码补全</h3>\n<p>​<img data-src=\"assets/image-20230829220157-37a9fqw.png\" alt=\"image\" />​</p>\n<h2 id=\"配置标准库\"><a class=\"anchor\" href=\"#配置标准库\">#</a> 配置标准库</h2>\n<p>位置： <code>STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\STM32F10x_StdPeriph_Driver\\src</code> ​</p>\n<p>​<img data-src=\"assets/image-20230829225009-nvrj73x.png\" alt=\"image\" /> 共 23 个文件，其中 misc.c 是内核的库函数，其他的就是内核外的外设库函数</p>\n<p>将全部文件复制到自己工程的 Library 文件夹下（新建）</p>\n<p>同理，将  <code>STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\STM32F10x_StdPeriph_Driver\\inc</code> ​ 位置下的头文件也复制到自己工程的 Library 文件夹下</p>\n<p>同理，将 Library 文件夹下加进来的 46 个文件添加到 Keil 工程新建 Library 组里</p>\n<p>除此之外，还需要将  <code>STM32F10x_StdPeriph_Lib_V3.5.0\\Project\\STM32F10x_StdPeriph_Template</code> ​ 位置下的  <code>stm32f10x_conf.h</code> ​、 <code>stm32f10x_it.c</code> ​、 <code>stm32f10x_it.h</code> ​ 三个文件复制到自己工程的 User 文件夹下（新建）</p>\n<p>同理，将自己工程的 User 文件夹添加到 Keil 工程新建 User 组里</p>\n<h3 id=\"设置宏编译\"><a class=\"anchor\" href=\"#设置宏编译\">#</a> 设置宏编译</h3>\n<p>在 User 组下创建 main.c 文件，第一行添加  <code>#include &quot;stm32f10x.h&quot;</code> ​，然后编译，编译后就可以跳转到  <code>stm32f10x.h</code> ​ 文件里了，在文件的底部可以看到宏判断</p>\n<p>​<img data-src=\"assets/image-20230829230237-napgeka.png\" alt=\"image\" />​</p>\n<p>所以需要在工程配置里添加这个宏，下面的  <code>User</code>  ​和  <code>Library</code>  ​目录也不要忘记添加到  <code>Include Paths</code> ​，即可完成使用标准库的配置</p>\n<p>​<img data-src=\"assets/image-20230829230313-7bdwc9w.png\" alt=\"image\" />​</p>\n<p>​<img data-src=\"assets/image-20230829230521-a8nrtvp.png\" alt=\"image\" />​</p>\n<h2 id=\"测试代码\"><a class=\"anchor\" href=\"#测试代码\">#</a> 测试代码</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"stm32f10x.h\"</span>                  <span class=\"token comment\">// Device header</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token function\">RCC_APB2PeriphClockCmd</span><span class=\"token punctuation\">(</span>RCC_APB2Periph_GPIOC<span class=\"token punctuation\">,</span> ENABLE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\tGPIO_InitTypeDef GPIO_InitStructure<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\tGPIO_InitStructure<span class=\"token punctuation\">.</span>GPIO_Mode <span class=\"token operator\">=</span> GPIO_Mode_Out_PP<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\tGPIO_InitStructure<span class=\"token punctuation\">.</span>GPIO_Pin <span class=\"token operator\">=</span> GPIO_Pin_13<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\tGPIO_InitStructure<span class=\"token punctuation\">.</span>GPIO_Speed <span class=\"token operator\">=</span> GPIO_Speed_50MHz<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token function\">GPIO_Init</span><span class=\"token punctuation\">(</span>GPIOC<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>GPIO_InitStructure<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token function\">GPIO_SetBits</span><span class=\"token punctuation\">(</span>GPIOC<span class=\"token punctuation\">,</span> GPIO_Pin_13<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t<span class=\"token comment\">//GPIO_ResetBits(GPIOC, GPIO_Pin_13);</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"启动文件选择讲解\"><a class=\"anchor\" href=\"#启动文件选择讲解\">#</a> 启动文件选择讲解</h2>\n<p>从表中可以看出我们的 STM32F103C8T6 因为是 64 的 Flash，所以选择 MD 的启动文件</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">缩写</th>\n<th style=\"text-align:center\">释义</th>\n<th style=\"text-align:center\">Flash 容量</th>\n<th style=\"text-align:center\">型号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">LD_VL</td>\n<td style=\"text-align:center\">小容量产品超值系列</td>\n<td style=\"text-align:center\">16~32K</td>\n<td style=\"text-align:center\">STM32F100</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MD_VL</td>\n<td style=\"text-align:center\">中容量产品超值系列</td>\n<td style=\"text-align:center\">64~128K</td>\n<td style=\"text-align:center\">STM32F100</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">HD_VL</td>\n<td style=\"text-align:center\">大容量产品超值系列</td>\n<td style=\"text-align:center\">256~512K</td>\n<td style=\"text-align:center\">STM32F100</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LD</td>\n<td style=\"text-align:center\">小容量产品</td>\n<td style=\"text-align:center\">16~32K</td>\n<td style=\"text-align:center\">STM32F101/102/103</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MD</td>\n<td style=\"text-align:center\">中容量产品</td>\n<td style=\"text-align:center\">64~128K</td>\n<td style=\"text-align:center\">STM32F101/102/103</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">HD</td>\n<td style=\"text-align:center\">大容量产品</td>\n<td style=\"text-align:center\">256~512K</td>\n<td style=\"text-align:center\">STM32F101/102/103</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">XL</td>\n<td style=\"text-align:center\">加大容量产品</td>\n<td style=\"text-align:center\">大于 512K</td>\n<td style=\"text-align:center\">STM32F101/102/103</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CL</td>\n<td style=\"text-align:center\">互联型产品</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">STM32F105/107</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"工程架构讲解\"><a class=\"anchor\" href=\"#工程架构讲解\">#</a> 工程架构讲解</h2>\n<p>​<img data-src=\"assets/image-20230829232745-0l14829.png\" alt=\"image\" />​</p>\n",
            "tags": [
                "硬件修炼手册",
                "STM32",
                "STM32"
            ]
        },
        {
            "id": "https://blog.aayu.today/hardware/stm32/20230829/",
            "url": "https://blog.aayu.today/hardware/stm32/20230829/",
            "title": "STM32学习笔记（1）简介",
            "date_published": "2023-08-29T09:47:17.000Z",
            "content_html": "<h2 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h2>\n<ul>\n<li>STM32 是 ST 公司基于 ARM Cortex-M 内核开发的 32 位微控制器</li>\n<li>STM32 常应用在嵌入式领域，如智能车、无人机、机器人、无线通信、物联网、工业控制、娱乐电子产品等</li>\n<li>STM32 功能强大、性能优异、片上资源丰富、功耗低，是一款经典的嵌入式微控制器</li>\n</ul>\n<p>​<img data-src=\"assets/image-20230829062418-b4zqa2d.png\" alt=\"image\" width=\"600px\" /></p>\n<h2 id=\"arm-简介\"><a class=\"anchor\" href=\"#arm-简介\">#</a> ARM 简介</h2>\n<ul>\n<li>ARM 既指 ARM 公司，也指 ARM 处理器内核</li>\n<li>ARM 公司是全球领先的半导体知识产权（IP）提供商，全世界超过 95% 的智能手机和平板电脑都采用 ARM 架构</li>\n<li>ARM 公司设计 ARM 内核，半导体厂商完善内核周边电路并生产芯片</li>\n</ul>\n<p class=\"gallery\" data-height=\"240\">​<img data-src=\"assets/image-20230829175000-sfot1fr.png\" alt=\"image\" />​<br />\n​<img data-src=\"assets/image-20230829085006-963k30s.png\" alt=\"image\" />​</p>\n<h2 id=\"芯片命名规则系统结构\"><a class=\"anchor\" href=\"#芯片命名规则系统结构\">#</a> 芯片命名规则 / 系统结构</h2>\n<p class=\"gallery\" data-height=\"400\">​<img data-src=\"assets/image-20230829085334-zco8aqz.png\" alt=\"image\" />​<br />\n​<img data-src=\"assets/image-20230829085412-okgln4i.png\" alt=\"image\" />​</p>\n<h2 id=\"stm32f103c8t6\"><a class=\"anchor\" href=\"#stm32f103c8t6\">#</a> STM32F103C8T6</h2>\n<ul>\n<li>系列：主流系列 STM32F1</li>\n<li>内核：ARM Cortex-M3</li>\n<li>主频：72MHz</li>\n<li>RAM：20K（SRAM）</li>\n<li>ROM：64K（Flash）</li>\n<li>供电：2.0~3.6V（标准 3.3V）</li>\n<li>封装：LQFP48</li>\n</ul>\n<p>​<img data-src=\"assets/image-20230829085113-dlbipzm.png\" alt=\"image\" />​</p>\n<h3 id=\"片上资源外设\"><a class=\"anchor\" href=\"#片上资源外设\">#</a> 片上资源 / 外设</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">英文缩写</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">英文缩写</th>\n<th style=\"text-align:center\">名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">NVIC</td>\n<td style=\"text-align:center\">嵌套向量中断控制器</td>\n<td style=\"text-align:center\">CAN</td>\n<td style=\"text-align:center\">CAN 通信</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SysTick</td>\n<td style=\"text-align:center\">系统滴答定时器</td>\n<td style=\"text-align:center\">USB</td>\n<td style=\"text-align:center\">USB 通信</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RCC</td>\n<td style=\"text-align:center\">复位和时钟控制</td>\n<td style=\"text-align:center\">RTC</td>\n<td style=\"text-align:center\">实时时钟</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GPIO</td>\n<td style=\"text-align:center\">通用 IO 口</td>\n<td style=\"text-align:center\">CRC</td>\n<td style=\"text-align:center\">CRC 校验</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">AFIO</td>\n<td style=\"text-align:center\">复用 IO 口</td>\n<td style=\"text-align:center\">PWR</td>\n<td style=\"text-align:center\">电源控制</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">EXTI</td>\n<td style=\"text-align:center\">外部中断</td>\n<td style=\"text-align:center\">BKP</td>\n<td style=\"text-align:center\">备份寄存器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TIM</td>\n<td style=\"text-align:center\">定时器</td>\n<td style=\"text-align:center\">IWDG</td>\n<td style=\"text-align:center\">独立看门狗</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ADC</td>\n<td style=\"text-align:center\">模数转换器</td>\n<td style=\"text-align:center\">WWDG</td>\n<td style=\"text-align:center\">窗口看门狗</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DMA</td>\n<td style=\"text-align:center\">直接内存访问</td>\n<td style=\"text-align:center\"><s>DAC</s></td>\n<td style=\"text-align:center\"><s>数模转换器</s></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">USART</td>\n<td style=\"text-align:center\">同步 / 异步串口通信</td>\n<td style=\"text-align:center\"><s>SDIO</s></td>\n<td style=\"text-align:center\"><s>SD 卡接口</s></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">I2C</td>\n<td style=\"text-align:center\">I2C 通信</td>\n<td style=\"text-align:center\"><s>FSMC</s></td>\n<td style=\"text-align:center\"><s>可变静态存储控制器</s></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SPI</td>\n<td style=\"text-align:center\">SPI 通信</td>\n<td style=\"text-align:center\"><s>USB OTG</s></td>\n<td style=\"text-align:center\"><s>USB 主机接口</s></td>\n</tr>\n</tbody>\n</table>\n<p>​<img data-src=\"assets/image-20230829085705-zv58vnn.png\" alt=\"image\" />​</p>\n<p>​<img data-src=\"assets/image-20230829085440-otbugzr.png\" alt=\"image\" />​</p>\n<h3 id=\"最小系统电路\"><a class=\"anchor\" href=\"#最小系统电路\">#</a> 最小系统电路</h3>\n<p>​<img data-src=\"assets/image-20230829085834-a3ncoer.png\" alt=\"image\" />​</p>\n<h2 id=\"参考资料\"><a class=\"anchor\" href=\"#参考资料\">#</a> 参考资料</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXRoNDExejdzbj9wPTI=\">STM32 入门教程</span></li>\n<li><a href=\"assets/STM32F103C8T6%E6%A0%B8%E5%BF%83%E6%9D%BF%E5%8E%9F%E7%90%86%E5%9B%BE-20230829090126-n4p7n0d.pdf\">STM32F103C8T6 核心板原理图.pdf</a></li>\n<li><a href=\"assets/STM32F103x8B_DS_CH_V10-20230829090132-snsquym.pdf\">STM32F103x8B_DS_CH_V10.pdf</a></li>\n</ul>\n",
            "tags": [
                "硬件修炼手册",
                "STM32",
                "STM32"
            ]
        },
        {
            "id": "https://blog.aayu.today/hardware/essay/20230828/",
            "url": "https://blog.aayu.today/hardware/essay/20230828/",
            "title": "PID 学习笔记",
            "date_published": "2023-08-28T15:44:28.000Z",
            "content_html": "<h2 id=\"基本介绍\"><a class=\"anchor\" href=\"#基本介绍\">#</a> 基本介绍</h2>\n<p>一种闭环控制算法</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable width=\"100%\"><mtr><mtd width=\"50%\"></mtd><mtd><mrow><mi>u</mi><mrow><mo fence=\"true\">(</mo><mi>t</mi><mo fence=\"true\">)</mo></mrow><mo>=</mo><mi>K</mi><mi>p</mi><msub><mrow><mo fence=\"true\">[</mo><mi>e</mi><mrow><mo fence=\"true\">(</mo><mi>t</mi><mo fence=\"true\">)</mo></mrow><mo>+</mo><mfrac><mn>1</mn><msub><mi>T</mi><mi>i</mi></msub></mfrac><msubsup><mo>∫</mo><mn>0</mn><mi>t</mi></msubsup><mi>e</mi><mrow><mo fence=\"true\">(</mo><mi>t</mi><mo fence=\"true\">)</mo></mrow><mi mathvariant=\"normal\">d</mi><mi>t</mi><mo>+</mo><mi>T</mi><mi>d</mi><mfrac><mrow><mi>d</mi><mi>e</mi><mrow><mo fence=\"true\">(</mo><mi>t</mi><mo fence=\"true\">)</mo></mrow></mrow><mrow><mi mathvariant=\"normal\">d</mi><mi>t</mi></mrow></mfrac><mo fence=\"true\">]</mo></mrow><mrow></mrow></msub></mrow></mtd><mtd width=\"50%\"></mtd><mtd><mtext>(连续)</mtext></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">u\\left(t\\right)=Kp\\left\\lbrack e\\left(t\\right)+\\frac{1}{T_{i}}\\int_0^{t}e\\left(t\\right)\\mathrm{d}t+Td\\frac{de\\left(t\\right)}{\\mathrm{d}t}\\right\\rbrack_{} \\tag{连续}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.5431860000000004em;vertical-align:-0.99973em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.3139999999999996em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8360000000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mop op-symbol large-op\" style=\"margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;\">∫</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5434560000000002em;\"><span style=\"top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span><span style=\"top:-3.8129000000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9119499999999999em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">d</span></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">d</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">d</span></span><span class=\"mord mathnormal\">t</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:-0.99973em;\"><span style=\"top:-1.00027em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.99973em;\"><span></span></span></span></span></span></span></span><span class=\"tag\"><span class=\"strut\" style=\"height:2.5431860000000004em;vertical-align:-0.99973em;\"></span><span class=\"mord text\"><span class=\"mord\">(</span><span class=\"mord\"><span class=\"mord cjk_fallback\">连</span><span class=\"mord cjk_fallback\">续</span></span><span class=\"mord\">)</span></span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable width=\"100%\"><mtr><mtd width=\"50%\"></mtd><mtd><mrow><msub><mi>u</mi><mi>k</mi></msub><mo>=</mo><mi>K</mi><mi>p</mi><mo>⋅</mo><msub><mi>e</mi><mi>k</mi></msub><mo>+</mo><mi>K</mi><mi>i</mi><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>k</mi></munderover><msub><mi>e</mi><mi>j</mi></msub><mo>+</mo><mi>K</mi><mi>d</mi><mrow><mo fence=\"true\">(</mo><msub><mi>e</mi><mi>k</mi></msub><mo>−</mo><msub><mi>e</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo fence=\"true\">)</mo></mrow></mrow></mtd><mtd width=\"50%\"></mtd><mtd><mtext>(离散)</mtext></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">u_{k}=Kp\\cdot e_{k}+Ki\\sum_{j=0}^{k}e_{j}+Kd\\left(e_{k}-e_{k-1}\\right) \\tag{离散}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.2498900000000006em;vertical-align:-1.4137769999999998em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.8361130000000006em;\"><span style=\"top:-1.872331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3000050000000005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.4137769999999998em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span></span><span class=\"tag\"><span class=\"strut\" style=\"height:3.2498900000000006em;vertical-align:-1.4137769999999998em;\"></span><span class=\"mord text\"><span class=\"mord\">(</span><span class=\"mord\"><span class=\"mord cjk_fallback\">离</span><span class=\"mord cjk_fallback\">散</span></span><span class=\"mord\">)</span></span></span></span></span></span></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">算法</th>\n<th style=\"text-align:center\">表达式</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">P 算法</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mi>p</mi><mo>⋅</mo><msub><mi>e</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">Kp\\cdot e_{k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>​</td>\n<td>P 算法的作用是减小测量值和理论值之间的误差（差值），让测量值不断接近理论值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D 算法</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mi>d</mi><mrow><mo fence=\"true\">(</mo><msub><mi>e</mi><mi>k</mi></msub><mo>−</mo><msub><mi>e</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo fence=\"true\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">Kd\\left(e_{k}-e_{k-1}\\right)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span></span></span></span>​</td>\n<td>D 算法的作用是 “阻尼”。如果系统误差很大或 P 参数较大，那么 P 的输出就会很大，导致系统剧烈响应，出现过冲现象，此时就需要用到 D 算法来抑制，让系统可以刚好停在理论值而不过冲。&lt;br /&gt; 就好像在水中挥拳，挥的速度越快，收到水的阻力越大，越难继续挥拳。这个 “水的阻力” 跟 D 算法的作用很像，因此可以把 D 算法理解为 “阻尼”，抑制过冲现象</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">I 算法</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mi>i</mi><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>k</mi></msubsup><msub><mi>e</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">Ki\\sum_{j=0}^{k}e_{j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.424826em;vertical-align:-0.43581800000000004em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43581800000000004em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>​</td>\n<td>I 算法的作用是消除稳态误差。当系统误差已经接近 0 时，P 的输出会很小，起不到继续减小误差的作用，导致误差始终没办法减小到 0。这个时候就需要用到 I 算法，让误差值不断累加，并将累加后的值输出</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"pid-实际应用中应注意的三个点\"><a class=\"anchor\" href=\"#pid-实际应用中应注意的三个点\">#</a> PID 实际应用中应注意的三个点</h2>\n<ol>\n<li>读取状态的时间间隔要短，例如 5ms 或 10ms</li>\n<li>每次读取的时间间隔要一致</li>\n<li>状态的读取和 PID 的计算要放在一起，不要分开</li>\n</ol>\n<h3 id=\"参考视频\"><a class=\"anchor\" href=\"#参考视频\">#</a> 参考视频</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWlQNDExeDcxWC8=\">PID 算法 - 从入门到实战！</span></li>\n</ul>\n",
            "tags": [
                "硬件修炼手册",
                "随笔",
                "PID"
            ]
        },
        {
            "id": "https://blog.aayu.today/skill/miscellaneous/20230817/",
            "url": "https://blog.aayu.today/skill/miscellaneous/20230817/",
            "title": "AR空间无法使用录制和拍照功能了（一加7T手机）",
            "date_published": "2023-08-17T15:08:04.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>之前（2023-07-14）在论坛上反馈的帖子一直没审核通过，咱也不知道为什么 / 捂脸，所以就在这里发一下吧～</p>\n<h2 id=\"设备\"><a class=\"anchor\" href=\"#设备\">#</a> 设备</h2>\n<table>\n<thead>\n<tr>\n<th>产品型号</th>\n<th>Nreal X</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>问题出现时间</td>\n<td>2023-07-14</td>\n</tr>\n<tr>\n<td>您搭配使用的产品</td>\n<td>一加 7T，安卓版本 12，ColorOS 版本 12.1，APP 版本 v3.4.0 (3982)</td>\n</tr>\n<tr>\n<td>使用场景</td>\n<td>游戏娱乐</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"问题描述\"><a class=\"anchor\" href=\"#问题描述\">#</a> 问题描述</h2>\n<p>今天突然发现，我在 AR 空间无法使用拍照和录制功能了。一点击拍照功能，眼镜画面就会直接卡死不动，APP 操作无相应反馈，只能杀死进程重新进入才行。当点击录制功能，手机会弹出「 要开始录制或投射内容吗？ 」对话框，如下图</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/08/17/202308172311430.png\" alt=\"\" /></p>\n<p>点击立即开始后，会有正常录制时 321 的倒计时，当倒计时结束后，正式开始录制时，就和点击拍照时一样了，眼睛画面卡死，APP 可以操作，但操作无响应。</p>\n<p>试验了 72HZ 和 60HZ，都无法使用拍照和录制功能</p>\n<p>奇怪的是前几周我帮官方内测 3D 模式下 72HZ 功能时，当时都还能使用拍照和录制功能，那时候我的安卓版本也是 12，但 ColorOS 版本不记得了，APP 版本是当时的内推包 v3.4.0。当时我的反馈如下</p>\n<p><img data-src=\"https://image.aayu.today/uploads/2023/08/17/202308172311056.png\" alt=\"\" /></p>\n<p>当时录制功能还是可以使用的，但现在却用不了了，所以我推测原因可能出在我的 ColorOS 版本上，但我也不记得手机推送过更新呀，就很奇了怪了。</p>\n<p>还有一点是，我打包部署运行了 NRSDK 包里的 RBGCamera-Record 示例场景，情况也和我点击录制按钮时的情况类似，会有个弹出框，点击立即开始后，眼镜画面消失，自己打包的应用程序卡死。</p>\n<p>不知道研发小哥可以复现这个问题吗，有机会可以修复它吗＞︿＜</p>\n",
            "tags": [
                "不看会后悔的实用技巧分享",
                "杂七杂八",
                "XReal"
            ]
        }
    ]
}